using System;
using System.Collections;
using System.Text.Parsing;
using Cm.Ast;

namespace Cm.Parser
{
    public class StatementGrammar: System.Text.Parsing.Grammar
    {
        public static StatementGrammar* Create()
        {
            return Create(new ParsingDomain());
        }
        public static StatementGrammar* Create(ParsingDomain* parsingDomain)
        {
            RegisterParsingDomain(parsingDomain);
            StatementGrammar* grammar = new StatementGrammar(parsingDomain);
            parsingDomain->AddGrammar(grammar);
            grammar->CreateRules();
            grammar->Link();
            return grammar;
        }
        private StatementGrammar(ParsingDomain* parsingDomain): base("StatementGrammar", parsingDomain->GetNamespaceScope("Cm.Parser"), parsingDomain)
        {
            SetOwner(0);
        }
        public StatementNode* Parse(const char* start, const char* end, int fileIndex, const string& fileName, ParsingContext* ctx)
        {
            Scanner scanner(start, end, fileIndex, fileName, SkipRule());
            System.IO.OutputStream* log = Log();
            UniquePtr<XmlLog> xmlLog;
            if (log != null)
            {
                xmlLog.Reset(new XmlLog(*log, MaxLogLineLength()));
                scanner.SetLog(xmlLog.GetPtr());
                xmlLog->WriteBeginRule("parse");
            }
            Stack<UniquePtr<Object>> stack;
            stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(ctx)));
            Match match = Parse(scanner, stack);
            Span stop = scanner.GetSpan();
            if (log != null)
            {
                xmlLog->WriteEndRule("parse");
            }
            if (!match.Hit() || stop.Start() != int(end - start))
            {
                Rule* startRule = StartRule();
                if (startRule != null)
                {
                    throw ExpectationFailure(startRule->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + Name() + "' has no start rule", fileName, stop, start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            StatementNode* result = *cast<ValueObject<StatementNode*>*>(value.GetPtr());
            return result;
        }
        private class StatementRule: System.Text.Parsing.Rule
        {
            public StatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                ActionParser* a3ActionParser = GetAction("A3");
                a3ActionParser->SetAction(ParsingAction(A3Action));
                ActionParser* a4ActionParser = GetAction("A4");
                a4ActionParser->SetAction(ParsingAction(A4Action));
                ActionParser* a5ActionParser = GetAction("A5");
                a5ActionParser->SetAction(ParsingAction(A5Action));
                ActionParser* a6ActionParser = GetAction("A6");
                a6ActionParser->SetAction(ParsingAction(A6Action));
                ActionParser* a7ActionParser = GetAction("A7");
                a7ActionParser->SetAction(ParsingAction(A7Action));
                ActionParser* a8ActionParser = GetAction("A8");
                a8ActionParser->SetAction(ParsingAction(A8Action));
                ActionParser* a9ActionParser = GetAction("A9");
                a9ActionParser->SetAction(ParsingAction(A9Action));
                ActionParser* a10ActionParser = GetAction("A10");
                a10ActionParser->SetAction(ParsingAction(A10Action));
                ActionParser* a11ActionParser = GetAction("A11");
                a11ActionParser->SetAction(ParsingAction(A11Action));
                NonterminalParser* labeledStatementNonterminalParser = GetNonterminal("LabeledStatement");
                labeledStatementNonterminalParser->SetPreCall(PreCall(PreLabeledStatement));
                labeledStatementNonterminalParser->SetPostCall(PostCall(PostLabeledStatement));
                NonterminalParser* controlStatementNonterminalParser = GetNonterminal("ControlStatement");
                controlStatementNonterminalParser->SetPreCall(PreCall(PreControlStatement));
                controlStatementNonterminalParser->SetPostCall(PostCall(PostControlStatement));
                NonterminalParser* typedefStatementNonterminalParser = GetNonterminal("TypedefStatement");
                typedefStatementNonterminalParser->SetPreCall(PreCall(PreTypedefStatement));
                typedefStatementNonterminalParser->SetPostCall(PostCall(PostTypedefStatement));
                NonterminalParser* simpleStatementNonterminalParser = GetNonterminal("SimpleStatement");
                simpleStatementNonterminalParser->SetPreCall(PreCall(PreSimpleStatement));
                simpleStatementNonterminalParser->SetPostCall(PostCall(PostSimpleStatement));
                NonterminalParser* assignmentStatementNonterminalParser = GetNonterminal("AssignmentStatement");
                assignmentStatementNonterminalParser->SetPreCall(PreCall(PreAssignmentStatement));
                assignmentStatementNonterminalParser->SetPostCall(PostCall(PostAssignmentStatement));
                NonterminalParser* constructionStatementNonterminalParser = GetNonterminal("ConstructionStatement");
                constructionStatementNonterminalParser->SetPreCall(PreCall(PreConstructionStatement));
                constructionStatementNonterminalParser->SetPostCall(PostCall(PostConstructionStatement));
                NonterminalParser* deleteStatementNonterminalParser = GetNonterminal("DeleteStatement");
                deleteStatementNonterminalParser->SetPreCall(PreCall(PreDeleteStatement));
                deleteStatementNonterminalParser->SetPostCall(PostCall(PostDeleteStatement));
                NonterminalParser* destroyStatementNonterminalParser = GetNonterminal("DestroyStatement");
                destroyStatementNonterminalParser->SetPreCall(PreCall(PreDestroyStatement));
                destroyStatementNonterminalParser->SetPostCall(PostCall(PostDestroyStatement));
                NonterminalParser* throwStatementNonterminalParser = GetNonterminal("ThrowStatement");
                throwStatementNonterminalParser->SetPreCall(PreCall(PreThrowStatement));
                throwStatementNonterminalParser->SetPostCall(PostCall(PostThrowStatement));
                NonterminalParser* tryStatementNonterminalParser = GetNonterminal("TryStatement");
                tryStatementNonterminalParser->SetPreCall(PreCall(PreTryStatement));
                tryStatementNonterminalParser->SetPostCall(PostCall(PostTryStatement));
                NonterminalParser* assertStatementNonterminalParser = GetNonterminal("AssertStatement");
                assertStatementNonterminalParser->SetPreCall(PreCall(PreAssertStatement));
                assertStatementNonterminalParser->SetPostCall(PostCall(PostAssertStatement));
                NonterminalParser* conditionalCompilationStatementNonterminalParser = GetNonterminal("ConditionalCompilationStatement");
                conditionalCompilationStatementNonterminalParser->SetPreCall(PreCall(PreConditionalCompilationStatement));
                conditionalCompilationStatementNonterminalParser->SetPostCall(PostCall(PostConditionalCompilationStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromLabeledStatement;
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromControlStatement;
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromTypedefStatement;
            }
            public throw void A3Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromSimpleStatement;
            }
            public throw void A4Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromAssignmentStatement;
            }
            public throw void A5Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromConstructionStatement;
            }
            public throw void A6Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromDeleteStatement;
            }
            public throw void A7Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromDestroyStatement;
            }
            public throw void A8Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromThrowStatement;
            }
            public throw void A9Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromTryStatement;
            }
            public throw void A10Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromAssertStatement;
            }
            public throw void A11Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromConditionalCompilationStatement;
            }
            public throw void PreLabeledStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostLabeledStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromLabeledStatement_value = stack.Pop();
                    context.fromLabeledStatement = *cast<ValueObject<StatementNode*>*>(fromLabeledStatement_value.GetPtr());
                }
            }
            public throw void PreControlStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostControlStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromControlStatement_value = stack.Pop();
                    context.fromControlStatement = *cast<ValueObject<StatementNode*>*>(fromControlStatement_value.GetPtr());
                }
            }
            public throw void PreTypedefStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostTypedefStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromTypedefStatement_value = stack.Pop();
                    context.fromTypedefStatement = *cast<ValueObject<StatementNode*>*>(fromTypedefStatement_value.GetPtr());
                }
            }
            public throw void PreSimpleStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostSimpleStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromSimpleStatement_value = stack.Pop();
                    context.fromSimpleStatement = *cast<ValueObject<StatementNode*>*>(fromSimpleStatement_value.GetPtr());
                }
            }
            public throw void PreAssignmentStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostAssignmentStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentStatement_value = stack.Pop();
                    context.fromAssignmentStatement = *cast<ValueObject<StatementNode*>*>(fromAssignmentStatement_value.GetPtr());
                }
            }
            public throw void PreConstructionStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostConstructionStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromConstructionStatement_value = stack.Pop();
                    context.fromConstructionStatement = *cast<ValueObject<StatementNode*>*>(fromConstructionStatement_value.GetPtr());
                }
            }
            public throw void PreDeleteStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostDeleteStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromDeleteStatement_value = stack.Pop();
                    context.fromDeleteStatement = *cast<ValueObject<StatementNode*>*>(fromDeleteStatement_value.GetPtr());
                }
            }
            public throw void PreDestroyStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostDestroyStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromDestroyStatement_value = stack.Pop();
                    context.fromDestroyStatement = *cast<ValueObject<StatementNode*>*>(fromDestroyStatement_value.GetPtr());
                }
            }
            public throw void PreThrowStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostThrowStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromThrowStatement_value = stack.Pop();
                    context.fromThrowStatement = *cast<ValueObject<StatementNode*>*>(fromThrowStatement_value.GetPtr());
                }
            }
            public throw void PreTryStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostTryStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromTryStatement_value = stack.Pop();
                    context.fromTryStatement = *cast<ValueObject<TryStatementNode*>*>(fromTryStatement_value.GetPtr());
                }
            }
            public throw void PreAssertStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostAssertStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromAssertStatement_value = stack.Pop();
                    context.fromAssertStatement = *cast<ValueObject<StatementNode*>*>(fromAssertStatement_value.GetPtr());
                }
            }
            public throw void PreConditionalCompilationStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostConditionalCompilationStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromConditionalCompilationStatement_value = stack.Pop();
                    context.fromConditionalCompilationStatement = *cast<ValueObject<CondCompStatementNode*>*>(fromConditionalCompilationStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public StatementNode* fromLabeledStatement;
                public StatementNode* fromControlStatement;
                public StatementNode* fromTypedefStatement;
                public StatementNode* fromSimpleStatement;
                public StatementNode* fromAssignmentStatement;
                public StatementNode* fromConstructionStatement;
                public StatementNode* fromDeleteStatement;
                public StatementNode* fromDestroyStatement;
                public StatementNode* fromThrowStatement;
                public TryStatementNode* fromTryStatement;
                public StatementNode* fromAssertStatement;
                public CondCompStatementNode* fromConditionalCompilationStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class LabelIdRule: System.Text.Parsing.Rule
        {
            public LabelIdRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("string");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<string>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* identifierNonterminalParser = GetNonterminal("identifier");
                identifierNonterminalParser->SetPostCall(PostCall(Postidentifier));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = string(matchBegin, matchEnd);
            }
            public throw void Postidentifier(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromidentifier_value = stack.Pop();
                    context.fromidentifier = *cast<ValueObject<string>*>(fromidentifier_value.GetPtr());
                }
            }
            private class Context
            {
                public string value;
                public string fromidentifier;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class LabelRule: System.Text.Parsing.Rule
        {
            public LabelRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("LabelNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<LabelNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* labelIdNonterminalParser = GetNonterminal("LabelId");
                labelIdNonterminalParser->SetPostCall(PostCall(PostLabelId));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new LabelNode(span, context.fromLabelId);
            }
            public throw void PostLabelId(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromLabelId_value = stack.Pop();
                    context.fromLabelId = *cast<ValueObject<string>*>(fromLabelId_value.GetPtr());
                }
            }
            private class Context
            {
                public LabelNode* value;
                public string fromLabelId;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class TargetLabelRule: System.Text.Parsing.Rule
        {
            public TargetLabelRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("LabelNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<LabelNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* labelIdNonterminalParser = GetNonterminal("LabelId");
                labelIdNonterminalParser->SetPostCall(PostCall(PostLabelId));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new LabelNode(span, context.fromLabelId);
            }
            public throw void PostLabelId(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromLabelId_value = stack.Pop();
                    context.fromLabelId = *cast<ValueObject<string>*>(fromLabelId_value.GetPtr());
                }
            }
            private class Context
            {
                public LabelNode* value;
                public string fromLabelId;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class LabeledStatementRule: System.Text.Parsing.Rule
        {
            public LabeledStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* labelNonterminalParser = GetNonterminal("Label");
                labelNonterminalParser->SetPostCall(PostCall(PostLabel));
                NonterminalParser* statementNonterminalParser = GetNonterminal("Statement");
                statementNonterminalParser->SetPreCall(PreCall(PreStatement));
                statementNonterminalParser->SetPostCall(PostCall(PostStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.fromStatement->SetLabelNode(context.fromLabel);
                context.value = context.fromStatement;
            }
            public throw void PostLabel(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromLabel_value = stack.Pop();
                    context.fromLabel = *cast<ValueObject<LabelNode*>*>(fromLabel_value.GetPtr());
                }
            }
            public throw void PreStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context.fromStatement = *cast<ValueObject<StatementNode*>*>(fromStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public LabelNode* fromLabel;
                public StatementNode* fromStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class SimpleStatementRule: System.Text.Parsing.Rule
        {
            public SimpleStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
                AddLocalVariable(AttrOrVariable("UniquePtr<Node>", "expr"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                a0ActionParser->SetFailureAction(FailureAction(A0ActionFail));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.ctx->PopParsingSimpleStatement();
                context.value = new SimpleStatementNode(span, context.expr.Release());
            }
            public throw void A0ActionFail()
            {
                context.ctx->PopParsingSimpleStatement();
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.ctx->PushParsingSimpleStatement(true);
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.expr.Reset(context.fromExpression);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public UniquePtr<Node> expr;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ControlStatementRule: System.Text.Parsing.Rule
        {
            public ControlStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                ActionParser* a3ActionParser = GetAction("A3");
                a3ActionParser->SetAction(ParsingAction(A3Action));
                ActionParser* a4ActionParser = GetAction("A4");
                a4ActionParser->SetAction(ParsingAction(A4Action));
                ActionParser* a5ActionParser = GetAction("A5");
                a5ActionParser->SetAction(ParsingAction(A5Action));
                ActionParser* a6ActionParser = GetAction("A6");
                a6ActionParser->SetAction(ParsingAction(A6Action));
                ActionParser* a7ActionParser = GetAction("A7");
                a7ActionParser->SetAction(ParsingAction(A7Action));
                ActionParser* a8ActionParser = GetAction("A8");
                a8ActionParser->SetAction(ParsingAction(A8Action));
                ActionParser* a9ActionParser = GetAction("A9");
                a9ActionParser->SetAction(ParsingAction(A9Action));
                ActionParser* a10ActionParser = GetAction("A10");
                a10ActionParser->SetAction(ParsingAction(A10Action));
                ActionParser* a11ActionParser = GetAction("A11");
                a11ActionParser->SetAction(ParsingAction(A11Action));
                ActionParser* a12ActionParser = GetAction("A12");
                a12ActionParser->SetAction(ParsingAction(A12Action));
                NonterminalParser* returnStatementNonterminalParser = GetNonterminal("ReturnStatement");
                returnStatementNonterminalParser->SetPreCall(PreCall(PreReturnStatement));
                returnStatementNonterminalParser->SetPostCall(PostCall(PostReturnStatement));
                NonterminalParser* conditionalStatementNonterminalParser = GetNonterminal("ConditionalStatement");
                conditionalStatementNonterminalParser->SetPreCall(PreCall(PreConditionalStatement));
                conditionalStatementNonterminalParser->SetPostCall(PostCall(PostConditionalStatement));
                NonterminalParser* switchStatementNonterminalParser = GetNonterminal("SwitchStatement");
                switchStatementNonterminalParser->SetPreCall(PreCall(PreSwitchStatement));
                switchStatementNonterminalParser->SetPostCall(PostCall(PostSwitchStatement));
                NonterminalParser* whileStatementNonterminalParser = GetNonterminal("WhileStatement");
                whileStatementNonterminalParser->SetPreCall(PreCall(PreWhileStatement));
                whileStatementNonterminalParser->SetPostCall(PostCall(PostWhileStatement));
                NonterminalParser* doStatementNonterminalParser = GetNonterminal("DoStatement");
                doStatementNonterminalParser->SetPreCall(PreCall(PreDoStatement));
                doStatementNonterminalParser->SetPostCall(PostCall(PostDoStatement));
                NonterminalParser* rangeForStatementNonterminalParser = GetNonterminal("RangeForStatement");
                rangeForStatementNonterminalParser->SetPreCall(PreCall(PreRangeForStatement));
                rangeForStatementNonterminalParser->SetPostCall(PostCall(PostRangeForStatement));
                NonterminalParser* forStatementNonterminalParser = GetNonterminal("ForStatement");
                forStatementNonterminalParser->SetPreCall(PreCall(PreForStatement));
                forStatementNonterminalParser->SetPostCall(PostCall(PostForStatement));
                NonterminalParser* compoundStatementNonterminalParser = GetNonterminal("CompoundStatement");
                compoundStatementNonterminalParser->SetPreCall(PreCall(PreCompoundStatement));
                compoundStatementNonterminalParser->SetPostCall(PostCall(PostCompoundStatement));
                NonterminalParser* breakStatementNonterminalParser = GetNonterminal("BreakStatement");
                breakStatementNonterminalParser->SetPostCall(PostCall(PostBreakStatement));
                NonterminalParser* continueStatementNonterminalParser = GetNonterminal("ContinueStatement");
                continueStatementNonterminalParser->SetPostCall(PostCall(PostContinueStatement));
                NonterminalParser* gotoCaseStatementNonterminalParser = GetNonterminal("GotoCaseStatement");
                gotoCaseStatementNonterminalParser->SetPreCall(PreCall(PreGotoCaseStatement));
                gotoCaseStatementNonterminalParser->SetPostCall(PostCall(PostGotoCaseStatement));
                NonterminalParser* gotoDefaultStatementNonterminalParser = GetNonterminal("GotoDefaultStatement");
                gotoDefaultStatementNonterminalParser->SetPostCall(PostCall(PostGotoDefaultStatement));
                NonterminalParser* gotoStatementNonterminalParser = GetNonterminal("GotoStatement");
                gotoStatementNonterminalParser->SetPostCall(PostCall(PostGotoStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromReturnStatement;
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromConditionalStatement;
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromSwitchStatement;
            }
            public throw void A3Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromWhileStatement;
            }
            public throw void A4Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromDoStatement;
            }
            public throw void A5Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromRangeForStatement;
            }
            public throw void A6Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromForStatement;
            }
            public throw void A7Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromCompoundStatement;
            }
            public throw void A8Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromBreakStatement;
            }
            public throw void A9Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromContinueStatement;
            }
            public throw void A10Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromGotoCaseStatement;
            }
            public throw void A11Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromGotoDefaultStatement;
            }
            public throw void A12Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromGotoStatement;
            }
            public throw void PreReturnStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostReturnStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromReturnStatement_value = stack.Pop();
                    context.fromReturnStatement = *cast<ValueObject<StatementNode*>*>(fromReturnStatement_value.GetPtr());
                }
            }
            public throw void PreConditionalStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostConditionalStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromConditionalStatement_value = stack.Pop();
                    context.fromConditionalStatement = *cast<ValueObject<StatementNode*>*>(fromConditionalStatement_value.GetPtr());
                }
            }
            public throw void PreSwitchStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostSwitchStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromSwitchStatement_value = stack.Pop();
                    context.fromSwitchStatement = *cast<ValueObject<SwitchStatementNode*>*>(fromSwitchStatement_value.GetPtr());
                }
            }
            public throw void PreWhileStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostWhileStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromWhileStatement_value = stack.Pop();
                    context.fromWhileStatement = *cast<ValueObject<StatementNode*>*>(fromWhileStatement_value.GetPtr());
                }
            }
            public throw void PreDoStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostDoStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromDoStatement_value = stack.Pop();
                    context.fromDoStatement = *cast<ValueObject<StatementNode*>*>(fromDoStatement_value.GetPtr());
                }
            }
            public throw void PreRangeForStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostRangeForStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromRangeForStatement_value = stack.Pop();
                    context.fromRangeForStatement = *cast<ValueObject<StatementNode*>*>(fromRangeForStatement_value.GetPtr());
                }
            }
            public throw void PreForStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostForStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromForStatement_value = stack.Pop();
                    context.fromForStatement = *cast<ValueObject<StatementNode*>*>(fromForStatement_value.GetPtr());
                }
            }
            public throw void PreCompoundStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostCompoundStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromCompoundStatement_value = stack.Pop();
                    context.fromCompoundStatement = *cast<ValueObject<CompoundStatementNode*>*>(fromCompoundStatement_value.GetPtr());
                }
            }
            public throw void PostBreakStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromBreakStatement_value = stack.Pop();
                    context.fromBreakStatement = *cast<ValueObject<StatementNode*>*>(fromBreakStatement_value.GetPtr());
                }
            }
            public throw void PostContinueStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromContinueStatement_value = stack.Pop();
                    context.fromContinueStatement = *cast<ValueObject<StatementNode*>*>(fromContinueStatement_value.GetPtr());
                }
            }
            public throw void PreGotoCaseStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostGotoCaseStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromGotoCaseStatement_value = stack.Pop();
                    context.fromGotoCaseStatement = *cast<ValueObject<StatementNode*>*>(fromGotoCaseStatement_value.GetPtr());
                }
            }
            public throw void PostGotoDefaultStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromGotoDefaultStatement_value = stack.Pop();
                    context.fromGotoDefaultStatement = *cast<ValueObject<StatementNode*>*>(fromGotoDefaultStatement_value.GetPtr());
                }
            }
            public throw void PostGotoStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromGotoStatement_value = stack.Pop();
                    context.fromGotoStatement = *cast<ValueObject<StatementNode*>*>(fromGotoStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public StatementNode* fromReturnStatement;
                public StatementNode* fromConditionalStatement;
                public SwitchStatementNode* fromSwitchStatement;
                public StatementNode* fromWhileStatement;
                public StatementNode* fromDoStatement;
                public StatementNode* fromRangeForStatement;
                public StatementNode* fromForStatement;
                public CompoundStatementNode* fromCompoundStatement;
                public StatementNode* fromBreakStatement;
                public StatementNode* fromContinueStatement;
                public StatementNode* fromGotoCaseStatement;
                public StatementNode* fromGotoDefaultStatement;
                public StatementNode* fromGotoStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ReturnStatementRule: System.Text.Parsing.Rule
        {
            public ReturnStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new ReturnStatementNode(span, context.fromExpression);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ConditionalStatementRule: System.Text.Parsing.Rule
        {
            public ConditionalStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
                NonterminalParser* thenSNonterminalParser = GetNonterminal("thenS");
                thenSNonterminalParser->SetPreCall(PreCall(PrethenS));
                thenSNonterminalParser->SetPostCall(PostCall(PostthenS));
                NonterminalParser* elseSNonterminalParser = GetNonterminal("elseS");
                elseSNonterminalParser->SetPreCall(PreCall(PreelseS));
                elseSNonterminalParser->SetPostCall(PostCall(PostelseS));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new ConditionalStatementNode(span, context.fromExpression, context.fromthenS, context.fromelseS);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            public throw void PrethenS(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostthenS(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromthenS_value = stack.Pop();
                    context.fromthenS = *cast<ValueObject<StatementNode*>*>(fromthenS_value.GetPtr());
                }
            }
            public throw void PreelseS(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostelseS(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromelseS_value = stack.Pop();
                    context.fromelseS = *cast<ValueObject<StatementNode*>*>(fromelseS_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
                public StatementNode* fromthenS;
                public StatementNode* fromelseS;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class SwitchStatementRule: System.Text.Parsing.Rule
        {
            public SwitchStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("SwitchStatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<SwitchStatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                ActionParser* a3ActionParser = GetAction("A3");
                a3ActionParser->SetAction(ParsingAction(A3Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
                NonterminalParser* caseStatementNonterminalParser = GetNonterminal("CaseStatement");
                caseStatementNonterminalParser->SetPreCall(PreCall(PreCaseStatement));
                caseStatementNonterminalParser->SetPostCall(PostCall(PostCaseStatement));
                NonterminalParser* defaultStatementNonterminalParser = GetNonterminal("DefaultStatement");
                defaultStatementNonterminalParser->SetPreCall(PreCall(PreDefaultStatement));
                defaultStatementNonterminalParser->SetPostCall(PostCall(PostDefaultStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new SwitchStatementNode(span, context.fromExpression);
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->AddCase(context.fromCaseStatement);
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->SetDefault(context.fromDefaultStatement);
            }
            public throw void A3Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->GetSpan().SetEnd(span.End());
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            public throw void PreCaseStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostCaseStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromCaseStatement_value = stack.Pop();
                    context.fromCaseStatement = *cast<ValueObject<CaseStatementNode*>*>(fromCaseStatement_value.GetPtr());
                }
            }
            public throw void PreDefaultStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostDefaultStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromDefaultStatement_value = stack.Pop();
                    context.fromDefaultStatement = *cast<ValueObject<DefaultStatementNode*>*>(fromDefaultStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public SwitchStatementNode* value;
                public Node* fromExpression;
                public CaseStatementNode* fromCaseStatement;
                public DefaultStatementNode* fromDefaultStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class CaseStatementRule: System.Text.Parsing.Rule
        {
            public CaseStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("CaseStatementNode*");
                AddLocalVariable(AttrOrVariable("UniquePtr<CaseStatementNode>", "caseS"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CaseStatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                ActionParser* a3ActionParser = GetAction("A3");
                a3ActionParser->SetAction(ParsingAction(A3Action));
                NonterminalParser* caseListNonterminalParser = GetNonterminal("CaseList");
                caseListNonterminalParser->SetPreCall(PreCall(PreCaseList));
                NonterminalParser* statementNonterminalParser = GetNonterminal("Statement");
                statementNonterminalParser->SetPreCall(PreCall(PreStatement));
                statementNonterminalParser->SetPostCall(PostCall(PostStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.caseS.Release();
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.caseS.Reset(new CaseStatementNode(span));
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.caseS->GetSpan().SetEnd(span.End());
            }
            public throw void A3Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.caseS->AddStatement(context.fromStatement);
            }
            public throw void PreCaseList(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
                stack.Push(UniquePtr<Object>(new ValueObject<CaseStatementNode*>(context.caseS.GetPtr())));
            }
            public throw void PreStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context.fromStatement = *cast<ValueObject<StatementNode*>*>(fromStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public CaseStatementNode* value;
                public UniquePtr<CaseStatementNode> caseS;
                public StatementNode* fromStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class DefaultStatementRule: System.Text.Parsing.Rule
        {
            public DefaultStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("DefaultStatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<DefaultStatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                NonterminalParser* statementNonterminalParser = GetNonterminal("Statement");
                statementNonterminalParser->SetPreCall(PreCall(PreStatement));
                statementNonterminalParser->SetPostCall(PostCall(PostStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new DefaultStatementNode(span);
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->AddStatement(context.fromStatement);
            }
            public throw void PreStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context.fromStatement = *cast<ValueObject<StatementNode*>*>(fromStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public DefaultStatementNode* value;
                public StatementNode* fromStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class CaseListRule: System.Text.Parsing.Rule
        {
            public CaseListRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                AddInheritedAttribute(AttrOrVariable("CaseStatementNode*", "caseS"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> caseS_value = stack.Pop();
                context.caseS = *cast<ValueObject<CaseStatementNode*>*>(caseS_value.GetPtr());
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.caseS->AddExpr(context.fromExpression);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public CaseStatementNode* caseS;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class GotoCaseStatementRule: System.Text.Parsing.Rule
        {
            public GotoCaseStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new GotoCaseStatementNode(span, context.fromExpression);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class GotoDefaultStatementRule: System.Text.Parsing.Rule
        {
            public GotoDefaultStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new GotoDefaultStatementNode(span);
            }
            private class Context
            {
                public StatementNode* value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class WhileStatementRule: System.Text.Parsing.Rule
        {
            public WhileStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
                NonterminalParser* statementNonterminalParser = GetNonterminal("Statement");
                statementNonterminalParser->SetPreCall(PreCall(PreStatement));
                statementNonterminalParser->SetPostCall(PostCall(PostStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new WhileStatementNode(span, context.fromExpression, context.fromStatement);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            public throw void PreStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context.fromStatement = *cast<ValueObject<StatementNode*>*>(fromStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
                public StatementNode* fromStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class DoStatementRule: System.Text.Parsing.Rule
        {
            public DoStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* statementNonterminalParser = GetNonterminal("Statement");
                statementNonterminalParser->SetPreCall(PreCall(PreStatement));
                statementNonterminalParser->SetPostCall(PostCall(PostStatement));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new DoStatementNode(span, context.fromStatement, context.fromExpression);
            }
            public throw void PreStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context.fromStatement = *cast<ValueObject<StatementNode*>*>(fromStatement_value.GetPtr());
                }
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public StatementNode* fromStatement;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class RangeForStatementRule: System.Text.Parsing.Rule
        {
            public RangeForStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
                AddLocalVariable(AttrOrVariable("UniquePtr<Node>", "varType"));
                AddLocalVariable(AttrOrVariable("UniquePtr<IdentifierNode>", "varId"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                NonterminalParser* typeExprNonterminalParser = GetNonterminal("TypeExpr");
                typeExprNonterminalParser->SetPreCall(PreCall(PreTypeExpr));
                typeExprNonterminalParser->SetPostCall(PostCall(PostTypeExpr));
                NonterminalParser* identifierNonterminalParser = GetNonterminal("Identifier");
                identifierNonterminalParser->SetPostCall(PostCall(PostIdentifier));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
                NonterminalParser* statementNonterminalParser = GetNonterminal("Statement");
                statementNonterminalParser->SetPreCall(PreCall(PreStatement));
                statementNonterminalParser->SetPostCall(PostCall(PostStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new RangeForStatementNode(span, context.varType.Release(), context.varId.Release(), context.fromExpression, context.fromStatement);
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.varType.Reset(context.fromTypeExpr);
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.varId.Reset(context.fromIdentifier);
            }
            public throw void PreTypeExpr(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostTypeExpr(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context.fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.GetPtr());
                }
            }
            public throw void PostIdentifier(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context.fromIdentifier = *cast<ValueObject<IdentifierNode*>*>(fromIdentifier_value.GetPtr());
                }
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            public throw void PreStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context.fromStatement = *cast<ValueObject<StatementNode*>*>(fromStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public UniquePtr<Node> varType;
                public UniquePtr<IdentifierNode> varId;
                public Node* fromTypeExpr;
                public IdentifierNode* fromIdentifier;
                public Node* fromExpression;
                public StatementNode* fromStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ForStatementRule: System.Text.Parsing.Rule
        {
            public ForStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* forInitStatementNonterminalParser = GetNonterminal("ForInitStatement");
                forInitStatementNonterminalParser->SetPreCall(PreCall(PreForInitStatement));
                forInitStatementNonterminalParser->SetPostCall(PostCall(PostForInitStatement));
                NonterminalParser* conditionNonterminalParser = GetNonterminal("condition");
                conditionNonterminalParser->SetPreCall(PreCall(Precondition));
                conditionNonterminalParser->SetPostCall(PostCall(Postcondition));
                NonterminalParser* incrementNonterminalParser = GetNonterminal("increment");
                incrementNonterminalParser->SetPreCall(PreCall(Preincrement));
                incrementNonterminalParser->SetPostCall(PostCall(Postincrement));
                NonterminalParser* statementNonterminalParser = GetNonterminal("Statement");
                statementNonterminalParser->SetPreCall(PreCall(PreStatement));
                statementNonterminalParser->SetPostCall(PostCall(PostStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new ForStatementNode(span, context.fromForInitStatement, context.fromcondition, context.fromincrement, context.fromStatement);
            }
            public throw void PreForInitStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostForInitStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromForInitStatement_value = stack.Pop();
                    context.fromForInitStatement = *cast<ValueObject<StatementNode*>*>(fromForInitStatement_value.GetPtr());
                }
            }
            public throw void Precondition(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void Postcondition(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromcondition_value = stack.Pop();
                    context.fromcondition = *cast<ValueObject<Node*>*>(fromcondition_value.GetPtr());
                }
            }
            public throw void Preincrement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void Postincrement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromincrement_value = stack.Pop();
                    context.fromincrement = *cast<ValueObject<Node*>*>(fromincrement_value.GetPtr());
                }
            }
            public throw void PreStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context.fromStatement = *cast<ValueObject<StatementNode*>*>(fromStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public StatementNode* fromForInitStatement;
                public Node* fromcondition;
                public Node* fromincrement;
                public StatementNode* fromStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ForInitStatementRule: System.Text.Parsing.Rule
        {
            public ForInitStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                NonterminalParser* assignmentStatementNonterminalParser = GetNonterminal("AssignmentStatement");
                assignmentStatementNonterminalParser->SetPreCall(PreCall(PreAssignmentStatement));
                assignmentStatementNonterminalParser->SetPostCall(PostCall(PostAssignmentStatement));
                NonterminalParser* constructionStatementNonterminalParser = GetNonterminal("ConstructionStatement");
                constructionStatementNonterminalParser->SetPreCall(PreCall(PreConstructionStatement));
                constructionStatementNonterminalParser->SetPostCall(PostCall(PostConstructionStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromAssignmentStatement;
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromConstructionStatement;
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new SimpleStatementNode(span, null);
            }
            public throw void PreAssignmentStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostAssignmentStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentStatement_value = stack.Pop();
                    context.fromAssignmentStatement = *cast<ValueObject<StatementNode*>*>(fromAssignmentStatement_value.GetPtr());
                }
            }
            public throw void PreConstructionStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostConstructionStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromConstructionStatement_value = stack.Pop();
                    context.fromConstructionStatement = *cast<ValueObject<StatementNode*>*>(fromConstructionStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public StatementNode* fromAssignmentStatement;
                public StatementNode* fromConstructionStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class CompoundStatementRule: System.Text.Parsing.Rule
        {
            public CompoundStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("CompoundStatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CompoundStatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                ActionParser* a3ActionParser = GetAction("A3");
                a3ActionParser->SetAction(ParsingAction(A3Action));
                NonterminalParser* statementNonterminalParser = GetNonterminal("Statement");
                statementNonterminalParser->SetPreCall(PreCall(PreStatement));
                statementNonterminalParser->SetPostCall(PostCall(PostStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->GetSpan().SetEnd(span.End());
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new CompoundStatementNode(span);
                context.value->SetBeginBraceSpan(span);
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->AddStatement(context.fromStatement);
            }
            public throw void A3Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->SetEndBraceSpan(span);
            }
            public throw void PreStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context.fromStatement = *cast<ValueObject<StatementNode*>*>(fromStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public CompoundStatementNode* value;
                public StatementNode* fromStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class BreakStatementRule: System.Text.Parsing.Rule
        {
            public BreakStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new BreakStatementNode(span);
            }
            private class Context
            {
                public StatementNode* value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ContinueStatementRule: System.Text.Parsing.Rule
        {
            public ContinueStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new ContinueStatementNode(span);
            }
            private class Context
            {
                public StatementNode* value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class GotoStatementRule: System.Text.Parsing.Rule
        {
            public GotoStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* targetLabelNonterminalParser = GetNonterminal("TargetLabel");
                targetLabelNonterminalParser->SetPostCall(PostCall(PostTargetLabel));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new GotoStatementNode(span, context.fromTargetLabel);
            }
            public throw void PostTargetLabel(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromTargetLabel_value = stack.Pop();
                    context.fromTargetLabel = *cast<ValueObject<LabelNode*>*>(fromTargetLabel_value.GetPtr());
                }
            }
            private class Context
            {
                public StatementNode* value;
                public LabelNode* fromTargetLabel;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class TypedefStatementRule: System.Text.Parsing.Rule
        {
            public TypedefStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* typeExprNonterminalParser = GetNonterminal("TypeExpr");
                typeExprNonterminalParser->SetPreCall(PreCall(PreTypeExpr));
                typeExprNonterminalParser->SetPostCall(PostCall(PostTypeExpr));
                NonterminalParser* identifierNonterminalParser = GetNonterminal("Identifier");
                identifierNonterminalParser->SetPostCall(PostCall(PostIdentifier));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new TypedefStatementNode(span, context.fromTypeExpr, context.fromIdentifier);
            }
            public throw void PreTypeExpr(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostTypeExpr(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context.fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.GetPtr());
                }
            }
            public throw void PostIdentifier(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context.fromIdentifier = *cast<ValueObject<IdentifierNode*>*>(fromIdentifier_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromTypeExpr;
                public IdentifierNode* fromIdentifier;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class AssignmentStatementRule: System.Text.Parsing.Rule
        {
            public AssignmentStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
                AddLocalVariable(AttrOrVariable("UniquePtr<Node>", "targetExpr"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                a2ActionParser->SetFailureAction(FailureAction(A2ActionFail));
                NonterminalParser* targetNonterminalParser = GetNonterminal("target");
                targetNonterminalParser->SetPreCall(PreCall(Pretarget));
                targetNonterminalParser->SetPostCall(PostCall(Posttarget));
                NonterminalParser* sourceNonterminalParser = GetNonterminal("source");
                sourceNonterminalParser->SetPreCall(PreCall(Presource));
                sourceNonterminalParser->SetPostCall(PostCall(Postsource));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.ctx->PushParsingLvalue(true);
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new AssignmentStatementNode(span, context.targetExpr.Release(), context.fromsource);
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.ctx->PopParsingLvalue();
                context.targetExpr.Reset(context.fromtarget);
            }
            public throw void A2ActionFail()
            {
                context.ctx->PopParsingLvalue();
            }
            public throw void Pretarget(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void Posttarget(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromtarget_value = stack.Pop();
                    context.fromtarget = *cast<ValueObject<Node*>*>(fromtarget_value.GetPtr());
                }
            }
            public throw void Presource(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void Postsource(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromsource_value = stack.Pop();
                    context.fromsource = *cast<ValueObject<Node*>*>(fromsource_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public UniquePtr<Node> targetExpr;
                public Node* fromtarget;
                public Node* fromsource;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ConstructionStatementRule: System.Text.Parsing.Rule
        {
            public ConstructionStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                NonterminalParser* typeExprNonterminalParser = GetNonterminal("TypeExpr");
                typeExprNonterminalParser->SetPreCall(PreCall(PreTypeExpr));
                typeExprNonterminalParser->SetPostCall(PostCall(PostTypeExpr));
                NonterminalParser* identifierNonterminalParser = GetNonterminal("Identifier");
                identifierNonterminalParser->SetPostCall(PostCall(PostIdentifier));
                NonterminalParser* argumentListNonterminalParser = GetNonterminal("ArgumentList");
                argumentListNonterminalParser->SetPreCall(PreCall(PreArgumentList));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new ConstructionStatementNode(span, context.fromTypeExpr, context.fromIdentifier);
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->AddArgument(context.fromExpression);
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->GetSpan().SetEnd(span.End());
            }
            public throw void PreTypeExpr(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostTypeExpr(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context.fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.GetPtr());
                }
            }
            public throw void PostIdentifier(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context.fromIdentifier = *cast<ValueObject<IdentifierNode*>*>(fromIdentifier_value.GetPtr());
                }
            }
            public throw void PreArgumentList(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
                stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context.value)));
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromTypeExpr;
                public IdentifierNode* fromIdentifier;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class DeleteStatementRule: System.Text.Parsing.Rule
        {
            public DeleteStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new DeleteStatementNode(span, context.fromExpression);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class DestroyStatementRule: System.Text.Parsing.Rule
        {
            public DestroyStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new DestroyStatementNode(span, context.fromExpression);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ThrowStatementRule: System.Text.Parsing.Rule
        {
            public ThrowStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new ThrowStatementNode(span, context.fromExpression);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class TryStatementRule: System.Text.Parsing.Rule
        {
            public TryStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("TryStatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<TryStatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                NonterminalParser* compoundStatementNonterminalParser = GetNonterminal("CompoundStatement");
                compoundStatementNonterminalParser->SetPreCall(PreCall(PreCompoundStatement));
                compoundStatementNonterminalParser->SetPostCall(PostCall(PostCompoundStatement));
                NonterminalParser* handlersNonterminalParser = GetNonterminal("Handlers");
                handlersNonterminalParser->SetPreCall(PreCall(PreHandlers));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new TryStatementNode(span, context.fromCompoundStatement);
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->GetSpan().SetEnd(span.End());
            }
            public throw void PreCompoundStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostCompoundStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromCompoundStatement_value = stack.Pop();
                    context.fromCompoundStatement = *cast<ValueObject<CompoundStatementNode*>*>(fromCompoundStatement_value.GetPtr());
                }
            }
            public throw void PreHandlers(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
                stack.Push(UniquePtr<Object>(new ValueObject<TryStatementNode*>(context.value)));
            }
            private class Context
            {
                public ParsingContext* ctx;
                public TryStatementNode* value;
                public CompoundStatementNode* fromCompoundStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class HandlersRule: System.Text.Parsing.Rule
        {
            public HandlersRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                AddInheritedAttribute(AttrOrVariable("TryStatementNode*", "tryS"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> tryS_value = stack.Pop();
                context.tryS = *cast<ValueObject<TryStatementNode*>*>(tryS_value.GetPtr());
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* handlerNonterminalParser = GetNonterminal("Handler");
                handlerNonterminalParser->SetPreCall(PreCall(PreHandler));
                handlerNonterminalParser->SetPostCall(PostCall(PostHandler));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.tryS->AddHandler(context.fromHandler);
            }
            public throw void PreHandler(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostHandler(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromHandler_value = stack.Pop();
                    context.fromHandler = *cast<ValueObject<CatchNode*>*>(fromHandler_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public TryStatementNode* tryS;
                public CatchNode* fromHandler;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class HandlerRule: System.Text.Parsing.Rule
        {
            public HandlerRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("CatchNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CatchNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* typeExprNonterminalParser = GetNonterminal("TypeExpr");
                typeExprNonterminalParser->SetPreCall(PreCall(PreTypeExpr));
                typeExprNonterminalParser->SetPostCall(PostCall(PostTypeExpr));
                NonterminalParser* identifierNonterminalParser = GetNonterminal("Identifier");
                identifierNonterminalParser->SetPostCall(PostCall(PostIdentifier));
                NonterminalParser* compoundStatementNonterminalParser = GetNonterminal("CompoundStatement");
                compoundStatementNonterminalParser->SetPreCall(PreCall(PreCompoundStatement));
                compoundStatementNonterminalParser->SetPostCall(PostCall(PostCompoundStatement));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new CatchNode(span, context.fromTypeExpr, context.fromIdentifier, context.fromCompoundStatement);
            }
            public throw void PreTypeExpr(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostTypeExpr(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context.fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.GetPtr());
                }
            }
            public throw void PostIdentifier(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context.fromIdentifier = *cast<ValueObject<IdentifierNode*>*>(fromIdentifier_value.GetPtr());
                }
            }
            public throw void PreCompoundStatement(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostCompoundStatement(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromCompoundStatement_value = stack.Pop();
                    context.fromCompoundStatement = *cast<ValueObject<CompoundStatementNode*>*>(fromCompoundStatement_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public CatchNode* value;
                public Node* fromTypeExpr;
                public IdentifierNode* fromIdentifier;
                public CompoundStatementNode* fromCompoundStatement;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class AssertStatementRule: System.Text.Parsing.Rule
        {
            public AssertStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("StatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* expressionNonterminalParser = GetNonterminal("Expression");
                expressionNonterminalParser->SetPreCall(PreCall(PreExpression));
                expressionNonterminalParser->SetPostCall(PostCall(PostExpression));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new AssertStatementNode(span, context.fromExpression);
            }
            public throw void PreExpression(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostExpression(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context.fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ConditionalCompilationStatementRule: System.Text.Parsing.Rule
        {
            public ConditionalCompilationStatementRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                AddInheritedAttribute(AttrOrVariable("ParsingContext*", "ctx"));
                SetValueTypeName("CondCompStatementNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
                UniquePtr<Object> ctx_value = stack.Pop();
                context.ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.GetPtr());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CondCompStatementNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                ActionParser* a3ActionParser = GetAction("A3");
                a3ActionParser->SetAction(ParsingAction(A3Action));
                ActionParser* a4ActionParser = GetAction("A4");
                a4ActionParser->SetAction(ParsingAction(A4Action));
                NonterminalParser* ifENonterminalParser = GetNonterminal("ifE");
                ifENonterminalParser->SetPostCall(PostCall(PostifE));
                NonterminalParser* ifSNonterminalParser = GetNonterminal("ifS");
                ifSNonterminalParser->SetPreCall(PreCall(PreifS));
                ifSNonterminalParser->SetPostCall(PostCall(PostifS));
                NonterminalParser* elifENonterminalParser = GetNonterminal("elifE");
                elifENonterminalParser->SetPostCall(PostCall(PostelifE));
                NonterminalParser* elifSNonterminalParser = GetNonterminal("elifS");
                elifSNonterminalParser->SetPreCall(PreCall(PreelifS));
                elifSNonterminalParser->SetPostCall(PostCall(PostelifS));
                NonterminalParser* elseSNonterminalParser = GetNonterminal("elseS");
                elseSNonterminalParser->SetPreCall(PreCall(PreelseS));
                elseSNonterminalParser->SetPostCall(PostCall(PostelseS));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new CondCompStatementNode(span, context.fromifE);
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->AddIfStatement(context.fromifS);
            }
            public throw void A2Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->AddElifExpr(span, context.fromelifE);
            }
            public throw void A3Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->AddElifStatement(context.fromelifS);
            }
            public throw void A4Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value->AddElseStatement(span, context.fromelseS);
            }
            public throw void PostifE(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromifE_value = stack.Pop();
                    context.fromifE = *cast<ValueObject<CondCompExprNode*>*>(fromifE_value.GetPtr());
                }
            }
            public throw void PreifS(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostifS(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromifS_value = stack.Pop();
                    context.fromifS = *cast<ValueObject<StatementNode*>*>(fromifS_value.GetPtr());
                }
            }
            public throw void PostelifE(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromelifE_value = stack.Pop();
                    context.fromelifE = *cast<ValueObject<CondCompExprNode*>*>(fromelifE_value.GetPtr());
                }
            }
            public throw void PreelifS(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostelifS(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromelifS_value = stack.Pop();
                    context.fromelifS = *cast<ValueObject<StatementNode*>*>(fromelifS_value.GetPtr());
                }
            }
            public throw void PreelseS(Stack<UniquePtr<Object>>& stack)
            {
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context.ctx)));
            }
            public throw void PostelseS(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromelseS_value = stack.Pop();
                    context.fromelseS = *cast<ValueObject<StatementNode*>*>(fromelseS_value.GetPtr());
                }
            }
            private class Context
            {
                public ParsingContext* ctx;
                public CondCompStatementNode* value;
                public CondCompExprNode* fromifE;
                public StatementNode* fromifS;
                public CondCompExprNode* fromelifE;
                public StatementNode* fromelifS;
                public StatementNode* fromelseS;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ConditionalCompilationExprRule: System.Text.Parsing.Rule
        {
            public ConditionalCompilationExprRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("CondCompExprNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CondCompExprNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* conditionalCompilationDisjunctionNonterminalParser = GetNonterminal("ConditionalCompilationDisjunction");
                conditionalCompilationDisjunctionNonterminalParser->SetPostCall(PostCall(PostConditionalCompilationDisjunction));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromConditionalCompilationDisjunction;
            }
            public throw void PostConditionalCompilationDisjunction(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromConditionalCompilationDisjunction_value = stack.Pop();
                    context.fromConditionalCompilationDisjunction = *cast<ValueObject<CondCompExprNode*>*>(fromConditionalCompilationDisjunction_value.GetPtr());
                }
            }
            private class Context
            {
                public CondCompExprNode* value;
                public CondCompExprNode* fromConditionalCompilationDisjunction;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ConditionalCompilationDisjunctionRule: System.Text.Parsing.Rule
        {
            public ConditionalCompilationDisjunctionRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("CondCompExprNode*");
                AddLocalVariable(AttrOrVariable("Span", "s"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CondCompExprNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                NonterminalParser* leftNonterminalParser = GetNonterminal("left");
                leftNonterminalParser->SetPostCall(PostCall(Postleft));
                NonterminalParser* rightNonterminalParser = GetNonterminal("right");
                rightNonterminalParser->SetPostCall(PostCall(Postright));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.s = span;
                context.value = context.fromleft;
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.s.SetEnd(span.End());
                context.value = new CondCompDisjunctionNode(context.s, context.value, context.fromright);
            }
            public throw void Postleft(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context.fromleft = *cast<ValueObject<CondCompExprNode*>*>(fromleft_value.GetPtr());
                }
            }
            public throw void Postright(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context.fromright = *cast<ValueObject<CondCompExprNode*>*>(fromright_value.GetPtr());
                }
            }
            private class Context
            {
                public CondCompExprNode* value;
                public Span s;
                public CondCompExprNode* fromleft;
                public CondCompExprNode* fromright;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ConditionalCompilationConjunctionRule: System.Text.Parsing.Rule
        {
            public ConditionalCompilationConjunctionRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("CondCompExprNode*");
                AddLocalVariable(AttrOrVariable("Span", "s"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CondCompExprNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                NonterminalParser* leftNonterminalParser = GetNonterminal("left");
                leftNonterminalParser->SetPostCall(PostCall(Postleft));
                NonterminalParser* rightNonterminalParser = GetNonterminal("right");
                rightNonterminalParser->SetPostCall(PostCall(Postright));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.s = span;
                context.value = context.fromleft;
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.s.SetEnd(span.End());
                context.value = new CondCompConjunctionNode(context.s, context.value, context.fromright);
            }
            public throw void Postleft(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context.fromleft = *cast<ValueObject<CondCompExprNode*>*>(fromleft_value.GetPtr());
                }
            }
            public throw void Postright(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context.fromright = *cast<ValueObject<CondCompExprNode*>*>(fromright_value.GetPtr());
                }
            }
            private class Context
            {
                public CondCompExprNode* value;
                public Span s;
                public CondCompExprNode* fromleft;
                public CondCompExprNode* fromright;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ConditionalCompilationPrefixRule: System.Text.Parsing.Rule
        {
            public ConditionalCompilationPrefixRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("CondCompExprNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CondCompExprNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                NonterminalParser* leftNonterminalParser = GetNonterminal("left");
                leftNonterminalParser->SetPostCall(PostCall(Postleft));
                NonterminalParser* rightNonterminalParser = GetNonterminal("right");
                rightNonterminalParser->SetPostCall(PostCall(Postright));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new CondCompNotNode(span, context.fromleft);
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromright;
            }
            public throw void Postleft(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context.fromleft = *cast<ValueObject<CondCompExprNode*>*>(fromleft_value.GetPtr());
                }
            }
            public throw void Postright(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context.fromright = *cast<ValueObject<CondCompExprNode*>*>(fromright_value.GetPtr());
                }
            }
            private class Context
            {
                public CondCompExprNode* value;
                public CondCompExprNode* fromleft;
                public CondCompExprNode* fromright;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ConditionalCompilationPrimaryRule: System.Text.Parsing.Rule
        {
            public ConditionalCompilationPrimaryRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("CondCompExprNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CondCompExprNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                NonterminalParser* symbolNonterminalParser = GetNonterminal("symbol");
                symbolNonterminalParser->SetPostCall(PostCall(Postsymbol));
                NonterminalParser* exprNonterminalParser = GetNonterminal("expr");
                exprNonterminalParser->SetPostCall(PostCall(Postexpr));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new CondCompPrimaryNode(span, context.fromsymbol);
            }
            public throw void A1Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = context.fromexpr;
            }
            public throw void Postsymbol(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromsymbol_value = stack.Pop();
                    context.fromsymbol = *cast<ValueObject<CondCompSymbolNode*>*>(fromsymbol_value.GetPtr());
                }
            }
            public throw void Postexpr(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromexpr_value = stack.Pop();
                    context.fromexpr = *cast<ValueObject<CondCompExprNode*>*>(fromexpr_value.GetPtr());
                }
            }
            private class Context
            {
                public CondCompExprNode* value;
                public CondCompSymbolNode* fromsymbol;
                public CondCompExprNode* fromexpr;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class ConditionalCompilationSymbolRule: System.Text.Parsing.Rule
        {
            public ConditionalCompilationSymbolRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("CondCompSymbolNode*");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CondCompSymbolNode*>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* symbolNonterminalParser = GetNonterminal("Symbol");
                symbolNonterminalParser->SetPostCall(PostCall(PostSymbol));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = new CondCompSymbolNode(span, context.fromSymbol);
            }
            public throw void PostSymbol(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromSymbol_value = stack.Pop();
                    context.fromSymbol = *cast<ValueObject<string>*>(fromSymbol_value.GetPtr());
                }
            }
            private class Context
            {
                public CondCompSymbolNode* value;
                public string fromSymbol;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class SymbolRule: System.Text.Parsing.Rule
        {
            public SymbolRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("string");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<string>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* identifierNonterminalParser = GetNonterminal("identifier");
                identifierNonterminalParser->SetPostCall(PostCall(Postidentifier));
            }
            public throw void A0Action(const char* matchBegin, const char* matchEnd, const Span& span, const string& fileName, bool& pass)
            {
                context.value = string(matchBegin, matchEnd);
            }
            public throw void Postidentifier(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromidentifier_value = stack.Pop();
                    context.fromidentifier = *cast<ValueObject<string>*>(fromidentifier_value.GetPtr());
                }
            }
            private class Context
            {
                public string value;
                public string fromidentifier;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        public override void GetReferencedGrammars()
        {
            ParsingDomain* parsingDomain = GetParsingDomain();
            Grammar* grammar0 = parsingDomain->GetGrammar("System.Text.Parsing.stdlib");
            if (grammar0 == null)
            {
                grammar0 = System.Text.Parsing.stdlib.Create(parsingDomain);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = parsingDomain->GetGrammar("Cm.Parser.ExpressionGrammar");
            if (grammar1 == null)
            {
                grammar1 = Cm.Parser.ExpressionGrammar.Create(parsingDomain);
            }
            AddGrammarReference(grammar1);
            Grammar* grammar2 = parsingDomain->GetGrammar("Cm.Parser.IdentifierGrammar");
            if (grammar2 == null)
            {
                grammar2 = Cm.Parser.IdentifierGrammar.Create(parsingDomain);
            }
            AddGrammarReference(grammar2);
            Grammar* grammar3 = parsingDomain->GetGrammar("Cm.Parser.KeywordGrammar");
            if (grammar3 == null)
            {
                grammar3 = Cm.Parser.KeywordGrammar.Create(parsingDomain);
            }
            AddGrammarReference(grammar3);
            Grammar* grammar4 = parsingDomain->GetGrammar("Cm.Parser.TypeExprGrammar");
            if (grammar4 == null)
            {
                grammar4 = Cm.Parser.TypeExprGrammar.Create(parsingDomain);
            }
            AddGrammarReference(grammar4);
        }
        public override void CreateRules()
        {
            AddRuleLink(new RuleLink("identifier", this, "System.Text.Parsing.stdlib.identifier"));
            AddRuleLink(new RuleLink("spaces_and_comments", this, "System.Text.Parsing.stdlib.spaces_and_comments"));
            AddRuleLink(new RuleLink("ArgumentList", this, "ExpressionGrammar.ArgumentList"));
            AddRuleLink(new RuleLink("Keyword", this, "KeywordGrammar.Keyword"));
            AddRuleLink(new RuleLink("Expression", this, "ExpressionGrammar.Expression"));
            AddRuleLink(new RuleLink("Identifier", this, "IdentifierGrammar.Identifier"));
            AddRuleLink(new RuleLink("TypeExpr", this, "TypeExprGrammar.TypeExpr"));
            AddRule(new StatementRule("Statement", GetScope(),
                new AlternativeParser(
                    new AlternativeParser(
                        new AlternativeParser(
                            new AlternativeParser(
                                new AlternativeParser(
                                    new AlternativeParser(
                                        new AlternativeParser(
                                            new AlternativeParser(
                                                new AlternativeParser(
                                                    new AlternativeParser(
                                                        new AlternativeParser(
                                                            new ActionParser("A0",
                                                                new NonterminalParser("LabeledStatement", "LabeledStatement", 1)),
                                                            new ActionParser("A1",
                                                                new NonterminalParser("ControlStatement", "ControlStatement", 1))),
                                                        new ActionParser("A2",
                                                            new NonterminalParser("TypedefStatement", "TypedefStatement", 1))),
                                                    new ActionParser("A3",
                                                        new NonterminalParser("SimpleStatement", "SimpleStatement", 1))),
                                                new ActionParser("A4",
                                                    new NonterminalParser("AssignmentStatement", "AssignmentStatement", 1))),
                                            new ActionParser("A5",
                                                new NonterminalParser("ConstructionStatement", "ConstructionStatement", 1))),
                                        new ActionParser("A6",
                                            new NonterminalParser("DeleteStatement", "DeleteStatement", 1))),
                                    new ActionParser("A7",
                                        new NonterminalParser("DestroyStatement", "DestroyStatement", 1))),
                                new ActionParser("A8",
                                    new NonterminalParser("ThrowStatement", "ThrowStatement", 1))),
                            new ActionParser("A9",
                                new NonterminalParser("TryStatement", "TryStatement", 1))),
                        new ActionParser("A10",
                            new NonterminalParser("AssertStatement", "AssertStatement", 1))),
                    new ActionParser("A11",
                        new NonterminalParser("ConditionalCompilationStatement", "ConditionalCompilationStatement", 1)))));
            AddRule(new LabelIdRule("LabelId", GetScope(),
                new ActionParser("A0",
                    new DifferenceParser(
                        new NonterminalParser("identifier", "identifier", 0),
                        new NonterminalParser("Keyword", "Keyword", 0))
                    )));
            AddRule(new LabelRule("Label", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new NonterminalParser("LabelId", "LabelId", 0),
                        new CharParser(':')))));
            AddRule(new TargetLabelRule("TargetLabel", GetScope(),
                new ActionParser("A0",
                    new NonterminalParser("LabelId", "LabelId", 0))));
            AddRule(new LabeledStatementRule("LabeledStatement", GetScope(),
                new SequenceParser(
                    new NonterminalParser("Label", "Label", 0),
                    new ActionParser("A0",
                        new NonterminalParser("Statement", "Statement", 1)))));
            AddRule(new SimpleStatementRule("SimpleStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new ActionParser("A1",
                                new EmptyParser()),
                            new OptionalParser(
                                new ActionParser("A2",
                                    new NonterminalParser("Expression", "Expression", 1)))),
                        new CharParser(';')))));
            AddRule(new ControlStatementRule("ControlStatement", GetScope(),
                new AlternativeParser(
                    new AlternativeParser(
                        new AlternativeParser(
                            new AlternativeParser(
                                new AlternativeParser(
                                    new AlternativeParser(
                                        new AlternativeParser(
                                            new AlternativeParser(
                                                new AlternativeParser(
                                                    new AlternativeParser(
                                                        new AlternativeParser(
                                                            new AlternativeParser(
                                                                new ActionParser("A0",
                                                                    new NonterminalParser("ReturnStatement", "ReturnStatement", 1)),
                                                                new ActionParser("A1",
                                                                    new NonterminalParser("ConditionalStatement", "ConditionalStatement", 1))),
                                                            new ActionParser("A2",
                                                                new NonterminalParser("SwitchStatement", "SwitchStatement", 1))),
                                                        new ActionParser("A3",
                                                            new NonterminalParser("WhileStatement", "WhileStatement", 1))),
                                                    new ActionParser("A4",
                                                        new NonterminalParser("DoStatement", "DoStatement", 1))),
                                                new ActionParser("A5",
                                                    new NonterminalParser("RangeForStatement", "RangeForStatement", 1))),
                                            new ActionParser("A6",
                                                new NonterminalParser("ForStatement", "ForStatement", 1))),
                                        new ActionParser("A7",
                                            new NonterminalParser("CompoundStatement", "CompoundStatement", 1))),
                                    new ActionParser("A8",
                                        new NonterminalParser("BreakStatement", "BreakStatement", 0))),
                                new ActionParser("A9",
                                    new NonterminalParser("ContinueStatement", "ContinueStatement", 0))),
                            new ActionParser("A10",
                                new NonterminalParser("GotoCaseStatement", "GotoCaseStatement", 1))),
                        new ActionParser("A11",
                            new NonterminalParser("GotoDefaultStatement", "GotoDefaultStatement", 0))),
                    new ActionParser("A12",
                        new NonterminalParser("GotoStatement", "GotoStatement", 0)))));
            AddRule(new ReturnStatementRule("ReturnStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new KeywordParser("return"),
                            new OptionalParser(
                                new NonterminalParser("Expression", "Expression", 1))),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new ConditionalStatementRule("ConditionalStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new SequenceParser(
                                    new SequenceParser(
                                        new KeywordParser("if"),
                                        new ExpectationParser(
                                            new CharParser('('))),
                                    new ExpectationParser(
                                        new NonterminalParser("Expression", "Expression", 1))),
                                new ExpectationParser(
                                    new CharParser(')'))),
                            new ExpectationParser(
                                new NonterminalParser("thenS", "Statement", 1))),
                        new OptionalParser(
                            new SequenceParser(
                                new KeywordParser("else"),
                                new NonterminalParser("elseS", "Statement", 1)))))));
            AddRule(new SwitchStatementRule("SwitchStatement", GetScope(),
                new SequenceParser(
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new ActionParser("A0",
                                    new SequenceParser(
                                        new SequenceParser(
                                            new KeywordParser("switch"),
                                            new ExpectationParser(
                                                new CharParser('('))),
                                        new ExpectationParser(
                                            new NonterminalParser("Expression", "Expression", 1)))),
                                new ExpectationParser(
                                    new CharParser(')'))),
                            new ExpectationParser(
                                new CharParser('{'))),
                        new KleeneStarParser(
                            new AlternativeParser(
                                new ActionParser("A1",
                                    new NonterminalParser("CaseStatement", "CaseStatement", 1)),
                                new ActionParser("A2",
                                    new NonterminalParser("DefaultStatement", "DefaultStatement", 1))))),
                    new ActionParser("A3",
                        new ExpectationParser(
                            new CharParser('}'))))));
            AddRule(new CaseStatementRule("CaseStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new ActionParser("A1",
                                new EmptyParser()),
                            new ActionParser("A2",
                                new NonterminalParser("CaseList", "CaseList", 2))),
                        new KleeneStarParser(
                            new ActionParser("A3",
                                new NonterminalParser("Statement", "Statement", 1)))))));
            AddRule(new DefaultStatementRule("DefaultStatement", GetScope(),
                new SequenceParser(
                    new ActionParser("A0",
                        new SequenceParser(
                            new KeywordParser("default"),
                            new ExpectationParser(
                                new CharParser(':')))),
                    new KleeneStarParser(
                        new ActionParser("A1",
                            new NonterminalParser("Statement", "Statement", 1))))));
            AddRule(new CaseListRule("CaseList", GetScope(),
                new PositiveParser(
                    new SequenceParser(
                        new SequenceParser(
                            new KeywordParser("case"),
                            new ExpectationParser(
                                new NonterminalParser("Expression", "Expression", 1))),
                        new ActionParser("A0",
                            new ExpectationParser(
                                new CharParser(':')))))));
            AddRule(new GotoCaseStatementRule("GotoCaseStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new KeywordParser("goto"),
                                new KeywordParser("case")),
                            new ExpectationParser(
                                new NonterminalParser("Expression", "Expression", 1))),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new GotoDefaultStatementRule("GotoDefaultStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new KeywordParser("goto"),
                            new KeywordParser("default")),
                        new CharParser(';')))));
            AddRule(new WhileStatementRule("WhileStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new SequenceParser(
                                    new KeywordParser("while"),
                                    new ExpectationParser(
                                        new CharParser('('))),
                                new ExpectationParser(
                                    new NonterminalParser("Expression", "Expression", 1))),
                            new ExpectationParser(
                                new CharParser(')'))),
                        new ExpectationParser(
                            new NonterminalParser("Statement", "Statement", 1))))));
            AddRule(new DoStatementRule("DoStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new SequenceParser(
                                    new SequenceParser(
                                        new SequenceParser(
                                            new KeywordParser("do"),
                                            new ExpectationParser(
                                                new NonterminalParser("Statement", "Statement", 1))),
                                        new ExpectationParser(
                                            new KeywordParser("while"))),
                                    new ExpectationParser(
                                        new CharParser('('))),
                                new ExpectationParser(
                                    new NonterminalParser("Expression", "Expression", 1))),
                            new ExpectationParser(
                                new CharParser(')'))),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new RangeForStatementRule("RangeForStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new SequenceParser(
                                    new SequenceParser(
                                        new SequenceParser(
                                            new SequenceParser(
                                                new KeywordParser("for"),
                                                new CharParser('(')),
                                            new ActionParser("A1",
                                                new NonterminalParser("TypeExpr", "TypeExpr", 1))),
                                        new ActionParser("A2",
                                            new NonterminalParser("Identifier", "Identifier", 0))),
                                    new CharParser(':')),
                                new ExpectationParser(
                                    new NonterminalParser("Expression", "Expression", 1))),
                            new ExpectationParser(
                                new CharParser(')'))),
                        new ExpectationParser(
                            new NonterminalParser("Statement", "Statement", 1))))));
            AddRule(new ForStatementRule("ForStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new SequenceParser(
                                    new SequenceParser(
                                        new SequenceParser(
                                            new SequenceParser(
                                                new KeywordParser("for"),
                                                new ExpectationParser(
                                                    new CharParser('('))),
                                            new ExpectationParser(
                                                new NonterminalParser("ForInitStatement", "ForInitStatement", 1))),
                                        new OptionalParser(
                                            new NonterminalParser("condition", "Expression", 1))),
                                    new ExpectationParser(
                                        new CharParser(';'))),
                                new OptionalParser(
                                    new NonterminalParser("increment", "Expression", 1))),
                            new ExpectationParser(
                                new CharParser(')'))),
                        new ExpectationParser(
                            new NonterminalParser("Statement", "Statement", 1))))));
            AddRule(new ForInitStatementRule("ForInitStatement", GetScope(),
                new AlternativeParser(
                    new AlternativeParser(
                        new ActionParser("A0",
                            new NonterminalParser("AssignmentStatement", "AssignmentStatement", 1)),
                        new ActionParser("A1",
                            new NonterminalParser("ConstructionStatement", "ConstructionStatement", 1))),
                    new ActionParser("A2",
                        new CharParser(';')))));
            AddRule(new CompoundStatementRule("CompoundStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new ActionParser("A1",
                                new CharParser('{')),
                            new KleeneStarParser(
                                new ActionParser("A2",
                                    new NonterminalParser("Statement", "Statement", 1)))),
                        new ExpectationParser(
                            new ActionParser("A3",
                                new CharParser('}')))))));
            AddRule(new BreakStatementRule("BreakStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new KeywordParser("break"),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new ContinueStatementRule("ContinueStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new KeywordParser("continue"),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new GotoStatementRule("GotoStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new KeywordParser("goto"),
                            new ExpectationParser(
                                new NonterminalParser("TargetLabel", "TargetLabel", 0))),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new TypedefStatementRule("TypedefStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new KeywordParser("typedef"),
                                new ExpectationParser(
                                    new NonterminalParser("TypeExpr", "TypeExpr", 1))),
                            new ExpectationParser(
                                new NonterminalParser("Identifier", "Identifier", 0))),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new AssignmentStatementRule("AssignmentStatement", GetScope(),
                new SequenceParser(
                    new ActionParser("A0",
                        new EmptyParser()),
                    new ActionParser("A1",
                        new SequenceParser(
                            new SequenceParser(
                                new SequenceParser(
                                    new ActionParser("A2",
                                        new NonterminalParser("target", "Expression", 1)),
                                    new CharParser('=')),
                                new ExpectationParser(
                                    new NonterminalParser("source", "Expression", 1))),
                            new ExpectationParser(
                                new CharParser(';')))))));
            AddRule(new ConstructionStatementRule("ConstructionStatement", GetScope(),
                new SequenceParser(
                    new SequenceParser(
                        new ActionParser("A0",
                            new SequenceParser(
                                new NonterminalParser("TypeExpr", "TypeExpr", 1),
                                new ExpectationParser(
                                    new NonterminalParser("Identifier", "Identifier", 0)))),
                        new OptionalParser(
                            new AlternativeParser(
                                new SequenceParser(
                                    new SequenceParser(
                                        new CharParser('('),
                                        new NonterminalParser("ArgumentList", "ArgumentList", 2)),
                                    new ExpectationParser(
                                        new CharParser(')'))),
                                new SequenceParser(
                                    new CharParser('='),
                                    new ActionParser("A1",
                                        new ExpectationParser(
                                            new NonterminalParser("Expression", "Expression", 1))))))),
                    new ActionParser("A2",
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new DeleteStatementRule("DeleteStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new KeywordParser("delete"),
                            new ExpectationParser(
                                new NonterminalParser("Expression", "Expression", 1))),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new DestroyStatementRule("DestroyStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new KeywordParser("destroy"),
                            new ExpectationParser(
                                new NonterminalParser("Expression", "Expression", 1))),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new ThrowStatementRule("ThrowStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new KeywordParser("throw"),
                            new ExpectationParser(
                                new NonterminalParser("Expression", "Expression", 1))),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new TryStatementRule("TryStatement", GetScope(),
                new SequenceParser(
                    new ActionParser("A0",
                        new SequenceParser(
                            new KeywordParser("try"),
                            new ExpectationParser(
                                new NonterminalParser("CompoundStatement", "CompoundStatement", 1)))),
                    new ActionParser("A1",
                        new ExpectationParser(
                            new NonterminalParser("Handlers", "Handlers", 2))))));
            AddRule(new HandlersRule("Handlers", GetScope(),
                new PositiveParser(
                    new ActionParser("A0",
                        new NonterminalParser("Handler", "Handler", 1)))));
            AddRule(new HandlerRule("Handler", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new SequenceParser(
                                    new SequenceParser(
                                        new KeywordParser("catch"),
                                        new ExpectationParser(
                                            new CharParser('('))),
                                    new ExpectationParser(
                                        new NonterminalParser("TypeExpr", "TypeExpr", 1))),
                                new OptionalParser(
                                    new NonterminalParser("Identifier", "Identifier", 0))),
                            new ExpectationParser(
                                new CharParser(')'))),
                        new ExpectationParser(
                            new NonterminalParser("CompoundStatement", "CompoundStatement", 1))))));
            AddRule(new AssertStatementRule("AssertStatement", GetScope(),
                new ActionParser("A0",
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new CharParser('#'),
                                new KeywordParser("assert")),
                            new ExpectationParser(
                                new NonterminalParser("Expression", "Expression", 1))),
                        new ExpectationParser(
                            new CharParser(';'))))));
            AddRule(new ConditionalCompilationStatementRule("ConditionalCompilationStatement", GetScope(),
                new SequenceParser(
                    new SequenceParser(
                        new SequenceParser(
                            new SequenceParser(
                                new SequenceParser(
                                    new SequenceParser(
                                        new ActionParser("A0",
                                            new SequenceParser(
                                                new SequenceParser(
                                                    new SequenceParser(
                                                        new CharParser('#'),
                                                        new KeywordParser("if")),
                                                    new ExpectationParser(
                                                        new CharParser('('))),
                                                new NonterminalParser("ifE", "ConditionalCompilationExpr", 0))),
                                        new ExpectationParser(
                                            new CharParser(')'))),
                                    new KleeneStarParser(
                                        new ActionParser("A1",
                                            new NonterminalParser("ifS", "Statement", 1)))),
                                new KleeneStarParser(
                                    new SequenceParser(
                                        new SequenceParser(
                                            new ActionParser("A2",
                                                new SequenceParser(
                                                    new SequenceParser(
                                                        new SequenceParser(
                                                            new CharParser('#'),
                                                            new KeywordParser("elif")),
                                                        new ExpectationParser(
                                                            new CharParser('('))),
                                                    new NonterminalParser("elifE", "ConditionalCompilationExpr", 0))),
                                            new ExpectationParser(
                                                new CharParser(')'))),
                                        new KleeneStarParser(
                                            new ActionParser("A3",
                                                new NonterminalParser("elifS", "Statement", 1)))))),
                            new OptionalParser(
                                new SequenceParser(
                                    new SequenceParser(
                                        new CharParser('#'),
                                        new KeywordParser("else")),
                                    new KleeneStarParser(
                                        new ActionParser("A4",
                                            new NonterminalParser("elseS", "Statement", 1)))))),
                        new ExpectationParser(
                            new CharParser('#'))),
                    new ExpectationParser(
                        new KeywordParser("endif")))));
            AddRule(new ConditionalCompilationExprRule("ConditionalCompilationExpr", GetScope(),
                new ActionParser("A0",
                    new NonterminalParser("ConditionalCompilationDisjunction", "ConditionalCompilationDisjunction", 0))));
            AddRule(new ConditionalCompilationDisjunctionRule("ConditionalCompilationDisjunction", GetScope(),
                new SequenceParser(
                    new ActionParser("A0",
                        new NonterminalParser("left", "ConditionalCompilationConjunction", 0)),
                    new KleeneStarParser(
                        new SequenceParser(
                            new StringParser("||"),
                            new ActionParser("A1",
                                new NonterminalParser("right", "ConditionalCompilationConjunction", 0)))))));
            AddRule(new ConditionalCompilationConjunctionRule("ConditionalCompilationConjunction", GetScope(),
                new SequenceParser(
                    new ActionParser("A0",
                        new NonterminalParser("left", "ConditionalCompilationPrefix", 0)),
                    new KleeneStarParser(
                        new SequenceParser(
                            new StringParser("&&"),
                            new ActionParser("A1",
                                new NonterminalParser("right", "ConditionalCompilationPrefix", 0)))))));
            AddRule(new ConditionalCompilationPrefixRule("ConditionalCompilationPrefix", GetScope(),
                new AlternativeParser(
                    new ActionParser("A0",
                        new SequenceParser(
                            new CharParser('!'),
                            new ExpectationParser(
                                new NonterminalParser("left", "ConditionalCompilationPrefix", 0)))),
                    new ActionParser("A1",
                        new ExpectationParser(
                            new NonterminalParser("right", "ConditionalCompilationPrimary", 0))))));
            AddRule(new ConditionalCompilationPrimaryRule("ConditionalCompilationPrimary", GetScope(),
                new AlternativeParser(
                    new ActionParser("A0",
                        new NonterminalParser("symbol", "ConditionalCompilationSymbol", 0)),
                    new SequenceParser(
                        new SequenceParser(
                            new CharParser('('),
                            new ActionParser("A1",
                                new NonterminalParser("expr", "ConditionalCompilationExpr", 0))),
                        new CharParser(')')))));
            AddRule(new ConditionalCompilationSymbolRule("ConditionalCompilationSymbol", GetScope(),
                new ActionParser("A0",
                    new NonterminalParser("Symbol", "Symbol", 0))));
            AddRule(new SymbolRule("Symbol", GetScope(),
                new ActionParser("A0",
                    new DifferenceParser(
                        new NonterminalParser("identifier", "identifier", 0),
                        new NonterminalParser("Keyword", "Keyword", 0))
                    )));
            SetSkipRuleName("spaces_and_comments");
        }
    }
}
