/*========================================================================
    Copyright (c) 2012-2015 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;

namespace Cm.IrIntf
{
    public enum Backend : byte
    {
        llvm, c
    }
    
    public static class BackendHolder
    {
        static nothrow BackendHolder() : backend(Backend.llvm), currentBackend(&llvmBackend)
        {
        }
        public static nothrow void SetCurrentBackend(Backend backend_)
        {
            backend = backend_;
            switch (backend)
            {
                case Backend.llvm: 
                {
                    currentBackend = &llvmBackend; 
                    Ir.Intf.Factory.SetInstance(&llvmFactory);
                    break;
                }                
                case Backend.c:
                {
                    currentBackend = &cBackend; 
                    Ir.Intf.Factory.SetInstance(&cFactory);
                    break;
                }
            }
        }
        public static nothrow Backend GetCurrentBackend()
        {
            return backend;
        }
        public static nothrow BackendIntf* GetCurrentBackendImpl() 
        {
            return currentBackend;
        }
        private static Backend backend;
        private static LlvmBackend llvmBackend;
        private static CBackend cBackend;
        private static BackendIntf* currentBackend;
        private static Llvm.Factory llvmFactory;
        private static C.Factory cFactory;
    }
    
    public nothrow void SetBackend(Backend backend)
    {
        BackendHolder.SetCurrentBackend(backend);
    }
    
    public nothrow Backend GetBackend()
    {
        return BackendHolder.GetCurrentBackend();
    }
    
    public nothrow BackendIntf* GetBackendImpl()
    {
        return BackendHolder.GetCurrentBackendImpl();
    }
    
    public const char* GetBackendStr()
    {
        switch (GetBackend())
        {
            case Backend.llvm: return "llvm";
            case Backend.c: return "c";
        }
        return "";
    }
    
    public abstract class BackendIntf
    {
        public virtual ~BackendIntf()
        {
        }
        public abstract string GetExCodeVarName();
        public abstract Ir.Intf.LabelObject* CreateTempLabel(int tempLabelCounter);
        public abstract string CreateTempVarName(int tempVarCounter);
        public abstract Ir.Intf.LabelObject* CreateNextLocalLabel();
        public abstract Ir.Intf.LabelObject* CreateLabel();
        public abstract Ir.Intf.LabelObject* CreateLabel(const string& label);
        public abstract Ir.Intf.LabelObject* CreateLandingPadLabel(int index);
        public abstract Ir.Intf.RegVar* CreateTemporaryRegVar(Ir.Intf.Type* type);
        public abstract Ir.Intf.Type* I1();
        public abstract Ir.Intf.Type* I8();
        public abstract Ir.Intf.Type* I16();
        public abstract Ir.Intf.Type* I32();
        public abstract Ir.Intf.Type* I64();
        public abstract Ir.Intf.Type* UI8();
        public abstract Ir.Intf.Type* UI16();
        public abstract Ir.Intf.Type* UI32();
        public abstract Ir.Intf.Type* UI64();
        public abstract Ir.Intf.Type* Float();
        public abstract Ir.Intf.Type* Double();
        public abstract Ir.Intf.Type* Void();
        public abstract Ir.Intf.Type* Char();
        public abstract Ir.Intf.Type* RvalueRef(Ir.Intf.Type* baseType);
        public abstract Ir.Intf.Type* Pointer(Ir.Intf.Type* baseType, int numPointers);
        public abstract Ir.Intf.Type* Structure(const string& tagName, const List<Ir.Intf.Type*>& elementTypes, const List<string>& elementNames);
        public abstract Ir.Intf.Type* Array(Ir.Intf.Type* itemType, int size);
        public abstract Ir.Intf.Type* CreateFunctionType(Ir.Intf.Type* returnType, const List<Ir.Intf.Type*>& parameterTypes);
        public abstract Ir.Intf.Type* CreateTypedef(const string& name, Ir.Intf.Type* type);
        public abstract Ir.Intf.Function* CreateFunction(const string& name, Ir.Intf.Type* returnType, const List<Ir.Intf.Parameter*>& parameters);
        public abstract Ir.Intf.Function* CreateDoNothingFunction();
        public abstract Ir.Intf.Function* CreateDbgDeclareFunction();
        public abstract Ir.Intf.Function* CreateMemSetFunction(Ir.Intf.Type* i8Ptr);
        public abstract Ir.Intf.Function* CreateMemCopyFunction(Ir.Intf.Type* i8Ptr);
        public abstract Ir.Intf.Instruction* MemSet(Ir.Intf.Object* dest, Ir.Intf.Object* value, Ir.Intf.Object* len, int align, bool isVolatile);
        public abstract Ir.Intf.Instruction* MemCopy(Ir.Intf.Object* dest, Ir.Intf.Object* source, Ir.Intf.Object* len, int align, bool isVolatile);
        public abstract void ResetLocalLabelCounter();
        public abstract string MakeAssemblyName(const string& name);
        public abstract string MakeClassNameAssemblyName(const string& fullClassName);
        public abstract Ir.Intf.Type* CreateClassTypeName(const string& fullClassName);
        public abstract bool TypesEqual(Ir.Intf.Type* left, Ir.Intf.Type* right);
        public abstract Ir.Intf.Object* True();
        public abstract Ir.Intf.Object* False();
        public abstract Ir.Intf.Object* CreateConstant(const string& name, Ir.Intf.Type* type);
        public abstract Ir.Intf.Object* CreateBooleanConstant(bool value);
        public abstract Ir.Intf.Object* CreateCharConstant(char value);
        public abstract string GetSeparator();
        public abstract string GetPrivateSeparator();
        public abstract string GetStringValuePrefix();
        public abstract Ir.Intf.Object* CreateStringConstant(const string& value);
        public abstract Ir.Intf.Object* Null(Ir.Intf.Type* ptrType);
        public abstract Ir.Intf.Object* CreateI8Constant(sbyte value);
        public abstract Ir.Intf.Object* CreateUI8Constant(byte value);
        public abstract Ir.Intf.Object* CreateI16Constant(short value);
        public abstract Ir.Intf.Object* CreateUI16Constant(ushort value);
        public abstract Ir.Intf.Object* CreateI32Constant(int value);
        public abstract Ir.Intf.Object* CreateUI32Constant(uint value);
        public abstract Ir.Intf.Object* CreateI64Constant(long value);
        public abstract Ir.Intf.Object* CreateUI64Constant(ulong  value);
        public abstract Ir.Intf.Object* CreateFloatConstant(float value);
        public abstract Ir.Intf.Object* CreateDoubleConstant(double value);
        public abstract string MakeStringConstantName(const string& s);
        public abstract string MakeStringConstantName(const string& s, bool metadataSyntax);
        public abstract string MakeDestructionNodeName(const string& assemblyName);
        public abstract string GetDestructionNodeTypeName();
        public abstract string GetRegisterDestructorFunctionName();
        public abstract Ir.Intf.Type* CreateTypeName(const string& name, bool global);
        public abstract Ir.Intf.MemberVar* CreateMemberVar(const string& memberVarName, Ir.Intf.Object* ptr, int index, Ir.Intf.Type* type);
        public abstract Ir.Intf.Object* CreateStackVar(const string& assemblyName, Ir.Intf.Type* type);
        public abstract Ir.Intf.Object* CreateRefVar(const string& assemblyName, Ir.Intf.Type* type);
        public abstract string GetVPtrVarName();
        public abstract string GetStackFrameIdentifier();
        public abstract int GetDebugTagLexicalBlock();
        public abstract int GetDebugTagCompileUnit();
        public abstract int GetDebugTagSubprogram();
        public abstract int GetDebugTagFileType();
        public abstract int GetDebugTagSubroutineType();
        public abstract int GetDebugTagBaseType();
        public abstract int GetDebugTagClassType();
        public abstract int GetDebugTagEnumerationType();
        public abstract int GetDebugTagEnumerator();
        public abstract int GetDebugTagInheritance();
        public abstract int GetDebugTagPointerType();
        public abstract int GetDebugTagConstType();
        public abstract int GetDebugTagReferenceType();
        public abstract int GetDebugTagRvalueRefType();
        public abstract int GetDebugTagNamespace();
        public abstract int GetDebugTagAutoVariable();
        public abstract int GetDebugTagArgVariable();
        public abstract int GetDebugTagMember();
        public abstract int GetDebugLangCmajor();
        public abstract Ir.Intf.Global* CreateGlobal(const string& name, Ir.Intf.Type* type);
        public abstract Ir.Intf.Parameter* CreatePointerParameter(const string& name, Ir.Intf.Type* type);
        public abstract Ir.Intf.Parameter* CreateParameter(const string& parameterName, Ir.Intf.Type* parameterType);
        public abstract string GetClassObjectResultParamName();
        public abstract string GetExceptionCodeParamName();
        public abstract string GetExceptionBaseIdTableName();
        public abstract string GetClassHierarchyTableName();
        public abstract int GetDebugAttrEncodingBoolean();
        public abstract int GetDebugAttrEncodingUnsigned();
        public abstract int GetDebugAttrEncodingSigned();
        public abstract int GetDebugAttrEncodingSignedChar();
        public abstract int GetDebugAttrEncodingUnsignedChar();
        public abstract int GetDebugAttrEncodingFloat();
        public abstract Ir.Intf.Instruction* Add(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* Sub(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* Mul(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* UDiv(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* SDiv(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* URem(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* SRem(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* Shl(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* LShr(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* AShr(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* And(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* Or(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* Xor(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* FAdd(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* FSub(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* FMul(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* FDiv(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* FRem(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* Index(Ir.Intf.Object* result, Ir.Intf.Object* array_, Ir.Intf.Object* index);
        public abstract Ir.Intf.Instruction* Ret();
        public abstract Ir.Intf.Instruction* Ret(Ir.Intf.Object* value);
        public abstract Ir.Intf.Instruction* Br(Ir.Intf.LabelObject* dest);
        public abstract Ir.Intf.Instruction* Br(Ir.Intf.Object* cond, Ir.Intf.LabelObject* trueLabel, Ir.Intf.LabelObject* falseLabel);
        public abstract Ir.Intf.Instruction* Switch(Ir.Intf.Type* integerType, Ir.Intf.Object* value, Ir.Intf.LabelObject* defaultDest, const List<Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>>& destinations);
        public abstract Ir.Intf.Instruction* Alloca(Ir.Intf.Type* type, Ir.Intf.Object* result);
        public abstract Ir.Intf.Instruction* Alloca(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Type* numElementsType, int numElements);
        public abstract Ir.Intf.Instruction* Load(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* ptr);
        public abstract Ir.Intf.Instruction* Load(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* ptr, Ir.Intf.Indirection leftIndirection, Ir.Intf.Indirection rightIndirection);
        public abstract Ir.Intf.Instruction* Store(Ir.Intf.Type* type, Ir.Intf.Object* value, Ir.Intf.Object* ptr);
        public abstract Ir.Intf.Instruction* Store(Ir.Intf.Type* type, Ir.Intf.Object* value, Ir.Intf.Object* ptr, Ir.Intf.Indirection leftIndirection, Ir.Intf.Indirection rightIndirection);
        public abstract Ir.Intf.Instruction* GetElementPtr(Ir.Intf.Type* ptrType, Ir.Intf.Object* result, Ir.Intf.Object* ptr, Ir.Intf.Object* index);
        public abstract Ir.Intf.Instruction* GetElementPtr(Ir.Intf.Type* ptrType, Ir.Intf.Object* result, Ir.Intf.Object* ptr, Ir.Intf.Object* index, Ir.Intf.Object* index1);
        public abstract Ir.Intf.Instruction* GetElementPtr(Ir.Intf.Type* ptrType, Ir.Intf.Object* result, Ir.Intf.Object* ptr, Ir.Intf.Object* index, const List<Ir.Intf.Object*>& indeces);
        public abstract Ir.Intf.Instruction* Call(Ir.Intf.Object* result, Ir.Intf.Function* fun, const List<Ir.Intf.Object*>& args);
        public abstract Ir.Intf.Instruction* IndirectCall(Ir.Intf.Object* result, Ir.Intf.Object* funPtr, const List<Ir.Intf.Object*>& args);
        public abstract Ir.Intf.Instruction* ICmp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.IConditionCode cond, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* FCmp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.FConditionCode cond, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2);
        public abstract Ir.Intf.Instruction* DoNothing();
        public abstract Ir.Intf.Instruction* Trunc(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Zext(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Sext(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Fptrunc(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Fpext(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Fptoui(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Fptosi(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Uitofp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Sitofp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Ptrtoint(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Inttoptr(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract Ir.Intf.Instruction* Bitcast(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType);
        public abstract void Init(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Object* from, Ir.Intf.Object* to);
        public abstract void Assign(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Object* from, Ir.Intf.Object* to);
        public abstract Ir.Intf.Object* SizeOf(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type);
    }
}
