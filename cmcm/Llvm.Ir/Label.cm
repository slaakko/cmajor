/*========================================================================
    Copyright (c) 2012-2016 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;

namespace Llvm
{
    public class LabelObject : Ir.Intf.LabelObject
    {
        public nothrow LabelObject() : base(Ir.Intf.Factory.Instance()->GetLabelType())
        {
        }
        public nothrow LabelObject(const string& label_) : base(Ir.Intf.Factory.Instance()->GetLabelType(), label_, "%" + label_)
        {
        }
        public override nothrow string Target() const
        {
            return GetLabelName() + ":";
        }
        public override nothrow void Set(Ir.Intf.LabelObject* from)
        {
            SetLabelName(from->GetLabelName());
            SetName("%" + GetLabelName());
        }
        public override void InitTo(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Object* to)
        {
            ThrowNotImplemented();
        }
        public override void InitFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Constant& constant)
        {
            ThrowNotImplemented();
        }
        public override void InitFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Global& global)
        {
            ThrowNotImplemented();
        }
        public override void InitFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.RegVar& regVar)
        {
            ThrowNotImplemented();
        }
        public override void InitFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.StackVar& stackVar)
        {
            ThrowNotImplemented();
        }
        public override void InitFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.MemberVar& memberVar)
        {
            ThrowNotImplemented();
        }
        public override void InitFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.RefVar& refVar)
        {
            ThrowNotImplemented();
        }
        public override void InitFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Parameter& parameter)
        {
            ThrowNotImplemented();
        }
        public override void AssignTo(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Object* to)
        {
            ThrowNotImplemented();
        }
        public override void AssignFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Constant& constant)
        {
            ThrowNotImplemented();
        }
        public override void AssignFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Global& global)
        {
            ThrowNotImplemented();
        }
        public override void AssignFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.RegVar& regVar)
        {
            ThrowNotImplemented();
        }
        public override void AssignFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.StackVar& stackVar)
        {
            ThrowNotImplemented();
        }
        public override void AssignFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.MemberVar& memberVar)
        {
            ThrowNotImplemented();
        }
        public override void AssignFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.RefVar& refVar)
        {
            ThrowNotImplemented();
        }
        public override void AssignFrom(Ir.Intf.Emitter& emitter, Ir.Intf.Type* type, Ir.Intf.Parameter& parameter)
        {
            ThrowNotImplemented();
        }
    }
    
    public nothrow Ir.Intf.LabelObject* CreateLabel()
    {
        return new LabelObject();
    }

    public nothrow Ir.Intf.LabelObject* CreateLabel(const string& label)
    {
        return new LabelObject(label);
    }
    
    internal class LocalLabelCounter
    {
        public static nothrow int Next()
        {
            return counter++;
        }
        public static nothrow void Reset()
        {
            counter = 0;
        }
        private static int counter;
    }
    
    public static class Breaker
    {
        public static nothrow void Set(int x)
        {
            b = x;
        }
        public static nothrow bool IsSet(int x) 
        {
            return b == x;
        }
        public static nothrow void PushString(const string& str)
        {
            try
            {
                ss.Push(s);
            }
            catch (const Exception& ex)
            {
            }
            s = str;
        }
        public static nothrow void PopString()
        {
            try
            {
                s = ss.Pop();
            }
            catch (const Exception& ex)
            {
            }
        }
        public static nothrow string Str() 
        {
            return s;
        }
        private static int b;
        private static string s;
        private static Stack<string> ss;
    }

    public class Pusher
    {
        public nothrow Pusher(const string& s)
        {
            Breaker.PushString(s);
        }
        public nothrow ~Pusher()
        {
            Breaker.PopString();
        }
    }
            
    public nothrow Ir.Intf.LabelObject* CreateNextLocalLabel()
    {
        int next = LocalLabelCounter.Next();
        if (Breaker.IsSet(1))
        {
            try
            {
                Console.Out() << next << ": " << Breaker.Str() << endl();
            }
            catch (const Exception& ex)
            {
            }
        }
        return CreateLabel("$L" + ToString(next));
    }
    
    public nothrow void ResetLocalLabelCounter()
    {
        LocalLabelCounter.Reset();
    }
}
