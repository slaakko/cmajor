/*========================================================================
    Copyright (c) 2012-2016 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;

namespace Llvm
{
    public class BinOpInstruction : Ir.Intf.Instruction
    {
        public nothrow BinOpInstruction(Ir.Intf.Type* type_, const string& name_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : 
            base(name_), type(type_), result(result_), operand1(operand1_), operand2(operand2_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s(result->Name());
            s.Append(" = ").Append(Name()).Append(' ').Append(type->Name()).Append(' ').Append(operand1->Name()).Append(", ").Append(operand2->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* operand1;
        private Ir.Intf.Object* operand2;
    }
    
    public class AddInst : BinOpInstruction
    {
        public nothrow AddInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "add", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Add(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new AddInst(integerType, result, operand1, operand2);
    }
    
    public class SubInst : BinOpInstruction
    {
        public nothrow SubInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "sub", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Sub(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new SubInst(integerType, result, operand1, operand2);
    }
    
    public class MulInst : BinOpInstruction
    {
        public nothrow MulInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "mul", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Mul(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new MulInst(integerType, result, operand1, operand2);
    }

    public class UDivInst : BinOpInstruction
    {
        public nothrow UDivInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "udiv", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* UDiv(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new UDivInst(integerType, result, operand1, operand2);
    }

    public class SDivInst : BinOpInstruction
    {
        public nothrow SDivInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "sdiv", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* SDiv(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new SDivInst(integerType, result, operand1, operand2);
    }
    
    public class URemInst : BinOpInstruction
    {
        public nothrow URemInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "urem", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* URem(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new URemInst(integerType, result, operand1, operand2);
    }

    public class SRemInst : BinOpInstruction
    {
        public nothrow SRemInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "srem", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* SRem(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new SRemInst(integerType, result, operand1, operand2);
    }
    
    public class ShlInst : BinOpInstruction
    {
        public nothrow ShlInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "shl", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Shl(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new ShlInst(integerType, result, operand1, operand2);
    }
    
    public class LShrInst : BinOpInstruction
    {
        public nothrow LShrInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "lshr", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* LShr(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new LShrInst(integerType, result, operand1, operand2);
    }

    public class AShrInst : BinOpInstruction
    {
        public nothrow AShrInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "ashr", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* AShr(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new AShrInst(integerType, result, operand1, operand2);
    }
    
    public class AndInst : BinOpInstruction
    {
        public nothrow AndInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "and", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* And(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new AndInst(integerType, result, operand1, operand2);
    }
    
    public class OrInst : BinOpInstruction
    {
        public nothrow OrInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "or", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Or(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new OrInst(integerType, result, operand1, operand2);
    }

    public class XorInst : BinOpInstruction
    {
        public nothrow XorInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "xor", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Xor(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new XorInst(integerType, result, operand1, operand2);
    }
    
    public class FAddInst : BinOpInstruction
    {
        public nothrow FAddInst(Ir.Intf.Type* floatingPointType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(floatingPointType_, "fadd", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* FAdd(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FAddInst(floatingPointType, result, operand1, operand2);
    }

    public class FSubInst : BinOpInstruction
    {
        public nothrow FSubInst(Ir.Intf.Type* floatingPointType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(floatingPointType_, "fsub", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* FSub(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FSubInst(floatingPointType, result, operand1, operand2);
    }

    public class FMulInst : BinOpInstruction
    {
        public nothrow FMulInst(Ir.Intf.Type* floatingPointType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(floatingPointType_, "fmul", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* FMul(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FMulInst(floatingPointType, result, operand1, operand2);
    }

    public class FDivInst : BinOpInstruction
    {
        public nothrow FDivInst(Ir.Intf.Type* floatingPointType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(floatingPointType_, "fdiv", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* FDiv(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FDivInst(floatingPointType, result, operand1, operand2);
    }

    public class FRemInst : BinOpInstruction
    {
        public nothrow FRemInst(Ir.Intf.Type* floatingPointType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(floatingPointType_, "frem", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* FRem(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FRemInst(floatingPointType, result, operand1, operand2);
    }
    
    public class RetInst : Ir.Intf.Instruction
    {
        public nothrow RetInst() : base("ret"), value(null)
        {
        }
        public nothrow RetInst(Ir.Intf.Object* value_) : base("ret"), value(value_)
        {
        }
        public nothrow override bool IsTerminator() const
        {
            return true;
        }
        public nothrow override bool IsRet() const
        {
            return true;
        }
        public nothrow override string ToString() const
        {
            string ret(Name());
            if (value != null)
            {
                ret.Append(' ').Append(value->GetType()->Name()).Append(' ').Append(value->Name());
            }
            else
            {
                ret.Append(' ').Append(Ir.Intf.Factory.Instance()->GetVoid()->Name());
            }
            return ret;
        }
        private Ir.Intf.Object* value;
    }
    
    public nothrow inline Ir.Intf.Instruction* Ret()
    {
        return new RetInst();
    }
    
    public nothrow inline Ir.Intf.Instruction* Ret(Ir.Intf.Object* value)
    {
        return new RetInst(value);
    }
    
    public class BrInst : Ir.Intf.Instruction
    {
        public nothrow BrInst(Ir.Intf.LabelObject* dest_) : base("br"), dest(dest_), cond(null), trueLabel(null), falseLabel(null)
        {
        }
        public nothrow BrInst(Ir.Intf.Object* cond_, Ir.Intf.LabelObject* trueLabel_, Ir.Intf.LabelObject* falseLabel_) : base("br"), dest(null), cond(cond_), trueLabel(trueLabel_), falseLabel(falseLabel_)
        {
        }
        public nothrow override string ToString() const
        {
            string br(Name());
            Ir.Intf.Type* labelType = Ir.Intf.Factory.Instance()->GetLabelType();
            if (cond != null)
            {
                br.Append(' ').Append(Ir.Intf.Factory.Instance()->GetI1()->Name()).Append(' ').Append(cond->Name()).Append(", ").Append(labelType->Name()).Append(' ').Append(trueLabel->Name()).Append(", ").
                    Append(labelType->Name()).Append(' ').Append(falseLabel->Name());
            }
            else
            {
                br.Append(' ').Append(labelType->Name()).Append(' ').Append(dest->Name());
            }
            return br;
        }
        public override void AddTargetLabels(HashSet<string>& targetLabels)
        {
            if (dest != null)
            {
                targetLabels.Insert(dest->Name());
            }
            else
            {
                if (trueLabel != null)
                {
                    targetLabels.Insert(trueLabel->Name());
                }
                if (falseLabel != null)
                {
                    targetLabels.Insert(falseLabel->Name());
                }
            }
        }
        public nothrow override bool IsTerminator() const
        {
            return true;
        }
        public nothrow override Ir.Intf.LabelObject* GetTargetLabel() const
        {
            return dest;
        }
        public nothrow override bool IsUnconditionalBr() const
        {
            return dest != null;
        }
        private Ir.Intf.LabelObject* dest;
        private Ir.Intf.Object* cond;
        private Ir.Intf.LabelObject* trueLabel;
        private Ir.Intf.LabelObject* falseLabel;
    }
    
    public nothrow inline Ir.Intf.Instruction* Br(Ir.Intf.LabelObject* dest)
    {
        return new BrInst(dest);
    }
    
    public nothrow inline Ir.Intf.Instruction* Br(Ir.Intf.Object* cond, Ir.Intf.LabelObject* trueLabel, Ir.Intf.LabelObject* falseLabel)
    {
        return new BrInst(cond, trueLabel, falseLabel);
    }
    
    public class SwitchInst : Ir.Intf.Instruction
    {
        public nothrow SwitchInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* value_, Ir.Intf.LabelObject* defaultDest_, const List<Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>>& destinations_) : 
            base("switch"), integerType(integerType_), value(value_), defaultDest(defaultDest_), destinations(destinations_)
        {
        }
        public nothrow override bool IsTerminator() const
        {
            return true;
        }
        public override void AddTargetLabels(HashSet<string>& targetLabels)
        {
            targetLabels.Insert(defaultDest->Name());
            for (const Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>& dest : destinations)
            {
                targetLabels.Insert(dest.second->Name());
            }
        }
        public nothrow override string ToString() const
        {
            string s(Name());
            Ir.Intf.Type* labelType = Ir.Intf.Factory.Instance()->GetLabelType();
            s.Append(' ').Append(integerType->Name()).Append(' ').Append(value->Name()).Append(", ").Append(labelType->Name()).Append(' ').Append(defaultDest->Name()).Append(" [");
            for (const Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>& dest : destinations)
            {
                s.Append(' ').Append(integerType->Name()).Append(' ').Append(dest.first->Name()).Append(", ").Append(labelType->Name()).Append(' ').Append(dest.second->Name());
            }
            s.Append(" ]");
            return s;
        }
        private Ir.Intf.Type* integerType;
        private Ir.Intf.Object* value;
        private Ir.Intf.LabelObject* defaultDest;
        private List<Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>> destinations;
    }
    
    public nothrow inline Ir.Intf.Instruction* Switch(Ir.Intf.Type* integerType, Ir.Intf.Object* value, Ir.Intf.LabelObject* defaultDest, const List<Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>>& destinations)
    {
        return new SwitchInst(integerType, value, defaultDest, destinations);
    }
    
    public class AllocaInst : Ir.Intf.Instruction
    {
        public nothrow AllocaInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_) : 
            base("alloca"), type(type_), result(result_), numElementsType(null), numElements(0), alignment(0)
        {
        }
        public nothrow AllocaInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Type* numElementsType_, int numElements_) : 
            base("alloca"), type(type_), result(result_), numElementsType(numElementsType_), numElements(numElements_), alignment(0)
        {
        }
        public nothrow override void SetAlignment(int alignment_)
        {
            alignment = alignment_;
        }
        public nothrow override string ToString() const
        {
            string s = result->Name();
            s.Append(" = ").Append(Name()).Append(' ').Append(type->Name());
            if (numElements > 0)
            {
                #assert(numElementsType != null);
                s.Append(", ").Append(numElementsType->Name()).Append(' ').Append(ToString(numElements));
            }
            if (alignment > 0)
            {
                s.Append(", align ").Append(ToString(alignment));
            }
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.Type* numElementsType;
        private int numElements;
        private int alignment;
    }
    
    public nothrow inline Ir.Intf.Instruction* Alloca(Ir.Intf.Type* type, Ir.Intf.Object* result)
    {
        return new AllocaInst(type, result);
    }
    
    public nothrow inline Ir.Intf.Instruction* Alloca(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Type* numElementsType, int numElements)
    {
        return new AllocaInst(type, result, numElementsType, numElements);
    }
    
    public class LoadInst : Ir.Intf.Instruction
    {
        public nothrow LoadInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* ptr_) : base("load"), type(type_), result(result_), ptr(ptr_), alignment(0)
        {
        }
        public nothrow override void SetAlignment(int alignment_)
        {
            alignment = alignment_;
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s(result->Name());
            s.Append(" = ").Append(Name()).Append(", ").Append(type->Name()).Append(' ').Append(ptr->Name());
            if (alignment > 0)
            {
                s.Append(", align ").Append(ToString(alignment));
            }
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* ptr;
        private int alignment;
    }
    
    public nothrow inline Ir.Intf.Instruction* Load(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* ptr)
    {
        return new LoadInst(type, result, ptr);
    }
    
    public class StoreInst : Ir.Intf.Instruction
    {
        public nothrow StoreInst(Ir.Intf.Type* type_, Ir.Intf.Object* value_, Ir.Intf.Object* ptr_) : base("store"), type(type_), value(value_), ptr(ptr_), alignment(0)
        {
        }
        public nothrow override void SetAlignment(int alignment_)
        {
            alignment = alignment_;
        }
        public nothrow override string ToString() const
        {
            string s(Name());
            s.Append(' ').Append(type->Name()).Append(' ').Append(value->Name()).Append(", ").Append(ptr->GetType()->Name()).Append(' ').Append(ptr->Name());
            if (alignment > 0)
            {
                s.Append(", align ").Append(ToString(alignment));
            }
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* value;
        private Ir.Intf.Object* ptr;
        private int alignment;
    }
    
    public nothrow inline Ir.Intf.Instruction* Store(Ir.Intf.Type* type, Ir.Intf.Object* value, Ir.Intf.Object* ptr)
    {
        return new StoreInst(type, value, ptr);
    }
    
    public class GetElementPtrInst : Ir.Intf.Instruction
    {
        public nothrow GetElementPtrInst(Ir.Intf.Type* ptrType_, Ir.Intf.Object* result_, Ir.Intf.Object* ptr_, Ir.Intf.Object* index_) :
            base("getelementptr"), ptrType(ptrType_), result(result_), ptr(ptr_), index(index_), indeces(), inbounds(false)
        {
        }
        public GetElementPtrInst(Ir.Intf.Type* ptrType_, Ir.Intf.Object* result_, Ir.Intf.Object* ptr_, Ir.Intf.Object* index_, Ir.Intf.Object* index1_) : 
            base("getelementptr"), ptrType(ptrType_), result(result_), ptr(ptr_), index(index_), indeces(), inbounds(false)
        {
            indeces.Add(index1_);
        }
        public nothrow GetElementPtrInst(Ir.Intf.Type* ptrType_, Ir.Intf.Object* result_, Ir.Intf.Object* ptr_, Ir.Intf.Object* index_, const List<Ir.Intf.Object*>& indeces_) : 
            base("getelementptr"), ptrType(ptrType_), result(result_), ptr(ptr_), index(index_), indeces(indeces_), inbounds(false)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override void SetInbounds() 
        {
            inbounds = true;
        }
        public nothrow override string ToString() const
        {
            string s(result->Name());
            s.Append(" = ").Append(Name()).Append(' ');
            if (inbounds)
            {
                s.Append("inbounds ");
            }
            s.Append(ptrType->Name()).Append(' ').Append(ptr->Name()).Append(", ").Append(index->GetType()->Name()).Append(' ').Append(index->Name());
            for (Ir.Intf.Object* idx : indeces)
            {
                s.Append(", ").Append(idx->GetType()->Name()).Append(' ').Append(idx->Name());
            }
            return s;
        }
        private Ir.Intf.Type* ptrType;
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* ptr;
        private Ir.Intf.Object* index;
        private List<Ir.Intf.Object*> indeces;
        private bool inbounds;
    }
    
    public nothrow inline Ir.Intf.Instruction* GetElementPtr(Ir.Intf.Type* ptrType, Ir.Intf.Object* result, Ir.Intf.Object* ptr, Ir.Intf.Object* index)
    {
        return new GetElementPtrInst(ptrType, result, ptr, index);
    }
    
    public inline Ir.Intf.Instruction* GetElementPtr(Ir.Intf.Type* ptrType, Ir.Intf.Object* result, Ir.Intf.Object* ptr, Ir.Intf.Object* index, Ir.Intf.Object* index1)
    {
        return new GetElementPtrInst(ptrType, result, ptr, index, index1);
    }
    
    public nothrow inline Ir.Intf.Instruction* GetElementPtr(Ir.Intf.Type* ptrType, Ir.Intf.Object* result, Ir.Intf.Object* ptr, Ir.Intf.Object* index, const List<Ir.Intf.Object*>& indeces)
    {
        return new GetElementPtrInst(ptrType, result, ptr, index, indeces);
    }
    
    public class CallInst : Ir.Intf.Instruction
    {
        public nothrow CallInst(Ir.Intf.Object* result_, Ir.Intf.Function* fun_, const List<Ir.Intf.Object*>& args_) : 
            base("call"), result(result_), fun(fun_), args(args_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return result != null && !(result->GetType() is VoidType*);
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s;
            if (result != null && !(result->GetType() is VoidType*))
            {
                s.Append(result->Name()).Append(" = ");
            }
            s.Append(Name()).Append(' ').Append(fun->ReturnType()->Name()).Append(" @").Append(fun->Name()).Append('(');
            bool first = true;
            for (Ir.Intf.Object* arg : args)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    s.Append(", ");
                }
                s.Append(arg->GetType()->Name()).Append(' ').Append(arg->Name());
            }
            s.Append(')');
            return s;
        }
        private Ir.Intf.Object* result;
        private Ir.Intf.Function* fun;
        private List<Ir.Intf.Object*> args;
    }
    
    public nothrow inline Ir.Intf.Instruction* Call(Ir.Intf.Object* result, Ir.Intf.Function* fun, const List<Ir.Intf.Object*>& args)
    {
        return new CallInst(result, fun, args);
    }
    
    public class IndirectCallInst : Ir.Intf.Instruction
    {
        public nothrow IndirectCallInst(Ir.Intf.Object* result_, Ir.Intf.Object* funPtr_, const List<Ir.Intf.Object*>& args_) : base("call"), result(result_), funPtr(funPtr_), args(args_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return result != null && !(result->GetType() is VoidType*);
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string returnTypeName = "void";
            string s;
            if (result != null && !(result->GetType() is VoidType*))
            {
                s.Append(result->Name()).Append(" = ");
                returnTypeName = result->GetType()->Name();
            }
            s.Append(Name()).Append(' ').Append(returnTypeName).Append(' ').Append(funPtr->Name()).Append('(');
            bool first = true;
            for (Ir.Intf.Object* arg : args)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    s.Append(", ");
                }
                s.Append(arg->GetType()->Name()).Append(' ').Append(arg->Name());
            }
            s.Append(')');
            return s;
        }
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* funPtr;
        private List<Ir.Intf.Object*> args;
    }
    
    public Ir.Intf.Instruction* IndirectCall(Ir.Intf.Object* result, Ir.Intf.Object* funPtr, const List<Ir.Intf.Object*>& args)
    {
        return new IndirectCallInst(result, funPtr, args);
    }
    
    public nothrow const char* ConditionCodeStr(Ir.Intf.IConditionCode cond)
    {
        switch (cond)
        {
            case Ir.Intf.IConditionCode.eq: return "eq";
            case Ir.Intf.IConditionCode.ne: return "ne";
            case Ir.Intf.IConditionCode.ugt: return "ugt";
            case Ir.Intf.IConditionCode.uge: return "uge";
            case Ir.Intf.IConditionCode.ult: return "ult";
            case Ir.Intf.IConditionCode.ule: return "ule";
            case Ir.Intf.IConditionCode.sgt: return "sgt";
            case Ir.Intf.IConditionCode.sge: return "sge";
            case Ir.Intf.IConditionCode.slt: return "slt";
            case Ir.Intf.IConditionCode.sle: return "sle";
        }
        return "";
    }
    
    public class ICmpInst : Ir.Intf.Instruction
    {
        public nothrow ICmpInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.IConditionCode cond_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : 
            base("icmp"), type(type_), result(result_), cond(cond_), operand1(operand1_), operand2(operand2_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s(result->Name());
            s.Append(" = ").Append(Name()).Append(' ').Append(ConditionCodeStr(cond)).Append(' ').Append(type->Name()).Append(' ').Append(operand1->Name()).Append(", ").Append(operand2->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.IConditionCode cond;
        private Ir.Intf.Object* operand1;
        private Ir.Intf.Object* operand2;   
    }
    
    public nothrow inline Ir.Intf.Instruction* ICmp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.IConditionCode cond, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new ICmpInst(type, result, cond, operand1, operand2);
    }
    
    public nothrow const char* ConditionCodeStr(Ir.Intf.FConditionCode cond)
    {
        switch (cond)
        {
            case Ir.Intf.FConditionCode.false_: return "false";
            case Ir.Intf.FConditionCode.oeq: return "oeq";
            case Ir.Intf.FConditionCode.ogt: return "ogt";
            case Ir.Intf.FConditionCode.oge: return "oge";
            case Ir.Intf.FConditionCode.olt: return "olt";
            case Ir.Intf.FConditionCode.ole: return "ole";
            case Ir.Intf.FConditionCode.one: return "one";
            case Ir.Intf.FConditionCode.ord: return "ord";
            case Ir.Intf.FConditionCode.ueq: return "ueq";
            case Ir.Intf.FConditionCode.ugt: return "ugt";
            case Ir.Intf.FConditionCode.uge: return "uge";
            case Ir.Intf.FConditionCode.ult: return "ult";
            case Ir.Intf.FConditionCode.ule: return "ule";
            case Ir.Intf.FConditionCode.une: return "une";
            case Ir.Intf.FConditionCode.uno: return "uno";
            case Ir.Intf.FConditionCode.true_: return "true";
        }        
        return "";
    }
    
    public class FCmpInst : Ir.Intf.Instruction
    {
        public nothrow FCmpInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.FConditionCode cond_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : 
            base("fcmp"), type(type_), result(result_), cond(cond_), operand1(operand1_), operand2(operand2_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s(result->Name());
            s.Append(" = ").Append(Name()).Append(' ').Append(ConditionCodeStr(cond)).Append(' ').Append(type->Name()).Append(' ').Append(operand1->Name()).Append(", ").Append(operand2->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.FConditionCode cond;
        private Ir.Intf.Object* operand1;
        private Ir.Intf.Object* operand2;
    }
    
    public nothrow inline Ir.Intf.Instruction* FCmp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.FConditionCode cond, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FCmpInst(type, result, cond, operand1, operand2);
    }
    
    public class DoNothingInst : Ir.Intf.Instruction
    {
        public nothrow DoNothingInst() : base("call void @llvm.donothing()")
        {
        }
        public nothrow override string ToString() const
        {
            return Name();
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* DoNothing()
    {
        return new DoNothingInst();
    }
    
    public abstract class ConversionInstruction : Ir.Intf.Instruction
    {
        public nothrow ConversionInstruction(const string& name_, Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) : 
            base(name_), type(type_), result(result_), value(value_), toType(toType_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s(result->Name());
            s.Append(" = ").Append(Name()).Append(' ').Append(type->Name()).Append(' ').Append(value->Name()).Append(" to ").Append(toType->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* value;
        private Ir.Intf.Type* toType;
    }
    
    public class TruncInst : ConversionInstruction
    {
        public nothrow TruncInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("trunc", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Trunc(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new TruncInst(type, result, value, toType);
    }
    
    public class ZextInst : ConversionInstruction
    {
        public nothrow ZextInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("zext", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Zext(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new ZextInst(type, result, value, toType);
    }

    public class SextInst : ConversionInstruction
    {
        public nothrow SextInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("sext", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Sext(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new SextInst(type, result, value, toType);
    }

    public class FptruncInst : ConversionInstruction
    {
        public nothrow FptruncInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("fptrunc", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Fptrunc(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new FptruncInst(type, result, value, toType);
    }

    public class FpextInst : ConversionInstruction
    {
        public nothrow FpextInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("fpext", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Fpext(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new FpextInst(type, result, value, toType);
    }

    public class FptouiInst : ConversionInstruction
    {
        public nothrow FptouiInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("fptoui", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Fptoui(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new FptouiInst(type, result, value, toType);
    }

    public class FptosiInst : ConversionInstruction
    {
        public nothrow FptosiInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("fptosi", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Fptosi(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new FptosiInst(type, result, value, toType);
    }

    public class UitofpInst : ConversionInstruction
    {
        public nothrow UitofpInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("uitofp", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Uitofp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new UitofpInst(type, result, value, toType);
    }

    public class SitofpInst : ConversionInstruction
    {
        public nothrow SitofpInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("sitofp", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Sitofp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new SitofpInst(type, result, value, toType);
    }

    public class PtrtointInst : ConversionInstruction
    {
        public nothrow PtrtointInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("ptrtoint", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Ptrtoint(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new PtrtointInst(type, result, value, toType);
    }

    public class InttoptrInst : ConversionInstruction
    {
        public nothrow InttoptrInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("intotptr", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Inttoptr(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new InttoptrInst(type, result, value, toType);
    }

    public class BitcastInst : ConversionInstruction
    {
        public nothrow BitcastInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("bitcast", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Bitcast(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new BitcastInst(type, result, value, toType);
    }
    
    public class MemSetInst : Ir.Intf.Instruction
    {
        public nothrow MemSetInst(Ir.Intf.Object* dest_, Ir.Intf.Object* value_, Ir.Intf.Object* len_, int align_, bool isVolatile_) 
            : base("memset"), dest(dest_), value(value_), len(len_), align(align_), isVolatile(isVolatile_)
        {
        }
        public nothrow override string ToString() const
        {
            string s("call void @llvm.memset.p0i8.i64(i8* ");
            s.Append(dest->Name()).Append(", i8 ").Append(value->Name()).Append(", i64 ").Append(len->Name()).Append(", i32 ").Append(ToString(align)).Append(", i1 ");
            if (isVolatile)
            {
                s.Append("true");
            }
            else
            {
                s.Append("false");
            }
            s.Append(')');
            return s;
        }
        private Ir.Intf.Object* dest;
        private Ir.Intf.Object* value;
        private Ir.Intf.Object* len;
        private int align;
        private bool isVolatile;
    }
    
    public nothrow inline Ir.Intf.Instruction* MemSet(Ir.Intf.Object* dest, Ir.Intf.Object* value, Ir.Intf.Object* len, int align, bool isVolatile)
    {
        return new MemSetInst(dest, value, len, align, isVolatile);
    }

    public class MemCopyInst : Ir.Intf.Instruction
    {
        public nothrow MemCopyInst(Ir.Intf.Object* dest_, Ir.Intf.Object* source_, Ir.Intf.Object* len_, int align_, bool isVolatile_) 
            : base("memcopy"), dest(dest_), source(source_), len(len_), align(align_), isVolatile(isVolatile_)
        {
        }
        public nothrow override string ToString() const
        {
            string s("call void @llvm.memcpy.p0i8.i64(i8* ");
            s.Append(dest->Name()).Append(", i8 ").Append(source->Name()).Append(", i64 ").Append(len->Name()).Append(", i32 ").Append(ToString(align)).Append(", i1 ");
            if (isVolatile)
            {
                s.Append("true");
            }
            else
            {
                s.Append("false");
            }
            s.Append(')');
            return s;
        }
        private Ir.Intf.Object* dest;
        private Ir.Intf.Object* source;
        private Ir.Intf.Object* len;
        private int align;
        private bool isVolatile;
    }
    
    public nothrow inline Ir.Intf.Instruction* MemCopy(Ir.Intf.Object* dest, Ir.Intf.Object* source, Ir.Intf.Object* len, int align, bool isVolatile)
    {
        return new MemCopyInst(dest, source, len, align, isVolatile);
    }
}
