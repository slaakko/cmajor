/*========================================================================
    Copyright (c) 2012-2015 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;

namespace C
{
    public class BinOpInstruction : Ir.Intf.Instruction
    {
        public nothrow BinOpInstruction(Ir.Intf.Type* type_, const string& name_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : 
            base(name_), type(type_), result(result_), operand1(operand1_), operand2(operand2_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s = result->Name();
            s.Append(" = ").Append(operand1->Name()).Append(' ').Append(Name()).Append(' ').Append(operand2->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* operand1;
        private Ir.Intf.Object* operand2;
    }
    
    public class AddInst : BinOpInstruction
    {
        public nothrow AddInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "+", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Add(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new AddInst(integerType, result, operand1, operand2);
    }

    public class SubInst : BinOpInstruction
    {
        public nothrow SubInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "-", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Sub(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new SubInst(integerType, result, operand1, operand2);
    }

    public class MulInst : BinOpInstruction
    {
        public nothrow MulInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "*", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Mul(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new MulInst(integerType, result, operand1, operand2);
    }

    public class UDivInst : BinOpInstruction
    {
        public nothrow UDivInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "/", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* UDiv(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new UDivInst(integerType, result, operand1, operand2);
    }

    public class SDivInst : BinOpInstruction
    {
        public nothrow SDivInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "/", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* SDiv(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new SDivInst(integerType, result, operand1, operand2);
    }
   
    public class URemInst : BinOpInstruction
    {
        public nothrow URemInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "%", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* URem(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new URemInst(integerType, result, operand1, operand2);
    }

    public class SRemInst : BinOpInstruction
    {
        public nothrow SRemInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "%", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* SRem(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new SRemInst(integerType, result, operand1, operand2);
    }

    public class ShlInst : BinOpInstruction
    {
        public nothrow ShlInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "<<", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Shl(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new ShlInst(integerType, result, operand1, operand2);
    }
    
    public class LShrInst : BinOpInstruction
    {
        public nothrow LShrInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, ">>", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* LShr(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new LShrInst(integerType, result, operand1, operand2);
    }

    public class AShrInst : BinOpInstruction
    {
        public nothrow AShrInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, ">>", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* AShr(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new AShrInst(integerType, result, operand1, operand2);
    }
    
    public class AndInst : BinOpInstruction
    {
        public nothrow AndInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "&", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* And(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new AndInst(integerType, result, operand1, operand2);
    }
    
    public class OrInst : BinOpInstruction
    {
        public nothrow OrInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "|", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Or(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new OrInst(integerType, result, operand1, operand2);
    }

    public class XorInst : BinOpInstruction
    {
        public nothrow XorInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(integerType_, "^", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Xor(Ir.Intf.Type* integerType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new XorInst(integerType, result, operand1, operand2);
    }
    
    public class FAddInst : BinOpInstruction
    {
        public nothrow FAddInst(Ir.Intf.Type* floatingPointType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(floatingPointType_, "+", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* FAdd(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FAddInst(floatingPointType, result, operand1, operand2);
    }

    public class FSubInst : BinOpInstruction
    {
        public nothrow FSubInst(Ir.Intf.Type* floatingPointType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(floatingPointType_, "-", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* FSub(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FSubInst(floatingPointType, result, operand1, operand2);
    }

    public class FMulInst : BinOpInstruction
    {
        public nothrow FMulInst(Ir.Intf.Type* floatingPointType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(floatingPointType_, "*", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* FMul(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FMulInst(floatingPointType, result, operand1, operand2);
    }

    public class FDivInst : BinOpInstruction
    {
        public nothrow FDivInst(Ir.Intf.Type* floatingPointType_, Ir.Intf.Object* result_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : base(floatingPointType_, "/", result_, operand1_, operand2_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* FDiv(Ir.Intf.Type* floatingPointType, Ir.Intf.Object* result, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FDivInst(floatingPointType, result, operand1, operand2);
    }
    
    public class IndexInst : Ir.Intf.Instruction
    {
        public nothrow IndexInst(Ir.Intf.Object* result_, Ir.Intf.Object* array_, Ir.Intf.Object* index_) : base("[]"), result(result_), array(array_), index(index_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s = result->Name();
            s.Append(" = &").Append(array->Name()).Append('[').Append(index->Name()).Append(']');
            return s;
        }
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* array;
        private Ir.Intf.Object* index;
    }

    public class RetInst : Ir.Intf.Instruction
    {
        public nothrow RetInst() : base("return"), value(null)
        {
        }
        public nothrow RetInst(Ir.Intf.Object* value_) : base("return"), value(value_)
        {
        }
        public nothrow override bool IsTerminator() const
        {
            return true;
        }
        public nothrow override bool IsRet() const
        {
            return true;
        }
        public nothrow override string ToString() const
        {
            string ret(Name());
            if (value != null)
            {
                ret.Append(' ').Append(value->Name());
            }
            return ret;
        }
        private Ir.Intf.Object* value;
    }
    
    public nothrow inline Ir.Intf.Instruction* Ret()
    {
        return new RetInst();
    }
    
    public nothrow inline Ir.Intf.Instruction* Ret(Ir.Intf.Object* value)
    {
        return new RetInst(value);
    }
    
    public class BrInst : Ir.Intf.Instruction
    {
        public nothrow BrInst(Ir.Intf.LabelObject* dest_) : base("goto"), dest(dest_), cond(null), trueLabel(null), falseLabel(null)
        {
        }
        public nothrow BrInst(Ir.Intf.Object* cond_, Ir.Intf.LabelObject* trueLabel_, Ir.Intf.LabelObject* falseLabel_) : base("goto"), dest(null), cond(cond_), trueLabel(trueLabel_), falseLabel(falseLabel_)
        {
        }
        public nothrow override string ToString() const
        {
            string br;
            Ir.Intf.Type* labelType = Ir.Intf.Factory.Instance()->GetLabelType();
            if (cond != null)
            {
                br.Append("if (").Append(cond->Name()).Append(") goto ").Append(trueLabel->Name()).Append("; else goto ").Append(falseLabel->Name());
            }
            else
            {
                br.Append("goto ").Append(dest->Name());
            }
            return br;
        }
        public override void AddTargetLabels(HashSet<string>& targetLabels)
        {
            if (dest != null)
            {
                targetLabels.Insert(dest->Name());
            }
            else
            {
                if (trueLabel != null)
                {
                    targetLabels.Insert(trueLabel->Name());
                }
                if (falseLabel != null)
                {
                    targetLabels.Insert(falseLabel->Name());
                }
            }
        }
        public nothrow override bool IsTerminator() const
        {
            return true;
        }
        public nothrow override Ir.Intf.LabelObject* GetTargetLabel() const
        {
            return dest;
        }
        public nothrow override bool IsUnconditionalBr() const
        {
            return dest != null;
        }
        private Ir.Intf.LabelObject* dest;
        private Ir.Intf.Object* cond;
        private Ir.Intf.LabelObject* trueLabel;
        private Ir.Intf.LabelObject* falseLabel;
    }
    
    public nothrow inline Ir.Intf.Instruction* Br(Ir.Intf.LabelObject* dest)
    {
        return new BrInst(dest);
    }
    
    public nothrow inline Ir.Intf.Instruction* Br(Ir.Intf.Object* cond, Ir.Intf.LabelObject* trueLabel, Ir.Intf.LabelObject* falseLabel)
    {
        return new BrInst(cond, trueLabel, falseLabel);
    }

    public class SwitchInst : Ir.Intf.Instruction
    {
        public nothrow SwitchInst(Ir.Intf.Type* integerType_, Ir.Intf.Object* value_, Ir.Intf.LabelObject* defaultDest_, const List<Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>>& destinations_) : 
            base("switch"), integerType(integerType_), value(value_), defaultDest(defaultDest_), destinations(destinations_)
        {
        }
        public nothrow override bool IsTerminator() const
        {
            return true;
        }
        public override void AddTargetLabels(HashSet<string>& targetLabels)
        {
            targetLabels.Insert(defaultDest->Name());
            for (const Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>& dest : destinations)
            {
                targetLabels.Insert(dest.second->Name());
            }
        }
        public nothrow override string ToString() const
        {
            string s(Name());
            s.Append('(').Append(value->Name()).Append(") { ");
            for (const Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>& dest : destinations)
            {
                s.Append("case ").Append(dest.first->Name()).Append(": goto ").Append(dest.second->Name()).Append("; break;");
            }
            s.Append("default: goto ").Append(defaultDest->Name()).Append("; break; }");
            return s;
        }
        private Ir.Intf.Type* integerType;
        private Ir.Intf.Object* value;
        private Ir.Intf.LabelObject* defaultDest;
        private List<Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>> destinations;
    }
    
    public nothrow inline Ir.Intf.Instruction* Switch(Ir.Intf.Type* integerType, Ir.Intf.Object* value, Ir.Intf.LabelObject* defaultDest, const List<Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>>& destinations)
    {
        return new SwitchInst(integerType, value, defaultDest, destinations);
    }

    public class AllocaInst : Ir.Intf.Instruction
    {
        public nothrow AllocaInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_) : 
            base("alloca"), type(type_), result(result_), numElementsType(null), numElements(0), alignment(0)
        {
        }
        public nothrow AllocaInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Type* numElementsType_, int numElements_) : 
            base("alloca"), type(type_), result(result_), numElementsType(numElementsType_), numElements(numElements_), alignment(0)
        {
        }
        public nothrow override void SetAlignment(int alignment_)
        {
            alignment = alignment_;
        }
        public nothrow override string ToString() const
        {
            string s;
            if (type->IsFunctionPointerType() || type->IsFunctionPtrPtrType())
            {
                s.Append(type->Prefix()).Append(result->Name()).Append(type->Suffix());
            }
            else
            {
                s.Append(type->Name()).Append(' ').Append(result->Name());
                if (numElements > 0)
                {
                    s.Append('[').Append(ToString(numElements)).Append(']');
                }
            }
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.Type* numElementsType;
        private int numElements;
        private int alignment;
    }
    
    public nothrow inline Ir.Intf.Instruction* Alloca(Ir.Intf.Type* type, Ir.Intf.Object* result)
    {
        return new AllocaInst(type, result);
    }
    
    public nothrow inline Ir.Intf.Instruction* Alloca(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Type* numElementsType, int numElements)
    {
        return new AllocaInst(type, result, numElementsType, numElements);
    }
    
    public class LoadInst : Ir.Intf.Instruction
    {
        public nothrow LoadInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* ptr_, Ir.Intf.Indirection leftIndirection_, Ir.Intf.Indirection rightIndirection_) :
            base("load"), type(type_), result(result_), ptr(ptr_), alignment(0)
        {
        }
        public nothrow override void SetAlignment(int alignment_)
        {
            alignment = alignment_;
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s;
            if (leftIndirection == Ir.Intf.Indirection.deref)
            {
                s.Append('*');
            }
            else if (leftIndirection == Ir.Intf.Indirection.addr)
            {
                s.Append('&');
            }
            s.Append(result->Name()).Append(" = ");
            if (rightIndirection == Ir.Intf.Indirection.deref)
            {
                s.Append('*');
            }
            else if (rightIndirection == Ir.Intf.Indirection.addr)
            {
                s.Append('&');
            }
            s.Append(ptr->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* ptr;
        private int alignment;
        private Ir.Intf.Indirection leftIndirection;
        private Ir.Intf.Indirection rightIndirection;
    }
    
    public nothrow inline Ir.Intf.Instruction* Load(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* ptr, Ir.Intf.Indirection leftIndirection, Ir.Intf.Indirection rightIndirection)
    {
        return new LoadInst(type, result, ptr, leftIndirection, rightIndirection);
    }

    public class StoreInst : Ir.Intf.Instruction
    {
        public nothrow StoreInst(Ir.Intf.Type* type_, Ir.Intf.Object* value_, Ir.Intf.Object* ptr_, Ir.Intf.Indirection leftIndirection_, Ir.Intf.Indirection rightIndirection_) :
            base("store"), type(type_), value(value_), ptr(ptr_), alignment(0)
        {
        }
        public nothrow override void SetAlignment(int alignment_)
        {
            alignment = alignment_;
        }
        public nothrow override string ToString() const
        {
            string s;
            if (rightIndirection == Ir.Intf.Indirection.deref)
            {
                s.Append('*');
            }
            else if (rightIndirection == Ir.Intf.Indirection.addr)
            {
                s.Append('&');
            }
            s.Append(ptr->Name()).Append(" = ");
            if (leftIndirection == Ir.Intf.Indirection.deref)
            {
                s.Append('*');
            }
            else if (leftIndirection == Ir.Intf.Indirection.addr)
            {
                s.Append('&');
            }
            s.Append(value->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* value;
        private Ir.Intf.Object* ptr;
        private int alignment;
        private Ir.Intf.Indirection leftIndirection;
        private Ir.Intf.Indirection rightIndirection;
    }
    
    public nothrow inline Ir.Intf.Instruction* Store(Ir.Intf.Type* type, Ir.Intf.Object* value, Ir.Intf.Object* ptr, Ir.Intf.Indirection leftIndirection, Ir.Intf.Indirection rightIndirection)
    {
        return new StoreInst(type, value, ptr, leftIndirection, rightIndirection);
    }
    
    public class SetInst : Ir.Intf.Instruction
    {
        public nothrow SetInst(Ir.Intf.Object* from_, Ir.Intf.Object* to_) : base("set"), from(from_), to(to_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return to;
        }
        public nothrow override string ToString() const
        {
            string s = to->Name();
            s.Append(" = ").Append(from->Name());
            return s;
        }
        private Ir.Intf.Object* from;
        private Ir.Intf.Object* to;
    }
    
    public nothrow inline Ir.Intf.Instruction* Set(Ir.Intf.Object* from, Ir.Intf.Object* to)
    {
        return new SetInst(from, to);
    }
    
    public class CallInst : Ir.Intf.Instruction
    {
        public nothrow CallInst(Ir.Intf.Object* result_, Ir.Intf.Function* fun_, const List<Ir.Intf.Object*>& args_) : 
            base("call"), result(result_), fun(fun_), args(args_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return result != null && !(result->GetType() is VoidType*);
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s;
            if (result != null && !(result->GetType() is VoidType*))
            {
                s.Append(result->Name()).Append(" = ");
            }
            s.Append(fun->Name()).Append('(');
            bool first = true;
            for (Ir.Intf.Object* arg : args)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    s.Append(", ");
                }
                if ((arg is StackVar*) || (arg is Global*))
                {
                    s.Append('&');
                }
                s.Append(arg->Name());
            }
            s.Append(')');
            return s;
        }
        private Ir.Intf.Object* result;
        private Ir.Intf.Function* fun;
        private List<Ir.Intf.Object*> args;
    }
    
    public nothrow inline Ir.Intf.Instruction* Call(Ir.Intf.Object* result, Ir.Intf.Function* fun, const List<Ir.Intf.Object*>& args)
    {
        return new CallInst(result, fun, args);
    }
    
    public class IndirectCallInst : Ir.Intf.Instruction
    {
        public nothrow IndirectCallInst(Ir.Intf.Object* result_, Ir.Intf.Object* funPtr_, const List<Ir.Intf.Object*>& args_) : base("call"), result(result_), funPtr(funPtr_), args(args_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return result != null && !(result->GetType() is VoidType*);
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s;
            if (result != null && !(result->GetType() is VoidType*))
            {
                s.Append(result->Name()).Append(" = ");
            }
            s.Append(funPtr->Name()).Append('(');
            bool first = true;
            for (Ir.Intf.Object* arg : args)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    s.Append(", ");
                }
                if ((arg is StackVar*) || (arg is Global*))
                {
                    s.Append('&');
                }
                s.Append(arg->Name());
            }
            s.Append(')');
            return s;
        }
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* funPtr;
        private List<Ir.Intf.Object*> args;
    }
    
    public Ir.Intf.Instruction* IndirectCall(Ir.Intf.Object* result, Ir.Intf.Object* funPtr, const List<Ir.Intf.Object*>& args)
    {
        return new IndirectCallInst(result, funPtr, args);
    }
    
    public nothrow const char* ConditionCodeStr(Ir.Intf.IConditionCode cond)
    {
        switch (cond)
        {
            case Ir.Intf.IConditionCode.eq: return "==";
            case Ir.Intf.IConditionCode.ne: return "!=";
            case Ir.Intf.IConditionCode.ugt: return ">";
            case Ir.Intf.IConditionCode.uge: return ">=";
            case Ir.Intf.IConditionCode.ult: return "<";
            case Ir.Intf.IConditionCode.ule: return "<=";
            case Ir.Intf.IConditionCode.sgt: return ">";
            case Ir.Intf.IConditionCode.sge: return ">=";
            case Ir.Intf.IConditionCode.slt: return "<";
            case Ir.Intf.IConditionCode.sle: return "<=";
        }
        return "";
    }

    public class ICmpInst : Ir.Intf.Instruction
    {
        public nothrow ICmpInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.IConditionCode cond_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : 
            base("icmp"), type(type_), result(result_), cond(cond_), operand1(operand1_), operand2(operand2_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s(result->Name());
            s.Append(" = ").Append(operand1->Name()).Append(' ').Append(ConditionCodeStr(cond)).Append(' ').Append(operand2->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.IConditionCode cond;
        private Ir.Intf.Object* operand1;
        private Ir.Intf.Object* operand2;   
    }
    
    public nothrow inline Ir.Intf.Instruction* ICmp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.IConditionCode cond, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new ICmpInst(type, result, cond, operand1, operand2);
    }

    public nothrow const char* ConditionCodeStr(Ir.Intf.FConditionCode cond)
    {
        switch (cond)
        {
            case Ir.Intf.FConditionCode.false_: return "false";
            case Ir.Intf.FConditionCode.oeq: return "==";
            case Ir.Intf.FConditionCode.ogt: return ">";
            case Ir.Intf.FConditionCode.oge: return ">=";
            case Ir.Intf.FConditionCode.olt: return "<";
            case Ir.Intf.FConditionCode.ole: return "<=";
            case Ir.Intf.FConditionCode.one: return "!=";
            case Ir.Intf.FConditionCode.ord: return "?";
            case Ir.Intf.FConditionCode.ueq: return "==";
            case Ir.Intf.FConditionCode.ugt: return ">";
            case Ir.Intf.FConditionCode.uge: return ">=";
            case Ir.Intf.FConditionCode.ult: return "<";
            case Ir.Intf.FConditionCode.ule: return "<=";
            case Ir.Intf.FConditionCode.une: return "!=";
            case Ir.Intf.FConditionCode.uno: return "?";
            case Ir.Intf.FConditionCode.true_: return "true";
        }        
        return "";
    }
    
    public class FCmpInst : Ir.Intf.Instruction
    {
        public nothrow FCmpInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.FConditionCode cond_, Ir.Intf.Object* operand1_, Ir.Intf.Object* operand2_) : 
            base("fcmp"), type(type_), result(result_), cond(cond_), operand1(operand1_), operand2(operand2_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s(result->Name());
            s.Append(" = ").Append(operand1->Name()).Append(' ').Append(ConditionCodeStr(cond)).Append(' ').Append(operand2->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.FConditionCode cond;
        private Ir.Intf.Object* operand1;
        private Ir.Intf.Object* operand2;
    }
    
    public nothrow inline Ir.Intf.Instruction* FCmp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.FConditionCode cond, Ir.Intf.Object* operand1, Ir.Intf.Object* operand2)
    {
        return new FCmpInst(type, result, cond, operand1, operand2);
    }

    public class DoNothingInst : Ir.Intf.Instruction
    {
        public nothrow DoNothingInst() : base("_V__X_dummy = true")
        {
        }
        public nothrow override string ToString() const
        {
            return Name();
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* DoNothing()
    {
        return new DoNothingInst();
    }

    public abstract class ConversionInstruction : Ir.Intf.Instruction
    {
        public nothrow ConversionInstruction(const string& name_, Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) : 
            base(name_), type(type_), result(result_), value(value_), toType(toType_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s(result->Name());
            s.Append(" = ").Append('(').Append(toType->Name()).Append(')').Append(value->Name());
            return s;
        }
        private Ir.Intf.Type* type;
        private Ir.Intf.Object* result;
        private Ir.Intf.Object* value;
        private Ir.Intf.Type* toType;
    }
        
    public class TruncInst : ConversionInstruction
    {
        public nothrow TruncInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("trunc", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Trunc(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new TruncInst(type, result, value, toType);
    }
    
    public class ZextInst : ConversionInstruction
    {
        public nothrow ZextInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("zext", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Zext(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new ZextInst(type, result, value, toType);
    }

    public class SextInst : ConversionInstruction
    {
        public nothrow SextInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("sext", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Sext(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new SextInst(type, result, value, toType);
    }

    public class FptruncInst : ConversionInstruction
    {
        public nothrow FptruncInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("fptrunc", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Fptrunc(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new FptruncInst(type, result, value, toType);
    }

    public class FpextInst : ConversionInstruction
    {
        public nothrow FpextInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("fpext", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Fpext(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new FpextInst(type, result, value, toType);
    }

    public class FptouiInst : ConversionInstruction
    {
        public nothrow FptouiInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("fptoui", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Fptoui(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new FptouiInst(type, result, value, toType);
    }

    public class FptosiInst : ConversionInstruction
    {
        public nothrow FptosiInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("fptosi", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Fptosi(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new FptosiInst(type, result, value, toType);
    }

    public class UitofpInst : ConversionInstruction
    {
        public nothrow UitofpInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("uitofp", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Uitofp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new UitofpInst(type, result, value, toType);
    }

    public class SitofpInst : ConversionInstruction
    {
        public nothrow SitofpInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("sitofp", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Sitofp(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new SitofpInst(type, result, value, toType);
    }

    public class PtrtointInst : ConversionInstruction
    {
        public nothrow PtrtointInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("ptrtoint", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Ptrtoint(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new PtrtointInst(type, result, value, toType);
    }

    public class InttoptrInst : ConversionInstruction
    {
        public nothrow InttoptrInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("intotptr", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Intoptr(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new InttoptrInst(type, result, value, toType);
    }

    public class BitcastInst : ConversionInstruction
    {
        public nothrow BitcastInst(Ir.Intf.Type* type_, Ir.Intf.Object* result_, Ir.Intf.Object* value_, Ir.Intf.Type* toType_) :
            base("bitcast", type_, result_, value_, toType_)
        {
        }
    }
    
    public nothrow inline Ir.Intf.Instruction* Bitcast(Ir.Intf.Type* type, Ir.Intf.Object* result, Ir.Intf.Object* value, Ir.Intf.Type* toType)
    {
        return new BitcastInst(type, result, value, toType);
    }
    
    public class SizeOfInst : Ir.Intf.Instruction
    {
        public nothrow SizeOfInst(Ir.Intf.Object* result_, Ir.Intf.Type* type_) : base("sizeof"), result(result_), type(type_)
        {
        }
        public nothrow override bool ReturnsResult() const
        {
            return true;
        }
        public nothrow override Ir.Intf.Object* GetResult() const
        {
            return result;
        }
        public nothrow override string ToString() const
        {
            string s = result->Name();
            s.Append(" = ").Append(Name()).Append('(').Append(type->Name()).Append(')');
            return s;
        }
        private Ir.Intf.Object* result;
        private Ir.Intf.Type* type;
    }
    
    public nothrow inline Ir.Intf.Instruction* CreateSizeOf(Ir.Intf.Object* result, Ir.Intf.Type* type)
    {
        return new SizeOfInst(result, type);
    }

    public class MemSetInst : Ir.Intf.Instruction
    {
        public nothrow MemSetInst(Ir.Intf.Object* dest_, Ir.Intf.Object* value_, Ir.Intf.Object* len_, int align_, bool isVolatile_) 
            : base("memset"), dest(dest_), value(value_), len(len_), align(align_), isVolatile(isVolatile_)
        {
        }
        public nothrow override string ToString() const
        {
            string s("cmemset(");
            s.Append(dest->Name()).Append(", ").Append(value->Name()).Append(", ").Append(len->Name()).Append(", ").Append(ToString(align)).Append(", ").Append(ToString(isVolatile)).Append(')');
            return s;
        }
        private Ir.Intf.Object* dest;
        private Ir.Intf.Object* value;
        private Ir.Intf.Object* len;
        private int align;
        private bool isVolatile;
    }
    
    public nothrow inline Ir.Intf.Instruction* MemSet(Ir.Intf.Object* dest, Ir.Intf.Object* value, Ir.Intf.Object* len, int align, bool isVolatile)
    {
        return new MemSetInst(dest, value, len, align, isVolatile);
    }

    public class MemCopyInst : Ir.Intf.Instruction
    {
        public nothrow MemCopyInst(Ir.Intf.Object* dest_, Ir.Intf.Object* value_, Ir.Intf.Object* len_, int align_, bool isVolatile_) 
            : base("memcopy"), dest(dest_), value(value_), len(len_), align(align_), isVolatile(isVolatile_)
        {
        }
        public nothrow override string ToString() const
        {
            string s("cmemcpy(");
            s.Append(dest->Name()).Append(", ").Append(value->Name()).Append(", ").Append(len->Name()).Append(", ").Append(ToString(align)).Append(", ").Append(ToString(isVolatile)).Append(')');
            return s;
        }
        private Ir.Intf.Object* dest;
        private Ir.Intf.Object* value;
        private Ir.Intf.Object* len;
        private int align;
        private bool isVolatile;
    }
    
    public nothrow inline Ir.Intf.Instruction* MemCopy(Ir.Intf.Object* dest, Ir.Intf.Object* value, Ir.Intf.Object* len, int align, bool isVolatile)
    {
        return new MemCopyInst(dest, value, len, align, isVolatile);
    }
}
