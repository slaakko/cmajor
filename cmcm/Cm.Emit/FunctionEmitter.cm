/*========================================================================
    Copyright (c) 2012-2016 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;
using System.IO;
using CodeFormatter = System.Text.CodeFormatter;
using Span = System.Text.Parsing.Span;

namespace Cm.Emit
{
    public class LocalVariableIrObjectRepository
    {
        public nothrow LocalVariableIrObjectRepository(Cm.Core.IrFunctionRepository& irFunctionRepository_) : irFunctionRepository(irFunctionRepository_), exceptionCodeVariable(null)
        {
        }
        public Ir.Intf.Object* CreateLocalVariableIrObjectFor(Cm.Sym.Symbol* localVariableOrParameter)
        {
            Cm.IrIntf.Backend backend = Cm.IrIntf.GetBackend();
            Cm.Sym.TypeSymbol* type = null;
            if (localVariableOrParameter is Cm.Sym.LocalVariableSymbol*)
            {
                Cm.Sym.LocalVariableSymbol* localVariableSymbol = cast<Cm.Sym.LocalVariableSymbol*>(localVariableOrParameter);
                type = localVariableSymbol->GetType();
            }
            else if (localVariableOrParameter is Cm.Sym.ParameterSymbol*)
            {
                Cm.Sym.ParameterSymbol* parameterSymbol = cast<Cm.Sym.ParameterSymbol*>(localVariableOrParameter);
                type = parameterSymbol->GetType();
            }
            if (!type->IrTypeMade())
            {
                type->MakeIrType();
            }
            string assemblyName = MakeUniqueAssemblyName(localVariableOrParameter->Name());
            Ir.Intf.Object* localVariableObject = null;
            Ir.Intf.Type* baseTypeIrType = type->GetBaseType()->IrType();
            if (type->GetBaseType() is Cm.Sym.VoidTypeSymbol*)
            {
                if (backend == Cm.IrIntf.Backend.llvm)
                {
                    baseTypeIrType = Ir.Intf.Factory.Instance()->GetI8();
                }
                else if (backend == Cm.IrIntf.Backend.c)
                {
                    baseTypeIrType = Ir.Intf.Factory.Instance()->GetVoid();
                }
            }
            if (type->IsArrayType())
            {
                baseTypeIrType = Cm.IrIntf.Array(baseTypeIrType, type->GetLastArrayDimension());
            }
            if (type->IsReferenceType() || type->IsRvalueRefType())
            {
                if ((type->GetBaseType() is Cm.Sym.ClassTypeSymbol*) || (type->GetBaseType() is Cm.Sym.DelegateTypeSymbol*))
                {
                    if (backend == Cm.IrIntf.Backend.llvm)
                    {
                        localVariableObject = Cm.IrIntf.MakeStackVar(assemblyName, Cm.IrIntf.Pointer(baseTypeIrType, cast<byte>(type->GetPointerCount() + 2)));
                    }
                    else if (backend == Cm.IrIntf.Backend.c)
                    {
                        localVariableObject = Cm.IrIntf.MakeStackVar(assemblyName, Cm.IrIntf.Pointer(baseTypeIrType, cast<byte>(type->GetPointerCount() + 1)));
                    }
                }
                else 
                {
                    if (backend == Cm.IrIntf.Backend.llvm)
                    {
                        localVariableObject = Cm.IrIntf.MakeRefVar(assemblyName, Cm.IrIntf.Pointer(baseTypeIrType, cast<byte>(type->GetPointerCount() + 2)));
                    }
                    else if (backend == Cm.IrIntf.Backend.c)
                    {
                        localVariableObject = Cm.IrIntf.MakeRefVar(assemblyName, Cm.IrIntf.Pointer(baseTypeIrType, cast<byte>(type->GetPointerCount() + 1)));
                    }
                }
            }
            else 
            {
                if (type->GetBaseType() is Cm.Sym.VoidTypeSymbol*)
                {
                    if (backend == Cm.IrIntf.Backend.llvm)
                    {
                        localVariableObject = Cm.IrIntf.MakeStackVar(assemblyName, Cm.IrIntf.Pointer(baseTypeIrType, cast<byte>(type->GetPointerCount() + 1)));
                    }
                    else if (backend == Cm.IrIntf.Backend.c)
                    {
                        localVariableObject = Cm.IrIntf.MakeStackVar(assemblyName, Cm.IrIntf.Pointer(baseTypeIrType, cast<byte>(type->GetPointerCount())));
                    }
                }
                else if (type is Cm.Sym.DelegateTypeSymbol*)
                {
                    Cm.Sym.DelegateTypeSymbol* delegateType = cast<Cm.Sym.DelegateTypeSymbol*>(type);
                    Ir.Intf.Type* irPtrToDelegateType = irFunctionRepository.CreateIrPointerToDelegateType(delegateType);
                    localVariableObject = Cm.IrIntf.MakeStackVar(assemblyName, irPtrToDelegateType);
                }
                else
                {
                    if (backend == Cm.IrIntf.Backend.llvm)
                    {
                        localVariableObject = Cm.IrIntf.MakeStackVar(assemblyName, Cm.IrIntf.Pointer(baseTypeIrType, cast<byte>(type->GetPointerCount() + 1)));
                    }
                    else if (backend == Cm.IrIntf.Backend.c)
                    {
                        localVariableObject = Cm.IrIntf.MakeStackVar(assemblyName, type->IrType());
                    }                
                }
            }
            localVariableObjectMap[localVariableOrParameter->Sid()] = localVariableObject;
            ownedIrObjects.Add(UniquePtr<Ir.Intf.Object>(localVariableObject));
            return localVariableObject;
        }
        public Ir.Intf.Object* GetLocalVariableIrObject(Cm.Sym.Symbol* localVariableOrParameter)
        {
            HashMap<uint, Ir.Intf.Object*>.ConstIterator i = localVariableObjectMap.CFind(localVariableOrParameter->Sid());
            if (i != localVariableObjectMap.CEnd())
            {
                return i->second;
            }
            throw Exception("local variable '" + localVariableOrParameter->Name() + "' not found");
        }
        public string MakeUniqueAssemblyName(const string& name)
        {
            if (assemblyNames.CFind(name) == assemblyNames.CEnd())
            {
                assemblyNames.Insert(name);
                return name;
            }
            int assemblyNameCounter = 0;
            string assemblyName = name + Cm.IrIntf.GetPrivateSeparator() + ToString(assemblyNameCounter);
            while (assemblyNames.CFind(assemblyName) != assemblyNames.CEnd())
            {
                ++assemblyNameCounter;
                assemblyName = name + Cm.IrIntf.GetPrivateSeparator() + ToString(assemblyNameCounter);
            }
            assemblyNames.Insert(assemblyName);
            return assemblyName;
        }
        public void SetExceptionCodeVariable(Ir.Intf.Object* exceptionCodeVariable_)
        {
            exceptionCodeVariable = exceptionCodeVariable_;
        }
        public Ir.Intf.Object* GetExceptionCodeVariable() const
        {
            return exceptionCodeVariable;
        }
        public void GetFunctionPtrTypes(HashSet<Ir.Intf.Type*>& functionPtrTypes)
        {
            for (const Pair<uint, Ir.Intf.Object*>& p : localVariableObjectMap)
            {
                Ir.Intf.Type* type = p.second->GetType();
                type->GetFunctionPtrTypes(functionPtrTypes);
            }
        }
        public void ReplaceFunctionPtrTypes(const HashMap<Ir.Intf.Type*, Ir.Intf.Type*>& tdfMap)
        {
            for (const Pair<uint, Ir.Intf.Object*>& p : localVariableObjectMap)
            {
                Ir.Intf.Type* type = p.second->GetType();
                type->ReplaceFunctionPtrTypes(tdfMap);
            }
        }
        private Cm.Core.IrFunctionRepository& irFunctionRepository;
        private HashMap<uint, Ir.Intf.Object*> localVariableObjectMap;
        private List<UniquePtr<Ir.Intf.Object>> ownedIrObjects;
        private HashSet<string> assemblyNames;
        private Ir.Intf.Object* exceptionCodeVariable;
    }
    
    public class IrObjectRepository
    {
        public Ir.Intf.MemberVar* MakeMemberVariableIrObject(Cm.BoundTree.BoundMemberVariable* boundMemberVariable, Ir.Intf.Object* ptr)
        {
            Ir.Intf.MemberVar* memberVar = Cm.IrIntf.MakeMemberVar(boundMemberVariable->Symbol()->Name(), ptr, boundMemberVariable->Symbol()->LayoutIndex(), boundMemberVariable->Symbol()->GetType()->IrType());
            ownedIrObjects.Add(UniquePtr<Ir.Intf.Object>(memberVar));
            return memberVar;
        }
        private List<UniquePtr<Ir.Intf.Object>> ownedIrObjects;
    }
    
    public enum SwitchEmitState : byte
    {
        none, createSwitchTargets, emitStatements
    }
    
    public class CompoundDestructionStack
    {
        public void Push(Cm.BoundTree.BoundDestructionStatement* destructionStatement)
        {
            destructionStatements.Add(UniquePtr<Cm.BoundTree.BoundDestructionStatement>(destructionStatement));
        }
        public UniquePtr<Cm.BoundTree.BoundDestructionStatement> Pop()
        {
            return destructionStatements.RemoveLast();
        }
        public nothrow inline const List<UniquePtr<Cm.BoundTree.BoundDestructionStatement>>& DestructionStatements() const
        {
            return destructionStatements;
        }
        public nothrow inline bool IsEmpty() const
        {
            return destructionStatements.IsEmpty();
        }
        private List<UniquePtr<Cm.BoundTree.BoundDestructionStatement>> destructionStatements;
    }
    
    public class FunctionDestructionStack
    {
        public void Push(CompoundDestructionStack&& compoundDestructionStack)
        {
            compoundDestructionStacks.Add(Rvalue(compoundDestructionStack));
        }
        public CompoundDestructionStack Pop()
        {
            return compoundDestructionStacks.RemoveLast();
        }
        public nothrow inline const List<CompoundDestructionStack>& CompoundDestructionStacks() const
        {
            return compoundDestructionStacks;
        }
        public nothrow inline bool IsEmpty() const
        {
            return compoundDestructionStacks.IsEmpty();
        }
        private List<CompoundDestructionStack> compoundDestructionStacks;
    }
    
    public abstract class FunctionEmitter : Cm.BoundTree.Visitor
    {
        public FunctionEmitter(CodeFormatter& codeFormatter_, Cm.Sym.TypeRepository& typeRepository_, Cm.Core.IrFunctionRepository& irFunctionRepository_, 
            Cm.Core.IrClassTypeRepository& irClassTypeRepository_, Cm.Core.StringRepository& stringRepository_, Cm.BoundTree.BoundClass* currentClass_, HashSet<string>& internalFunctionNames_, 
            HashSet<Ir.Intf.Function*>& externalFunctions_, Cm.Core.StaticMemberVariableRepository& staticMemberVariableRepository_, Cm.Core.ExternalConstantRepository& externalConstantRepository_, 
            Cm.Ast.CompileUnitNode* currentCompileUnit_, Cm.Sym.FunctionSymbol* enterFrameFun_, Cm.Sym.FunctionSymbol* leaveFrameFun_, Cm.Sym.FunctionSymbol* enterTracedCallFun_, 
            Cm.Sym.FunctionSymbol* leaveTracedCallFun_, bool generateDebugInfo_, bool profile_) :
            base(true), emitter(new Cm.Core.Emitter()), codeFormatter(codeFormatter_), genFlags(Cm.Core.GenFlags.none), typeRepository(typeRepository_), irFunctionRepository(irFunctionRepository_), 
            irClassTypeRepository(irClassTypeRepository_), stringRepository(stringRepository_), localVariableIrObjectRepository(irFunctionRepository), compoundResult(), currentCompileUnit(currentCompileUnit_),
            currentClass(currentClass_), currentFunction(null), fid(cast<uint>(-1)), profile(profile_), thisParam(null), internalFunctionNames(internalFunctionNames_), externalFunctions(externalFunctions_),
            staticMemberVariableRepository(staticMemberVariableRepository_), externalConstantRepository(externalConstantRepository_), executingPostfixIncDecStatements(false), continueTargetStatement(null),
            breakTargetStatement(null), currentSwitchEmitState(SwitchEmitState.none), currentSwitchCaseConstantMap(null), switchCaseLabel(null), firstStatementInCompound(false), currentCatchId(-1), 
            enterFrameFun(enterFrameFun_), leaveFrameFun(leaveFrameFun_), enterTracedCallFun(enterTracedCallFun_), leaveTracedCallFun(leaveTracedCallFun_), generateDebugInfo(generateDebugInfo_), 
            endProfiledFunLabel(null), tpGraph(null)
        {
        }
        public override void BeginVisit(Cm.BoundTree.BoundFunction& boundFunction)
        {
            currentFunction = &boundFunction;
            Cm.IrIntf.ResetLocalLabelCounter();
            if (currentFunction->FunctionSymbol()->FullName() == "main()")
            {
                //Llvm.Breaker.Set(1);
            }
            Ir.Intf.Function* irFunction = irFunctionRepository.CreateIrFunction(currentFunction->FunctionSymbol());
            externalFunctions.Insert(irFunction);
            MapIrFunToFun(irFunction, boundFunction.FunctionSymbol());
            internalFunctionNames.Insert(irFunction->Name());
            emitter->SetIrFunction(irFunction);
            irFunction->SetComment(boundFunction.FunctionSymbol()->FullName());
            if (profile)
            {
                // emitter set profiling handler 
                // EmitStartProfiledFun
            }
            Cm.IrIntf.Backend backend = Cm.IrIntf.GetBackend();
            Ir.Intf.Object* exceptionCodeVariable = null;
            if (backend == Cm.IrIntf.Backend.llvm)
            {
                exceptionCodeVariable = Cm.IrIntf.MakeStackVar(Cm.IrIntf.GetExCodeVarName(), Cm.IrIntf.Pointer(Ir.Intf.Factory.Instance()->GetI32(), 1u));
            }
            else if (backend == Cm.IrIntf.Backend.c)
            {
                exceptionCodeVariable = Cm.IrIntf.MakeStackVar(Cm.IrIntf.GetExCodeVarName(), Ir.Intf.Factory.Instance()->GetI32());
            }
            emitter->Own(exceptionCodeVariable);
            emitter->Emit(Cm.IrIntf.Alloca(Ir.Intf.Factory.Instance()->GetI32(), exceptionCodeVariable));
            localVariableIrObjectRepository.SetExceptionCodeVariable(exceptionCodeVariable);
            EmitDummyVar(emitter.GetPtr());
            int parameterIndex = 0;
            for (Cm.Sym.ParameterSymbol* parameter : boundFunction.FunctionSymbol()->Parameters())
            {
                Ir.Intf.Object* localVariableIrObject = localVariableIrObjectRepository.CreateLocalVariableIrObjectFor(parameter);
                Cm.Sym.TypeSymbol* parameterType = parameter->GetType();
                Ir.Intf.Type* parameterIrType = parameterType->IrType();
                if (parameterType->IsPureArrayType())
                {
                    parameterIrType = parameterType->GetBaseType()->IrType();
                    emitter->Emit(Cm.IrIntf.Alloca(parameterIrType, localVariableIrObject, Ir.Intf.Factory.Instance()->GetI32(), parameterType->GetLastArrayDimension()));
                }            
                else
                {
                    emitter->Emit(Cm.IrIntf.Alloca(parameterIrType, localVariableIrObject));
                }
                if (currentFunction->FunctionSymbol()->IsMemberFunctionSymbol() && !currentFunction->FunctionSymbol()->IsStatic() && parameterIndex == 0)
                {
                    thisParam = parameter;
                }
                ++parameterIndex;
            }
            
            for (Cm.Sym.LocalVariableSymbol* localVariable : boundFunction.LocalVariables())
            {
                Ir.Intf.Object* localVariableIrObject = localVariableIrObjectRepository.CreateLocalVariableIrObjectFor(localVariable);
                Cm.Sym.TypeSymbol* localVariableType = localVariable->GetType();
                Ir.Intf.Type* localVariableIrType = localVariableType->IrType();
                if (localVariableType->IsPureArrayType())
                {
                    localVariableIrType = localVariableType->GetBaseType()->IrType();
                    localVariableIrType = ReplaceFunctionPtrType(localVariableIrType);
                    emitter->Emit(Cm.IrIntf.Alloca(localVariableIrType, localVariableIrObject, Ir.Intf.Factory.Instance()->GetI32(), localVariableType->GetLastArrayDimension()));
                    localVariableIrObject->SetType(Cm.IrIntf.Pointer(localVariableIrType, 1u));
                }
                else
                {
                    localVariableIrType = ReplaceFunctionPtrType(localVariableIrType);
                    emitter->Emit(Cm.IrIntf.Alloca(localVariableIrType, localVariableIrObject));
                }
            }
            Ir.Intf.Object* zero = Ir.Intf.Factory.Instance()->GetI32()->CreateDefaultValue();
            emitter->Own(zero);
            Cm.IrIntf.Init(*emitter, Ir.Intf.Factory.Instance()->GetI32(), zero, exceptionCodeVariable);
        }
        public override void EndVisit(Cm.BoundTree.BoundFunction& boundFunction)
        {
            if (currentFunction->FunctionSymbol()->FullName() == "main()")
            {
                //Llvm.Breaker.Set(0);
            }
            Ir.Intf.Function* irFunction = emitter->IrFunction();
            SharedPtr<Cm.Core.GenResult> result = resultStack.Pop();
            if (!irFunction->LastInstructionIsRet())
            {
                Cm.Sym.TypeSymbol* returnType = boundFunction.FunctionSymbol()->GetReturnType();
                Ir.Intf.LabelObject* retLabel = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(retLabel);
                emitter->AddNextInstructionLabel(retLabel);
                if (returnType == null || (returnType is Cm.Sym.VoidTypeSymbol*) || boundFunction.FunctionSymbol()->ReturnsClassObjectByValue())
                {
                    emitter->Emit(Cm.IrIntf.Ret());
                }
                else
                {
                    Ir.Intf.Object* retVal = returnType->IrType()->CreateDefaultValue();
                    emitter->Own(retVal);
                    emitter->Emit(Cm.IrIntf.Ret(retVal));
                }
                result->BackpatchNextTargets(retLabel);
            }
            GenerateLandingPadCode();
            irFunction->Clean();
            Cm.Sym.FunctionSymbol* functionSymbol = boundFunction.FunctionSymbol();
            bool weakOdr = functionSymbol->IsReplicated();
            bool inline_ = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.optimize) && functionSymbol->IsInline();
            irFunction->WriteDefinition(codeFormatter, weakOdr, inline_);
            currentFunction = null;
            if (functionSymbol->Parent() != null && (functionSymbol->Parent() is Cm.Sym.TemplateTypeSymbol*))
            {
                Cm.Ast.Node* node = typeRepository.GetSymbolTable().GetNode(functionSymbol, false);
                if (node != null)
                {
                    if (!(node is Cm.Ast.FunctionNode*))
                    {
                        throw Exception("function node expected");
                    }
                    Cm.Ast.FunctionNode* functionNode = cast<Cm.Ast.FunctionNode*>(node);
                    functionNode->SetBody(null);
                }
            }
        }
        public override void Visit(Cm.BoundTree.BoundLiteral& boundLiteral)
        {
            Llvm.Pusher x("BoundLiteral");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Ir.Intf.Object* literalValue = boundLiteral.Value()->CreateIrObject();
            emitter->Own(literalValue);
            result->SetMainObject(literalValue);
            if (boundLiteral.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                GenJumpingBoolCode(*result);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundStringLiteral& boundStringLiteral)
        {
            Llvm.Pusher x("BoundStringLiteral");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(boundStringLiteral.Type(), typeRepository);
            Ir.Intf.Object* stringConstant = stringRepository.GetStringConstant(boundStringLiteral.Id());
            Ir.Intf.Object* stringObject = stringRepository.GetStringObject(boundStringLiteral.Id());
            SetStringLiteralResult(emitter.GetPtr(), result->MainObject(), stringConstant, stringObject);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundConstant& boundConstant)
        {
            Llvm.Pusher x("BoundConstant");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (&boundConstant is Cm.BoundTree.BoundExceptionTableConstant*)
            {
                Ir.Intf.Object* exceptionTableConstant = externalConstantRepository.GetExceptionBaseIdTable();
                Cm.Sym.TypeSymbol* type = boundConstant.Type();
                result->SetMainObject(type, typeRepository);
                result->AddObject(exceptionTableConstant);
                Cm.IrIntf.Init(*emitter, type->IrType(), result->Arg1(), result->MainObject());
                resultStack.Push(result);
                return;
            }
            else if (&boundConstant is Cm.BoundTree.BoundClassHierarchyTableConstant*)
            {
                Ir.Intf.Object* classHierarchyTableConstant = externalConstantRepository.GetClassHierarchyTable();
                Cm.Sym.TypeSymbol* type = boundConstant.Type();
                result->SetMainObject(type, typeRepository);
                result->AddObject(classHierarchyTableConstant);
                Cm.IrIntf.Init(*emitter, type->IrType(), result->Arg1(), result->MainObject());
                resultStack.Push(result);
                return;
            }
            Ir.Intf.Object* constantValue = boundConstant.Symbol()->GetValue()->CreateIrObject();
            emitter->Own(constantValue);
            result->SetMainObject(constantValue);
            if (boundConstant.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                GenJumpingBoolCode(*result);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundEnumConstant& boundEnumConstant)
        {
            Llvm.Pusher x("BoundEnumConstant");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Ir.Intf.Object* enumConstantValue = boundEnumConstant.Symbol()->GetValue()->CreateIrObject();
            emitter->Own(enumConstantValue);
            result->SetMainObject(enumConstantValue);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundLocalVariable& boundLocalVariable)
        {
            Llvm.Pusher x("BoundLocalVariable");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (&boundLocalVariable is Cm.BoundTree.BoundExceptionCodeVariable*)
            {
                if (boundLocalVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef) || boundLocalVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.lvalue))
                {
                    result->SetMainObject(localVariableIrObjectRepository.GetExceptionCodeVariable());
                }
                else
                {
                    Cm.Sym.TypeSymbol* type = boundLocalVariable.Type();
                    result->SetMainObject(type, typeRepository);
                    result->AddObject(localVariableIrObjectRepository.GetExceptionCodeVariable());
                    Cm.IrIntf.Init(*emitter, type->IrType(), result->Arg1(), result->MainObject());
                }
                resultStack.Push(result);
                return;
            }
            Cm.Sym.TypeSymbol* type = boundLocalVariable.Symbol()->GetType();
            bool typeIsReferenceType = type->IsReferenceType() || type->IsRvalueRefType();
            bool byRefOrClassType = boundLocalVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef) || boundLocalVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.lvalue) || (type is Cm.Sym.ClassTypeSymbol*);
            if ((boundLocalVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef) || boundLocalVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.lvalue)) && typeIsReferenceType)
            {
                byRefOrClassType = false; // already reference type
            }
            if (byRefOrClassType || boundLocalVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.constructVariable))
            {
                result->SetMainObject(MakeLocalVarIrObject(type, localVariableIrObjectRepository.GetLocalVariableIrObject(boundLocalVariable.Symbol())));
            }
            else
            {
                result->SetMainObject(type, typeRepository);
                result->AddObject(localVariableIrObjectRepository.GetLocalVariableIrObject(boundLocalVariable.Symbol()));
                Cm.IrIntf.Init(*emitter, type->IrType(), result->Arg1(), result->MainObject());
                if (boundLocalVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
                {
                    GenJumpingBoolCode(*result);
                }
            }
            if (boundLocalVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.refByValue))
            {
                MakePlainValueResult(typeRepository.MakePlainType(boundLocalVariable.Type()), *result);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundParameter& boundParameter)
        {
            Llvm.Pusher x("BoundParameter");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (&boundParameter is Cm.BoundTree.BoundExceptionCodeParameter*)
            {
                result->SetMainObject(irFunctionRepository.GetExceptionCodeParam());
                resultStack.Push(result);
                return;
            }
            Cm.Sym.TypeSymbol* type = boundParameter.Symbol()->GetType();
            bool typeIsReferenceType = type->IsReferenceType() || type->IsRvalueRefType();
            bool byRef = boundParameter.GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef) || boundParameter.GetFlag(Cm.BoundTree.BoundNodeFlags.lvalue);
            if ((boundParameter.GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef) || boundParameter.GetFlag(Cm.BoundTree.BoundNodeFlags.lvalue)) && typeIsReferenceType)
            {
                byRef = false; // already reference type
            }
            if (byRef)
            {
                result->SetMainObject(localVariableIrObjectRepository.GetLocalVariableIrObject(boundParameter.Symbol()));
            }
            else
            {
                result->SetMainObject(type, typeRepository);
                result->AddObject(localVariableIrObjectRepository.GetLocalVariableIrObject(boundParameter.Symbol()));
                Cm.IrIntf.Init(*emitter, type->IrType(), result->Arg1(), result->MainObject());
                if (boundParameter.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
                {
                    GenJumpingBoolCode(*result);
                }
            }
            if (boundParameter.GetFlag(Cm.BoundTree.BoundNodeFlags.refByValue))
            {
                MakePlainValueResult(typeRepository.MakePlainType(boundParameter.Type()), *result);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundMemberVariable& boundMemberVariable)
        {
            Llvm.Pusher x("BoundMemberVariable");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (boundMemberVariable.Symbol()->IsStatic())
            {
                Ir.Intf.Object* irObject = staticMemberVariableRepository.GetStaticMemberVariableIrObject(boundMemberVariable.Symbol());
                Cm.Sym.TypeSymbol* memberVariableType = boundMemberVariable.Symbol()->GetType();
                if (boundMemberVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.lvalue) || boundMemberVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef) || (memberVariableType is Cm.Sym.ClassTypeSymbol*))
                {
                    result->SetMainObject(irObject);
                }
                else
                {
                    result->SetMainObject(memberVariableType, typeRepository);
                    result->AddObject(irObject);
                    Cm.IrIntf.Init(*emitter, memberVariableType->IrType(), result->Arg1(), result->MainObject());
                }
            }
            else
            {
                Cm.BoundTree.BoundExpression* classObject = boundMemberVariable.ClassObject();
                if (classObject != null)
                {
                    classObject->Accept(*this);
                }
                else
                {
                    if (currentClass != null)
                    {
                        Cm.Sym.ClassTypeSymbol* classType = currentClass->Symbol();
                        UniquePtr<Cm.BoundTree.BoundParameter> boundParameter(new Cm.BoundTree.BoundParameter(null, thisParam));
                        boundParameter->Accept(*this);
                    }
                    else
                    {
                        throw Cm.Core.Error("cannot use member variables in non-class context", boundMemberVariable.Symbol()->GetSpan());
                    }
                }
                SharedPtr<Cm.Core.GenResult> ptrResult = resultStack.Pop();
                Cm.Sym.TypeSymbol* type = boundMemberVariable.Symbol()->GetType();
                Ir.Intf.MemberVar* memberVariableIrObject = irObjectRepository.MakeMemberVariableIrObject(&boundMemberVariable, ptrResult->MainObject());
                if (!ptrResult->MainObject()->GetType()->IsPointerType())
                {
                    memberVariableIrObject->SetDotMember();
                }
                if (boundMemberVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.lvalue) || boundMemberVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef))
                {
                    result->SetMainObject(memberVariableIrObject->CreateAddr(*emitter, type->IrType()));
                }
                else
                {
                    result->SetMainObject(type, typeRepository);
                    result->AddObject(memberVariableIrObject);
                    Cm.IrIntf.Init(*emitter, type->IrType(), result->Arg1(), result->MainObject());
                }
                result->Merge(ptrResult);
            }
            if (boundMemberVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.refByValue))
            {
                MakePlainValueResult(typeRepository.MakePlainType(boundMemberVariable.Type()), *result);
            }
            if (boundMemberVariable.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                GenJumpingBoolCode(*result);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundFunctionId& boundFunctionId)
        {
            Llvm.Pusher x("BoundFunctionId");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(irFunctionRepository.GetFunctionId(boundFunctionId.Symbol(), boundFunctionId.Type()));
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundConversion& boundConversion)
        {
            Llvm.Pusher x("BoundConversion");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Ir.Intf.Object* temporary = null;
            Cm.Sym.FunctionSymbol* conversionFun = boundConversion.ConversionFun();
            Ir.Intf.LabelObject* resultLabel = null;
            if (conversionFun->IsConversionFunction())
            {
                result->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
                boundConversion.Operand()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> operandResult = resultStack.Pop();
                if (boundConversion.Operand()->GetFlag(Cm.BoundTree.BoundNodeFlags.addrArg))
                {
                    result->SetAddrArg();
                }
                resultLabel = operandResult->GetLabel();
                result->Merge(operandResult);
            }
            Cm.BoundTree.BoundExpression* boundTemporary = boundConversion.BoundTemporary();
            if (boundTemporary != null)
            {
                Cm.Sym.TypeSymbol* temporaryType = boundTemporary->Type();
                boundTemporary->Accept(*this);
                SharedPtr<Cm.Core.GenResult> temporaryResult = resultStack.Pop();
                if (resultLabel == null)
                {
                    resultLabel = temporaryResult->GetLabel();
                }
                temporary = temporaryResult->MainObject();
                result->Merge(temporaryResult);
                if (temporaryType is Cm.Sym.ClassTypeSymbol*)
                {
                    Cm.Sym.ClassTypeSymbol* temporaryClassType = cast<Cm.Sym.ClassTypeSymbol*>(temporaryType);
                    if (temporaryClassType->Destructor() != null)
                    {
                        currentCompoundDestructionStack.Push(new Cm.BoundTree.BoundDestructionStatement(null, temporary, temporaryClassType->Destructor()));
                    }
                }
            }
            else
            {
                result->SetMainObject(boundConversion.Type(), typeRepository);
            }
            if (boundConversion.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                result->SetGenJumpingBoolCode();
            }
            if (!conversionFun->IsConversionFunction())
            {
                boundConversion.Operand()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> operandResult = resultStack.Pop();
                if (boundConversion.Operand()->GetFlag(Cm.BoundTree.BoundNodeFlags.addrArg))
                {
                    result->SetAddrArg();
                }
                if (boundConversion.Operand()->GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef))
                {
                    result->SetArgByRef();
                }
                if (resultLabel == null)
                {
                    resultLabel = operandResult->GetLabel();
                }
                result->Merge(operandResult);
            }
            if ((boundConversion.Operand()->Type() is Cm.Sym.ClassTypeSymbol*) && (boundConversion.Type()->IsPointerType() || boundConversion.Type()->IsReferenceType() || boundConversion.Type()->IsRvalueRefType()))
            {
                result->SetClassTypeToPointerTypeConversion();
            }
            GenerateCall(conversionFun, null, *result);
            if (boundConversion.GetFlag(Cm.BoundTree.BoundNodeFlags.refByValue))
            {
                MakePlainValueResult(typeRepository.MakePlainType(boundConversion.Type()), *result);
            }
            if (temporary != null)
            {
                result->SetMainObject(temporary);
            }
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundCast& boundCast)
        {
            Llvm.Pusher x("BoundCast");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(boundCast.Type(), typeRepository);
            if (boundCast.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                result->SetGenJumpingBoolCode();
            }
            boundCast.Operand()->Accept(*this);
            SharedPtr<Cm.Core.GenResult> operandResult = resultStack.Pop();
            Ir.Intf.LabelObject* resultLabel = operandResult->GetLabel();
            result->Merge(operandResult);
            Cm.Sym.FunctionSymbol* conversionFun = boundCast.ConversionFun();
            GenerateCall(conversionFun, null, *result);
            if (boundCast.GetFlag(Cm.BoundTree.BoundNodeFlags.refByValue))
            {
                MakePlainValueResult(typeRepository.MakePlainType(boundCast.Type()), *result);
            }
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundSizeOfExpression& boundSizeOfExpr)
        {
            Llvm.Pusher x("BoundSizeOfExpression");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(Cm.IrIntf.SizeOf(*emitter, boundSizeOfExpr.Type()->IrType()));
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundUnaryOp& boundUnaryOp)
        {
            Llvm.Pusher x("BoundUnaryOp");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Cm.Sym.FunctionSymbol* op = boundUnaryOp.Fun();
            bool functionReturnsClassObjectByValue = op->ReturnsClassObjectByValue() && !(op is Cm.Core.BasicTypeOp*);
            if (functionReturnsClassObjectByValue)
            {
                result->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
            }
            else
            {
                result->SetMainObject(op->GetReturnType(), typeRepository);
            }
            SharedPtr<Cm.Core.GenResult> operandResult = resultStack.Pop();
            if (boundUnaryOp.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                result->SetGenJumpingBoolCode();
            }
            if (boundUnaryOp.GetFlag(Cm.BoundTree.BoundNodeFlags.lvalue) || boundUnaryOp.GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef))
            {
                result->SetLvalue();
            }
            Ir.Intf.LabelObject* resultLabel = operandResult->GetLabel();
            result->Merge(operandResult);
            Ir.Intf.Object* classObjectResultValue = null;
            if (functionReturnsClassObjectByValue)
            {
                Cm.BoundTree.BoundLocalVariable classObjectResultVar(boundUnaryOp.SyntaxNode(), boundUnaryOp.ClassObjectResultVar());
                classObjectResultVar.SetType(classObjectResultVar.Symbol()->GetType());
                classObjectResultVar.Accept(*this);
                SharedPtr<Cm.Core.GenResult> argResult = resultStack.Pop();
                if (resultLabel == null)
                {
                    resultLabel = argResult->GetLabel();
                }
                classObjectResultValue = argResult->MainObject();
                result->Merge(argResult);
            }
            GenerateCall(op, boundUnaryOp.GetTraceCallInfo(), *result);
            if (boundUnaryOp.GetFlag(Cm.BoundTree.BoundNodeFlags.refByValue))
            {
                MakePlainValueResult(typeRepository.MakePlainType(boundUnaryOp.Type()), *result);
            }
            if (functionReturnsClassObjectByValue)
            {
                result->SetMainObject(classObjectResultValue);
            }
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundBinaryOp& boundBinaryOp)
        {
            Llvm.Pusher x("BoundBinaryOp");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            SharedPtr<Cm.Core.GenResult> right = resultStack.Pop();
            SharedPtr<Cm.Core.GenResult> left = resultStack.Pop();
            bool functionReturnsClassObjectByValue = boundBinaryOp.Fun()->ReturnsClassObjectByValue();
            if (functionReturnsClassObjectByValue)
            {
                result->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
            }
            else
            {
                result->SetMainObject(boundBinaryOp.Type(), typeRepository);
            }
            if (boundBinaryOp.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                result->SetGenJumpingBoolCode();
            }
            Ir.Intf.LabelObject* resultLabel = left->GetLabel();
            if (resultLabel == null)
            {
                resultLabel = right->GetLabel();
            }
            result->Merge(left);
            result->Merge(right);
            Ir.Intf.Object* classObjectResultValue = null;
            if (functionReturnsClassObjectByValue)
            {
                Cm.BoundTree.BoundLocalVariable classObjectResultVar(boundBinaryOp.SyntaxNode(), boundBinaryOp.ClassObjectResultVar());
                classObjectResultVar.SetType(classObjectResultVar.Symbol()->GetType());
                classObjectResultVar.Accept(*this);
                SharedPtr<Cm.Core.GenResult> argResult = resultStack.Pop();
                if (resultLabel == null)
                {
                    resultLabel = argResult->GetLabel();
                }
                classObjectResultValue = argResult->MainObject();
                result->Merge(argResult);
            }
            Cm.Sym.FunctionSymbol* op = boundBinaryOp.Fun();
            GenerateCall(op, boundBinaryOp.GetTraceCallInfo(), *result);
            if (boundBinaryOp.GetFlag(Cm.BoundTree.BoundNodeFlags.refByValue))
            {
                MakePlainValueResult(typeRepository.MakePlainType(boundBinaryOp.Type()), *result);
            }
            if (functionReturnsClassObjectByValue)
            {
                result->SetMainObject(classObjectResultValue);
            }
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundFunctionCall& boundFunctionCall)
        {
            Llvm.Pusher x("BoundFunctionCall");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            bool functionReturnsClassObjectByValue = boundFunctionCall.Fun()->ReturnsClassObjectByValue();
            if (functionReturnsClassObjectByValue)
            {
                result->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
            }
            else if (!(boundFunctionCall.Fun() is Cm.Core.BasicTypeOp*) && !(boundFunctionCall.Fun()->IsConstructorOrDestructorSymbol()))
            {
                result->SetMainObject(boundFunctionCall.Type(), typeRepository);
            }
            if (boundFunctionCall.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                result->SetGenJumpingBoolCode();
            }
            Ir.Intf.LabelObject* resultLabel = null;
            for (UniquePtr<Cm.BoundTree.BoundExpression>& argument : boundFunctionCall.Arguments())
            {
                argument->Accept(*this);
                SharedPtr<Cm.Core.GenResult> argResult = resultStack.Pop();
                if (resultLabel == null)
                {
                    resultLabel = argResult->GetLabel();
                }
                result->Merge(argResult);
            }
            Ir.Intf.Object* classObjectResultValue = null;
            if (functionReturnsClassObjectByValue)
            {
                Cm.BoundTree.BoundLocalVariable classObjectResultVar(boundFunctionCall.SyntaxNode(), boundFunctionCall.ClassObjectResultVar());
                classObjectResultVar.SetType(classObjectResultVar.Symbol()->GetType());
                classObjectResultVar.Accept(*this);
                SharedPtr<Cm.Core.GenResult> argResult = resultStack.Pop();
                if (resultLabel == null)
                {
                    resultLabel = argResult->GetLabel();
                }
                classObjectResultValue = argResult->MainObject();
                result->Merge(argResult);
            }
            Cm.Sym.FunctionSymbol* fun = boundFunctionCall.Fun();
            bool generateVirtualCall = boundFunctionCall.GetFlag(Cm.BoundTree.BoundNodeFlags.genVirtualCall);
            if (Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.fullConfig) && generateVirtualCall && tpGraph != null)
            {
                // todo
            }
            if (generateVirtualCall)
            {
                result->SetGenerateVirtualCall();
            }
            GenerateCall(fun, boundFunctionCall.GetTraceCallInfo(), *result);
            if (boundFunctionCall.GetFlag(Cm.BoundTree.BoundNodeFlags.refByValue))
            {
                MakePlainValueResult(typeRepository.MakePlainType(boundFunctionCall.Type()), *result);
            }
            if (functionReturnsClassObjectByValue)
            {
                result->SetMainObject(classObjectResultValue);
            }
            else if (boundFunctionCall.Temporary() != null)
            {
                if (boundFunctionCall.GetFlag(Cm.BoundTree.BoundNodeFlags.argByRef))
                {
                    boundFunctionCall.Temporary()->SetFlag(Cm.BoundTree.BoundNodeFlags.argByRef);
                }
                boundFunctionCall.Temporary()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> temporaryResult = resultStack.Pop();
                result->SetMainObject(temporaryResult->MainObject());
            }
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundDelegateCall& boundDelegateCall)
        {
            Llvm.Pusher x("BoundDelegateCall");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(boundDelegateCall.Type(), typeRepository);
            boundDelegateCall.Subject()->Accept(*this);
            Ir.Intf.LabelObject* resultLabel = null;
            SharedPtr<Cm.Core.GenResult> subjectResult = resultStack.Pop();
            resultLabel = subjectResult->GetLabel();
            Ir.Intf.Object* funPtr = subjectResult->MainObject();
            for (const UniquePtr<Cm.BoundTree.BoundExpression>& argument : boundDelegateCall.Arguments())
            {
                argument->Accept(*this);
                SharedPtr<Cm.Core.GenResult> argumentResult = resultStack.Pop();
                if (resultLabel == null)
                {
                    resultLabel = argumentResult->GetLabel();
                }
                result->Merge(argumentResult);
            }
            if (!boundDelegateCall.DelegateType()->IsNothrow())
            {
                result->AddObject(localVariableIrObjectRepository.GetExceptionCodeVariable());
            }
            emitter->Emit(Cm.IrIntf.IndirectCall(result->MainObject(), funPtr, result->Args()));
            if (!boundDelegateCall.DelegateType()->IsNothrow())
            {
                GenerateTestExceptionResult();
            }
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            result->Merge(subjectResult);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundClassDelegateCall& boundClassDelegateCall)
        {
            Llvm.Pusher x("BoundClassDelegateCall");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(boundClassDelegateCall.Type(), typeRepository);
            boundClassDelegateCall.Subject()->Accept(*this);
            SharedPtr<Cm.Core.GenResult> subjectResult = resultStack.Pop();
            Cm.Sym.Symbol* objSymbol = boundClassDelegateCall.ClassDelegateType()->GetContainerScope()->Lookup("obj");
            if (!(objSymbol is Cm.Sym.MemberVariableSymbol*))
            {
                throw Exception("member variable symbol expected");
            }
            Cm.Sym.MemberVariableSymbol* objMemberVarSymbol = cast<Cm.Sym.MemberVariableSymbol*>(objSymbol);
            UniquePtr<Cm.BoundTree.BoundMemberVariable> objMemberVar(new Cm.BoundTree.BoundMemberVariable(null, objMemberVarSymbol));
            Ir.Intf.Object* obj = irObjectRepository.MakeMemberVariableIrObject(objMemberVar.GetPtr(), subjectResult->MainObject());
            Ir.Intf.RegVar* thisPtr = Cm.IrIntf.MakeTemporaryRegVar(obj->GetType()->Clone());
            emitter->Own(thisPtr);
            Cm.IrIntf.Assign(*emitter, obj->GetType(), obj, thisPtr);
            result->AddObject(thisPtr);
            for (const UniquePtr<Cm.BoundTree.BoundExpression>& argument : boundClassDelegateCall.Arguments())
            {
                argument->Accept(*this);
                SharedPtr<Cm.Core.GenResult> argumentResult = resultStack.Pop();
                result->Merge(argumentResult);
            }
            if (!boundClassDelegateCall.ClassDelegateType()->IsNothrow())
            {
                result->AddObject(localVariableIrObjectRepository.GetExceptionCodeVariable());
            }
            Cm.Sym.Symbol* dlgSymbol = boundClassDelegateCall.ClassDelegateType()->GetContainerScope()->Lookup("dlg");
            if (!(dlgSymbol is Cm.Sym.MemberVariableSymbol*))
            {
                throw Exception("member variable symbol expected");
            }
            Cm.Sym.MemberVariableSymbol* dlgMemberVarSymbol = cast<Cm.Sym.MemberVariableSymbol*>(dlgSymbol);
            UniquePtr<Cm.BoundTree.BoundMemberVariable> dlgMemberVar(new Cm.BoundTree.BoundMemberVariable(null, dlgMemberVarSymbol));
            Ir.Intf.Object* dlg = irObjectRepository.MakeMemberVariableIrObject(dlgMemberVar.GetPtr(), subjectResult->MainObject());
            Ir.Intf.RegVar* funPtr = Cm.IrIntf.MakeTemporaryRegVar(dlg->GetType());
            emitter->Own(funPtr);
            Cm.IrIntf.Assign(*emitter, dlg->GetType(), dlg, funPtr);
            emitter->Emit(Cm.IrIntf.IndirectCall(result->MainObject(), funPtr, result->Args()));
            result->Merge(subjectResult);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundDisjunction& boundDisjunction)
        {
            Llvm.Pusher x("BoundDisjunction");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Ir.Intf.LabelObject* next = null;
            if (boundDisjunction.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                boundDisjunction.Left()->SetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode);
                boundDisjunction.Left()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> leftResult = resultStack.Pop();
                if (!result->LabelSet())
                {
                    result->SetLabelSet();
                    result->SetLabel(leftResult->GetLabel());
                }
                functionDestructionStack.Push(Rvalue(currentCompoundDestructionStack));
                currentCompoundDestructionStack = CompoundDestructionStack();
                boundDisjunction.Right()->SetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode);
                boundDisjunction.Right()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> rightResult = resultStack.Pop();
                leftResult->BackpatchFalseTargets(rightResult->GetLabel());
                if (currentCompoundDestructionStack.IsEmpty())
                {
                    result->MergeTargets(result->FalseTargets(), rightResult->FalseTargets());
                    result->MergeTargets(result->TrueTargets(), leftResult->TrueTargets());
                    result->MergeTargets(result->TrueTargets(), rightResult->TrueTargets());
                }
                else
                {
                    bool trueFirst = true;
                    SharedPtr<Cm.Core.GenResult> trueResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                    ExitCompound(*trueResult, currentCompoundDestructionStack, trueFirst);
                    rightResult->BackpatchTrueTargets(trueResult->GetLabel());
                    Ir.Intf.LabelObject* trueLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(trueLabel);
                    emitter->Emit(Cm.IrIntf.Br(trueLabel));
                    result->AddTrueTarget(trueLabel);
                    
                    bool falseFirst = true;
                    SharedPtr<Cm.Core.GenResult> falseResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                    ExitCompound(*falseResult, currentCompoundDestructionStack, falseFirst);
                    rightResult->BackpatchFalseTargets(falseResult->GetLabel());
                    Ir.Intf.LabelObject* falseLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(falseLabel);
                    emitter->Emit(Cm.IrIntf.Br(falseLabel));
                    result->AddFalseTarget(falseLabel);
                    result->MergeTargets(result->TrueTargets(), leftResult->TrueTargets());
                    result->Merge(trueResult);
                    result->Merge(falseResult);
                }
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                result->Merge(leftResult);
                result->Merge(rightResult);
            }
            else
            {
                boundDisjunction.Left()->SetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode);
                boundDisjunction.Left()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> leftResult = resultStack.Pop();
                if (!result->LabelSet())
                {
                    result->SetLabelSet();
                    result->SetLabel(leftResult->GetLabel());
                }
                functionDestructionStack.Push(Rvalue(currentCompoundDestructionStack));
                currentCompoundDestructionStack = CompoundDestructionStack();
                boundDisjunction.Right()->SetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode);
                boundDisjunction.Right()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> rightResult = resultStack.Pop();
                leftResult->BackpatchFalseTargets(rightResult->GetLabel());
                result->SetMainObject(localVariableIrObjectRepository.GetLocalVariableIrObject(boundDisjunction.ResultVar()));
                if (currentCompoundDestructionStack.IsEmpty())
                {
                    Ir.Intf.LabelObject* falseLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(falseLabel);
                    emitter->AddNextInstructionLabel(falseLabel);
                    Ir.Intf.Object* false_ = Cm.IrIntf.False();
                    emitter->Own(false_);
                    Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI1(), false_, result->MainObject());
                    rightResult->BackpatchFalseTargets(falseLabel);
                    next = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(next);
                    emitter->Emit(Cm.IrIntf.Br(next));
                    Ir.Intf.LabelObject* trueLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(trueLabel);
                    emitter->AddNextInstructionLabel(trueLabel);
                    Ir.Intf.Object* true_ = Cm.IrIntf.True();
                    emitter->Own(true_);
                    Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI1(), true_, result->MainObject());
                    leftResult->BackpatchTrueTargets(trueLabel);
                    rightResult->BackpatchTrueTargets(trueLabel);
                }
                else
                {
                    bool falseFirst = true;
                    SharedPtr<Cm.Core.GenResult> falseResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                    ExitCompound(*falseResult, currentCompoundDestructionStack, falseFirst);
                    rightResult->BackpatchFalseTargets(falseResult->GetLabel());
                    Ir.Intf.Object* false_ = Cm.IrIntf.False();
                    emitter->Own(false_);
                    Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI1(), false_, result->MainObject());
                    next = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(next);
                    emitter->Emit(Cm.IrIntf.Br(next));
                    bool trueFirst = true;
                    SharedPtr<Cm.Core.GenResult> trueResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                    ExitCompound(*trueResult, currentCompoundDestructionStack, trueFirst);
                    rightResult->BackpatchTrueTargets(trueResult->GetLabel());
                    Ir.Intf.LabelObject* assignTrueLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(assignTrueLabel);
                    emitter->AddNextInstructionLabel(assignTrueLabel);
                    Ir.Intf.Object* true_ = Cm.IrIntf.True();
                    emitter->Own(true_);
                    Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI1(), true_, result->MainObject());
                    leftResult->BackpatchTrueTargets(assignTrueLabel);
                    result->Merge(falseResult);
                    result->Merge(trueResult);
                }
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                result->Merge(leftResult);
                result->Merge(rightResult);
            }
            resultStack.Push(result);
            if (next != null)
            {
                emitter->AddNextInstructionLabel(next);
            }
        }
        public override void Visit(Cm.BoundTree.BoundConjunction& boundConjunction)
        {
            Llvm.Pusher x("BoundConjunction");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Ir.Intf.LabelObject* next = null;
            if (boundConjunction.GetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode))
            {
                boundConjunction.Left()->SetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode);
                boundConjunction.Left()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> leftResult = resultStack.Pop();
                if (!result->LabelSet())
                {
                    result->SetLabelSet();
                    result->SetLabel(leftResult->GetLabel());
                }
                functionDestructionStack.Push(Rvalue(currentCompoundDestructionStack));
                currentCompoundDestructionStack = CompoundDestructionStack();
                boundConjunction.Right()->SetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode);
                boundConjunction.Right()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> rightResult = resultStack.Pop();
                leftResult->BackpatchTrueTargets(rightResult->GetLabel());
                if (currentCompoundDestructionStack.IsEmpty())
                {
                    result->MergeTargets(result->TrueTargets(), rightResult->TrueTargets());
                    result->MergeTargets(result->FalseTargets(), leftResult->FalseTargets());
                    result->MergeTargets(result->FalseTargets(), rightResult->FalseTargets());
                }
                else
                {
                    bool trueFirst = true;
                    SharedPtr<Cm.Core.GenResult> trueResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                    ExitCompound(*trueResult, currentCompoundDestructionStack, trueFirst);
                    rightResult->BackpatchTrueTargets(trueResult->GetLabel());
                    Ir.Intf.LabelObject* trueLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(trueLabel);
                    emitter->Emit(Cm.IrIntf.Br(trueLabel));
                    result->AddTrueTarget(trueLabel);
                    bool falseFirst = true;
                    SharedPtr<Cm.Core.GenResult> falseResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                    ExitCompound(*falseResult, currentCompoundDestructionStack, falseFirst);
                    rightResult->BackpatchFalseTargets(falseResult->GetLabel());
                    Ir.Intf.LabelObject* falseLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(falseLabel);
                    emitter->Emit(Cm.IrIntf.Br(falseLabel));
                    result->AddFalseTarget(falseLabel);
                    result->MergeTargets(result->FalseTargets(), leftResult->FalseTargets());
                    result->Merge(trueResult);
                    result->Merge(falseResult);
                }
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                result->Merge(leftResult);
                result->Merge(rightResult);
            }
            else
            {
                boundConjunction.Left()->SetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode);
                boundConjunction.Left()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> leftResult = resultStack.Pop();
                if (!result->LabelSet())
                {
                    result->SetLabelSet();
                    result->SetLabel(leftResult->GetLabel());
                }
                functionDestructionStack.Push(Rvalue(currentCompoundDestructionStack));
                currentCompoundDestructionStack = CompoundDestructionStack();
                boundConjunction.Right()->SetFlag(Cm.BoundTree.BoundNodeFlags.genJumpingBoolCode);
                boundConjunction.Right()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> rightResult = resultStack.Pop();
                leftResult->BackpatchTrueTargets(rightResult->GetLabel());
                result->SetMainObject(localVariableIrObjectRepository.GetLocalVariableIrObject(boundConjunction.ResultVar()));
                if (currentCompoundDestructionStack.IsEmpty())
                {
                    Ir.Intf.LabelObject* trueLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(trueLabel);
                    emitter->AddNextInstructionLabel(trueLabel);
                    Ir.Intf.Object* true_ = Cm.IrIntf.True();
                    emitter->Own(true_);
                    Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI1(), true_, result->MainObject());
                    rightResult->BackpatchTrueTargets(trueLabel);
                    next = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(next);
                    emitter->Emit(Cm.IrIntf.Br(next));
                    Ir.Intf.LabelObject* falseLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(falseLabel);
                    emitter->AddNextInstructionLabel(falseLabel);
                    Ir.Intf.Object* false_ = Cm.IrIntf.False();
                    emitter->Own(false_);
                    Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI1(), false_, result->MainObject());
                    leftResult->BackpatchFalseTargets(falseLabel);
                    rightResult->BackpatchFalseTargets(falseLabel);
                }
                else
                {
                    bool trueFirst = true;
                    SharedPtr<Cm.Core.GenResult> trueResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                    ExitCompound(*trueResult, currentCompoundDestructionStack, trueFirst);
                    rightResult->BackpatchTrueTargets(trueResult->GetLabel());
                    next = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(next);
                    Ir.Intf.Object* true_ = Cm.IrIntf.True();
                    emitter->Own(true_);
                    Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI1(), true_, result->MainObject());
                    emitter->Emit(Cm.IrIntf.Br(next));
                    bool falseFirst = true;
                    SharedPtr<Cm.Core.GenResult> falseResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                    ExitCompound(*falseResult, currentCompoundDestructionStack, falseFirst);
                    rightResult->BackpatchFalseTargets(falseResult->GetLabel());
                    Ir.Intf.LabelObject* assignFalseLabel = Cm.IrIntf.CreateNextLocalLabel();
                    emitter->Own(assignFalseLabel);
                    emitter->AddNextInstructionLabel(assignFalseLabel);
                    Ir.Intf.Object* false_ = Cm.IrIntf.False();
                    emitter->Own(false_);
                    Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI1(), false_, result->MainObject());
                    leftResult->BackpatchFalseTargets(assignFalseLabel);
                    result->Merge(trueResult);
                    result->Merge(falseResult);
                }
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                result->Merge(leftResult);
                result->Merge(rightResult);
            }
            resultStack.Push(result);
            if (next != null)
            {
                emitter->AddNextInstructionLabel(next);
            }
        }
        public override void Visit(Cm.BoundTree.BoundPostfixIncDecExpr& boundPostfixIncDecExpr)
        {
            Llvm.Pusher x("BoundPostfixIncDecExpr");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            boundPostfixIncDecExpr.Value()->Accept(*this);
            SharedPtr<Cm.Core.GenResult> valueResult = resultStack.Pop();
            Ir.Intf.LabelObject* resultLabel = valueResult->GetLabel();
            result->Merge(valueResult);
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            resultStack.Push(result);
            postfixIncDecStatements.Add(UniquePtr<Cm.BoundTree.BoundStatement>(boundPostfixIncDecExpr.ReleaseStatement()));
        }
        public override void BeginVisitStatement(Cm.BoundTree.BoundStatement& statement)
        {
            genFlags = Cm.Core.GenFlags.none;
            nextTargetsStack.Push(compoundResult->NextTargets());
            compoundResult->NextTargets().Clear();
            if (!statement.Label().IsEmpty())
            {
                Ir.Intf.LabelObject* label = Cm.IrIntf.CreateLabel(statement.Label());
                emitter->Own(label);
                emitter->SetGotoTargetLabel(label);
            }
        }
        public override void EndVisitStatement(Cm.BoundTree.BoundStatement& statement)
        {
            SharedPtr<Cm.Core.GenResult> statementResult = resultStack.Pop();
            BackpatchNextTargets(statementResult->GetLabel());
            if (statementResult->GetLabel() != null)
            {
                compoundResult->BackpatchNextTargets(statementResult->GetLabel());
            }
            compoundResult->Merge(statementResult);
            if (!compoundResult->LabelSet())
            {
                if (statementResult->GetLabel() != null)
                {
                    compoundResult->SetLabel(statementResult->GetLabel());
                    compoundResult->SetLabelSet();
                }
            }
        }
        public override void BeginVisit(Cm.BoundTree.BoundCompoundStatement& boundCompoundStatement)
        {
            Llvm.Pusher x("BeginBoundCompoundStatement");
            if (boundCompoundStatement.Parent() == null)
            {
                bool gen = generateDebugInfo && boundCompoundStatement.SyntaxNode() != null;
                PushGenDebugInfo(gen);
            }
            SharedPtr<Cm.Core.GenResult> entryResult;
            if (generateDebugInfo)
            {
                if (boundCompoundStatement.SyntaxNode() == null)
                {
                    throw Exception("block body has no syntax node");
                }
                Cm.Ast.CompoundStatementNode* compoundStatementNode = cast<Cm.Ast.CompoundStatementNode*>(boundCompoundStatement.SyntaxNode());
                CreateEntryDebugNode(boundCompoundStatement, compoundStatementNode->BeginBraceSpan());
                entryResult = resultStack.Pop();
            }
            compoundResultStack.Push(compoundResult);
            compoundResult = SharedPtr<Cm.Core.GenResult>(new Cm.Core.GenResult(emitter.GetPtr(), Cm.Core.GenFlags.none));
            if (!entryResult.IsNull())
            {
                compoundResult->Merge(entryResult);
                compoundResult->SetLabel(entryResult->GetLabel());
                compoundResult->SetLabelSet();
            }
            if (boundCompoundStatement.IsEmpty())
            {
                compoundResult->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
                DoNothing(*compoundResult);
            }
            functionDestructionStack.Push(Rvalue(currentCompoundDestructionStack));
            currentCompoundDestructionStack = CompoundDestructionStack();
        }
        public override void EndVisit(Cm.BoundTree.BoundCompoundStatement& boundCompoundStatement)
        {
            Llvm.Pusher x("EndBoundCompoundStatement");
            ClearCompoundDestructionStack(*compoundResult);
            if (generateDebugInfo)
            {
                if (boundCompoundStatement.SyntaxNode() == null)
                {
                    throw Exception("block body has no syntax node");
                }
                Cm.Ast.CompoundStatementNode* compoundStatementNode = cast<Cm.Ast.CompoundStatementNode*>(boundCompoundStatement.SyntaxNode());
                CreateExitDebugNode(boundCompoundStatement, compoundStatementNode->EndBraceSpan());
                SharedPtr<Cm.Core.GenResult> exitResult = resultStack.Pop();
                compoundResult->Merge(exitResult);
            }
            if (boundCompoundStatement.Parent() == null)
            {
                PopGenDebugInfo();
            }
            currentCompoundDestructionStack = functionDestructionStack.Pop();
            resultStack.Push(compoundResult);
            compoundResult = compoundResultStack.Pop();
        }
        public override void Visit(Cm.BoundTree.BoundReceiveStatement& boundReceiveStatement)
        {
            Llvm.Pusher x("BoundReceiveStatement");
            Cm.Sym.ParameterSymbol* parameterSymbol = boundReceiveStatement.ParameterSymbol();
            if (generateDebugInfo)
            {
                Span span(0, 0, 0, 0);
                if (boundReceiveStatement.SyntaxNode() != null)
                {
                    span = boundReceiveStatement.SyntaxNode()->GetSpan();
                }
                Cm.Core.CfgNode* node = CreateDebugNode(boundReceiveStatement, span, true);
                if (node == null)
                {
                    throw Exception("node expected");
                }
                int defNode = node->Id();
                string irName;
                Ir.Intf.Object* irObject = localVariableIrObjectRepository.GetLocalVariableIrObject(parameterSymbol);
                if (irObject != null)
                {
                    irName = irObject->Name();
                }
                else
                {
                    throw Exception("irObject expected");
                }
                string typeName = parameterSymbol->GetType()->FullName();
                Cm.Core.CFunctionDebugInfo* functionDebugInfo = GetFunctionDebugInfo();
                if (functionDebugInfo != null)
                {
                    functionDebugInfo->Locals().AddLocal(new Cm.Core.Local(parameterSymbol->Name(), irName, typeName, defNode));
                }
                else
                {
                    throw Exception("function debug info expected");
                }
            }
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(localVariableIrObjectRepository.GetLocalVariableIrObject(parameterSymbol));
            Ir.Intf.Parameter* irParameter = irFunctionRepository.CreateIrParameter(parameterSymbol);
            emitter->Own(irParameter);
            result->AddObject(irParameter);
            Cm.Sym.FunctionSymbol* ctor = boundReceiveStatement.Constructor();
            GenerateCall(ctor, null, *result);
            if ((parameterSymbol->GetType() is Cm.Sym.ClassTypeSymbol*) && !(parameterSymbol->GetType() is Cm.Sym.ClassDelegateTypeSymbol*))
            {
                Cm.Sym.ClassTypeSymbol* parameterClassType = cast<Cm.Sym.ClassTypeSymbol*>(parameterSymbol->GetType());
                if (parameterClassType->Destructor() != null)
                {
                    currentCompoundDestructionStack.Push(new Cm.BoundTree.BoundDestructionStatement(boundReceiveStatement.SyntaxNode(), result->MainObject(), parameterClassType->Destructor()));
                }
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundInitClassObjectStatement& boundInitClassObjectStatement)
        {
            Llvm.Pusher x("BoundInitClassObjectStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            boundInitClassObjectStatement.FunctionCall()->Accept(*this);
            SharedPtr<Cm.Core.GenResult> callResult = resultStack.Pop();
            result->Merge(callResult);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundInitMemberVariableStatement& boundInitMemberVariableStatement)
        {
            Llvm.Pusher x("BoundInitMemberVariableStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            int n = boundInitMemberVariableStatement.Arguments().Count();
            Ir.Intf.LabelObject* resultLabel = null;
            for (int i = 0; i < n; ++i)
            {
                const UniquePtr<Cm.BoundTree.BoundExpression>& arg = boundInitMemberVariableStatement.Arguments()[i];
                arg->Accept(*this);
                SharedPtr<Cm.Core.GenResult> argResult = resultStack.Pop();
                if (resultLabel == null)
                {
                    resultLabel = argResult->GetLabel();
                }
                result->Merge(argResult);
            }
            Cm.Sym.FunctionSymbol* ctor = boundInitMemberVariableStatement.Constructor();
            result->SetMemberVar();
            GenerateCall(ctor, null, *result);
            if (boundInitMemberVariableStatement.RegisterDestructor())
            {
                RegisterDestructor(boundInitMemberVariableStatement.MemberVarSymbol());
            }
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundFunctionCallStatement& boundFunctionCallStatement)
        {
            Llvm.Pusher x("BoundFunctionCallStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Cm.Sym.FunctionSymbol* function = boundFunctionCallStatement.Function();
            if (!(function is Cm.Core.BasicTypeOp*) && !function->IsConstructorOrDestructorSymbol())
            {
                result->SetMainObject(function->GetReturnType(), typeRepository);
            }
            int n = boundFunctionCallStatement.Arguments().Count();
            Ir.Intf.LabelObject* resultLabel = null;
            for (int i = 0; i < n; ++i)
            {
                const UniquePtr<Cm.BoundTree.BoundExpression>& arg = boundFunctionCallStatement.Arguments()[i];
                arg->Accept(*this);
                SharedPtr<Cm.Core.GenResult> argResult = resultStack.Pop();
                if (resultLabel == null)
                {
                    resultLabel = argResult->GetLabel();
                }
                result->Merge(argResult);
            }
            GenerateCall(function, null, *result);
            ExecutePostfixIncDecStatements(*result);
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundReturnStatement& boundReturnStatement)
        {
            Llvm.Pusher x("BoundReturnStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            SharedPtr<Cm.Core.GenResult> entryResult;
            Ir.Intf.LabelObject* resultLabel = null;
            if (generateDebugInfo)
            {
                if (boundReturnStatement.SyntaxNode() == null)
                {
                    throw Exception("return statement has no syntax node");
                }
                CreateEntryDebugNode(boundReturnStatement, boundReturnStatement.SyntaxNode()->GetSpan());
                entryResult = resultStack.Pop();
                resultLabel = entryResult->GetLabel();
                compoundResult->Merge(entryResult);
            }
            if (boundReturnStatement.Expression() != null)
            {
                boundReturnStatement.Expression()->Accept(*this);
            }
            if (boundReturnStatement.ReturnsValue())
            {
                bool resultSet = false;
                SharedPtr<Cm.Core.GenResult> retValResult = resultStack.Pop();
                Cm.Sym.FunctionSymbol* ctor = boundReturnStatement.Constructor();
                bool returnsClassObjectByValue = currentFunction->FunctionSymbol()->ReturnsClassObjectByValue();
                if (returnsClassObjectByValue)
                {
                    result->SetMainObject(currentFunction->FunctionSymbol()->ClassObjectResultIrParam());
                }
                else if (boundReturnStatement.BoundTemporary() != null)
                {
                    SharedPtr<Cm.Core.GenResult> temporaryResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                    temporaryResult->SetMainObject(localVariableIrObjectRepository.GetLocalVariableIrObject(boundReturnStatement.BoundTemporary()->Symbol()));
                    temporaryResult->Merge(retValResult);
                    GenerateCall(ctor, boundReturnStatement.GetTraceCallInfo(), *temporaryResult);
                    result->SetMainObject(boundReturnStatement.ReturnType(), typeRepository);
                    result->Merge(temporaryResult);
                }
                else
                {
                    result->SetMainObject(boundReturnStatement.ReturnType(), typeRepository);
                }
                if (resultLabel == null)
                {
                    resultLabel = retValResult->GetLabel();
                }
                if (ctor is Cm.Bind.DelegateFromFunCtor*)
                {
                    result->SetMainObject(retValResult->MainObject());
                    Cm.Bind.DelegateFromFunCtor* delegateFromFunCtor = cast<Cm.Bind.DelegateFromFunCtor*>(ctor);
                    result->Objects()[0]->SetType(delegateFromFunCtor->DelegateType()->IrType());
                    resultSet = true;
                }
                result->Merge(retValResult);
                Ir.Intf.LabelObject* exprNext = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(exprNext);
                emitter->AddNextInstructionLabel(exprNext);
                if (resultLabel == null)
                {
                    resultLabel = exprNext;
                }
                if (!resultSet)
                {
                    GenerateCall(ctor, boundReturnStatement.GetTraceCallInfo(), *result);
                }
                ExecutePostfixIncDecStatements(*result);
                ExitFunction(*result);
                if (generateDebugInfo)
                {
                    if (currentFunction->Body()->SyntaxNode() == null)
                    {
                        throw Exception("current function body has no syntax node");
                    }
                    Cm.Ast.CompoundStatementNode* compoundStatementNode = cast<Cm.Ast.CompoundStatementNode*>(currentFunction->Body()->SyntaxNode());
                    CreateExitDebugNode(boundReturnStatement, compoundStatementNode->EndBraceSpan());
                    SharedPtr<Cm.Core.GenResult> exitResult = resultStack.Pop();
                    compoundResult->Merge(exitResult);
                }
                if (returnsClassObjectByValue)
                {
                    emitter->Emit(Cm.IrIntf.Ret());
                }
                else
                {
                    emitter->Emit(Cm.IrIntf.Ret(result->MainObject()));
                }
                if (resultLabel != null)
                {
                    result->SetLabel(resultLabel);
                }
            }
            else
            {
                ExitFunction(*result);
                if (generateDebugInfo)
                {
                    if (currentFunction->Body()->SyntaxNode() == null)
                    {
                        throw Exception("current function body has no syntax node");
                    }
                    Cm.Ast.CompoundStatementNode* compoundStatementNode = cast<Cm.Ast.CompoundStatementNode*>(currentFunction->Body()->SyntaxNode());
                    CreateExitDebugNode(boundReturnStatement, compoundStatementNode->EndBraceSpan());
                    SharedPtr<Cm.Core.GenResult> exitResult = resultStack.Pop();
                    compoundResult->Merge(exitResult);
                }
                emitter->Emit(Cm.IrIntf.Ret());
                if (resultLabel != null)
                {
                    result->SetLabel(resultLabel);
                }
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundBeginTryStatement& boundBeginTryStatement)
        {
            Llvm.Pusher x("BoundBeginTryStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            catchIdStack.Push(currentCatchId);
            currentCatchId = boundBeginTryStatement.FirstCatchId();
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundEndTryStatement& boundEndTryStatement)
        {
            Llvm.Pusher x("BoundEndTryStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            currentCatchId = catchIdStack.Pop();
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundExitBlocksStatement& boundExitBlocksStatement)
        {
            Llvm.Pusher x("BoundExitBlocksStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Cm.BoundTree.BoundCompoundStatement* currentCompound = boundExitBlocksStatement.CompoundParent();
            Cm.BoundTree.BoundCompoundStatement* targetCompound = boundExitBlocksStatement.TargetBlock();
            ExitCompounds(currentCompound, targetCompound, *result);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundBeginThrowStatement& boundBeginThrowStatement)
        {
            Llvm.Pusher x("BoundBeginThrowStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
            DoNothing(*result);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundEndThrowStatement& boundEndThrowStatement)
        {
            Llvm.Pusher x("BoundEndThrowStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
            DoNothing(*result);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundConstructionStatement& boundConstructionStatement)
        {
            Llvm.Pusher x("BoundConstructionStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (generateDebugInfo)
            {
                if (boundConstructionStatement.SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                Cm.Core.CfgNode* node = CreateDebugNode(boundConstructionStatement, boundConstructionStatement.SyntaxNode()->GetSpan(), true);
                if (node == null)
                {
                    throw Exception("node is null");
                }
                int defNode = node->Id();
                Cm.Sym.LocalVariableSymbol* variable = boundConstructionStatement.LocalVariable();
                string irName;
                Ir.Intf.Object* irObject = localVariableIrObjectRepository.GetLocalVariableIrObject(variable);
                if (irObject != null)
                {
                    irName = irObject->Name();
                }
                else
                {
                    throw Exception("ir object is null");
                }
                string typeName = variable->GetType()->FullName();
                Cm.Core.CFunctionDebugInfo* functionDebugInfo = GetFunctionDebugInfo();
                if (functionDebugInfo != null)
                {
                    functionDebugInfo->Locals().AddLocal(new Cm.Core.Local(variable->Name(), irName, typeName, defNode));
                }
                else
                {
                    throw Exception("function debug info is null");
                }
            }
            int n = boundConstructionStatement.Arguments().Count();
            Ir.Intf.LabelObject* resultLabel = null;
            Ir.Intf.Object* object = null;
            for (int i = 0; i < n; ++i)
            {
                const UniquePtr<Cm.BoundTree.BoundExpression>& arg = boundConstructionStatement.Arguments()[i];
                arg->Accept(*this);
                SharedPtr<Cm.Core.GenResult> argResult = resultStack.Pop();
                if (i == 0)
                {
                    object = argResult->MainObject();
                }
                if (resultLabel == null)
                {
                    resultLabel = argResult->GetLabel();
                }
                result->Merge(argResult);
            }
            Cm.Sym.FunctionSymbol* ctor = boundConstructionStatement.Constructor();
            Ir.Intf.LabelObject* exprNext = Cm.IrIntf.CreateNextLocalLabel();
            emitter->Own(exprNext);
            emitter->AddNextInstructionLabel(exprNext);
            GenerateCall(ctor, boundConstructionStatement.GetTraceCallInfo(), *result);
            ExecutePostfixIncDecStatements(*result);
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            Cm.Sym.TypeSymbol* variableType = boundConstructionStatement.LocalVariable()->GetType();
            if (variableType is Cm.Sym.ClassTypeSymbol*)
            {
                Cm.Sym.ClassTypeSymbol* variableClassType = cast<Cm.Sym.ClassTypeSymbol*>(variableType);
                if (variableClassType->Destructor() != null)
                {
                    currentCompoundDestructionStack.Push(new Cm.BoundTree.BoundDestructionStatement(null, object, variableClassType->Destructor()));
                }
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundDestructionStatement& boundDestructionStatement)
        {
            Llvm.Pusher x("BoundDestructionStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(boundDestructionStatement.Object());
            Cm.Sym.FunctionSymbol* dtor = boundDestructionStatement.Destructor();
            GenerateCall(dtor, null, *result);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundAssignmentStatement& boundAssignmentStatement)
        {
            Llvm.Pusher x("BoundAssignmentStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (generateDebugInfo)
            {
                if (boundAssignmentStatement.SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(boundAssignmentStatement, boundAssignmentStatement.SyntaxNode()->GetSpan(), true);
            }
            boundAssignmentStatement.Left()->Accept(*this);
            boundAssignmentStatement.Right()->Accept(*this);
            Cm.Sym.FunctionSymbol* assignment = boundAssignmentStatement.Assignment();
            if (!(assignment is Cm.Core.BasicTypeOp*) && !assignment->IsArrayAssignment())
            {
                result->SetMainObject(assignment->GetReturnType(), typeRepository);
            }
            SharedPtr<Cm.Core.GenResult> sourceResult = resultStack.Pop();
            SharedPtr<Cm.Core.GenResult> targetResult = resultStack.Pop();
            Ir.Intf.LabelObject* resultLabel = targetResult->GetLabel();
            if (resultLabel == null)
            {
                resultLabel = sourceResult->GetLabel();
            }
            result->Merge(targetResult);
            result->Merge(sourceResult);
            Ir.Intf.LabelObject* exprNext = Cm.IrIntf.CreateNextLocalLabel();
            emitter->Own(exprNext);
            emitter->AddNextInstructionLabel(exprNext);
            GenerateCall(assignment, boundAssignmentStatement.GetTraceCallInfo(), *result);
            ExecutePostfixIncDecStatements(*result);
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundSimpleStatement& boundSimpleStatement)
        {
            Llvm.Pusher x("BoundSimpleStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (generateDebugInfo)
            {
                if (boundSimpleStatement.SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(boundSimpleStatement, boundSimpleStatement.SyntaxNode()->GetSpan(), true);
            }
            if (boundSimpleStatement.HasExpression())
            {
                boundSimpleStatement.Expression()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> expressionResult = resultStack.Pop();
                result->SetLabel(expressionResult->GetLabel());
                result->Merge(expressionResult);
                ExecutePostfixIncDecStatements(*result);
            }
            else
            {
                result->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
                DoNothing(*result);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundBreakStatement& boundBreakStatement)
        {
            Llvm.Pusher x("BoundBreakStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (generateDebugInfo)
            {
                if (boundBreakStatement.SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(boundBreakStatement, boundBreakStatement.SyntaxNode()->GetSpan(), false);
            }
            Ir.Intf.LabelObject* breakTargetLabel = Cm.IrIntf.CreateNextLocalLabel();
            emitter->Own(breakTargetLabel);
            breakTargetStatement->AddBreakTargetLabel(breakTargetLabel);
            ExitCompounds(boundBreakStatement.CompoundParent(), breakTargetStatement->CompoundParent(), *result);
            if (generateDebugInfo)
            {
                breakTargetStatement->AddToBreakNextSet(boundBreakStatement.CfgNode());
            }
            emitter->UseCDebugNode(boundBreakStatement.CfgNode());
            emitter->Emit(Cm.IrIntf.Br(breakTargetLabel));
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundContinueStatement& boundContinueStatement)
        {
            Llvm.Pusher x("BoundContinueStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (generateDebugInfo)
            {
                if (boundContinueStatement.SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(boundContinueStatement, boundContinueStatement.SyntaxNode()->GetSpan(), false);
            }
            Ir.Intf.LabelObject* continueTargetLabel = Cm.IrIntf.CreateNextLocalLabel();
            emitter->Own(continueTargetLabel);
            continueTargetStatement->AddContinueTargetLabel(continueTargetLabel);
            ExitCompounds(boundContinueStatement.CompoundParent(), continueTargetStatement->CompoundParent(), *result);
            if (generateDebugInfo)
            {
                continueTargetStatement->AddToContinueNextSet(boundContinueStatement.CfgNode());
            }
            emitter->UseCDebugNode(boundContinueStatement.CfgNode());
            emitter->Emit(Cm.IrIntf.Br(continueTargetLabel));
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundGotoStatement& boundGotoStatement)
        {
            Llvm.Pusher x("BoundGotoStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (generateDebugInfo)
            {
                if (boundGotoStatement.SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(boundGotoStatement, boundGotoStatement.SyntaxNode()->GetSpan(), false);
            }
            if (!boundGotoStatement.IsExceptionHandlingGoto())
            {
                ExitCompounds(boundGotoStatement.CompoundParent(), boundGotoStatement.TargetCompoundParent(), *result);
            }
            Ir.Intf.LabelObject* gotoTargetLabel = Cm.IrIntf.CreateLabel(boundGotoStatement.TargetLabel());
            emitter->Own(gotoTargetLabel);
            if (generateDebugInfo)
            {
                if (boundGotoStatement.TargetStatement()->CfgNode() != null)
                {
                    AddDebugNodeTransition(boundGotoStatement, *boundGotoStatement.TargetStatement());
                }
                else
                {
                    boundGotoStatement.TargetStatement()->AddToPrevSet(boundGotoStatement.CfgNode());
                }
            }
            emitter->Emit(Cm.IrIntf.Br(gotoTargetLabel));
            resultStack.Push(result);
        }
        public override void BeginVisit(Cm.BoundTree.BoundConditionalStatement& boundConditionalStatement)
        {
            Llvm.Pusher x("BeginBoundConditionalStatement");
            PushSkipContent();
            if (generateDebugInfo)
            {
                if (boundConditionalStatement.SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(boundConditionalStatement, boundConditionalStatement.SyntaxNode()->GetSpan(), true);
            }
            functionDestructionStack.Push(Rvalue(currentCompoundDestructionStack));
            currentCompoundDestructionStack = CompoundDestructionStack();
        }
        public override void EndVisit(Cm.BoundTree.BoundConditionalStatement& boundConditionalStatement)
        {
            Llvm.Pusher x("EndBoundConditionalStatement");
            PopSkipContent();
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            SharedPtr<Cm.Core.GenResult> conditionResult = resultStack.Pop();
            Ir.Intf.LabelObject* resultLabel = conditionResult->GetLabel();
            int debugNodeSetHandle = -1;
            if (currentCompoundDestructionStack.IsEmpty())
            {
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                Cm.BoundTree.BoundStatement* thenS = boundConditionalStatement.ThenS();
                BeginVisitStatement(*thenS);
                thenS->Accept(*this);
                if (generateDebugInfo)
                {
                    AddDebugNodeTransition(boundConditionalStatement, *thenS);
                }
                SharedPtr<Cm.Core.GenResult> thenResult = resultStack.Pop();
                conditionResult->BackpatchTrueTargets(thenResult->GetLabel());
                BackpatchNextTargets(thenResult->GetLabel());
                Ir.Intf.LabelObject* next = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(next);
                result->AddNextTarget(next);
                emitter->Emit(Cm.IrIntf.Br(next));
                result->Merge(thenResult);
                Cm.BoundTree.BoundStatement* elseS = boundConditionalStatement.ElseS();
                if (elseS != null)
                {
                    if (generateDebugInfo)
                    {
                        debugNodeSetHandle = RetrievePrevDebugNodes();
                    }
                    BeginVisitStatement(*elseS);
                    elseS->Accept(*this);
                    if (generateDebugInfo)
                    {
                        AddDebugNodeTransition(boundConditionalStatement, *elseS);
                    }
                    SharedPtr<Cm.Core.GenResult> elseResult = resultStack.Pop();
                    conditionResult->BackpatchFalseTargets(elseResult->GetLabel());
                    BackpatchNextTargets(elseResult->GetLabel());
                    result->Merge(elseResult);
                }
                else
                {
                    result->MergeTargets(result->NextTargets(), conditionResult->FalseTargets());
                    AddToPrevDebugNodes(boundConditionalStatement);
                }
            }
            else
            {
                bool trueFirst = true;
                SharedPtr<Cm.Core.GenResult> trueResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                ExitCompound(*trueResult, currentCompoundDestructionStack, trueFirst);
                CompoundDestructionStack tempCompoundDestructionStack = Rvalue(currentCompoundDestructionStack);
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                conditionResult->BackpatchTrueTargets(trueResult->GetLabel());
                Ir.Intf.LabelObject* trueLabel = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(trueLabel);
                emitter->Emit(Cm.IrIntf.Br(trueLabel));
                Cm.BoundTree.BoundStatement* thenS = boundConditionalStatement.ThenS();
                BeginVisitStatement(*thenS);
                thenS->Accept(*this);
                if (generateDebugInfo)
                {
                    AddDebugNodeTransition(boundConditionalStatement, *thenS);
                }
                SharedPtr<Cm.Core.GenResult> thenResult = resultStack.Pop();
                trueLabel->Set(thenResult->GetLabel());
                BackpatchNextTargets(thenResult->GetLabel());
                Ir.Intf.LabelObject* next = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(next);
                result->AddNextTarget(next);
                emitter->Emit(Cm.IrIntf.Br(next));
                result->Merge(thenResult);
                bool falseFirst = true;
                SharedPtr<Cm.Core.GenResult> falseResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                ExitCompound(*falseResult, tempCompoundDestructionStack, falseFirst);
                conditionResult->BackpatchFalseTargets(falseResult->GetLabel());
                Ir.Intf.LabelObject* falseLabel = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(falseLabel);
                emitter->Emit(Cm.IrIntf.Br(falseLabel));
                Cm.BoundTree.BoundStatement* elseS = boundConditionalStatement.ElseS();
                if (elseS != null)
                {
                    if (generateDebugInfo)
                    {
                        debugNodeSetHandle = RetrievePrevDebugNodes();
                    }
                    BeginVisitStatement(*elseS);
                    elseS->Accept(*this);
                    if (generateDebugInfo)
                    {
                        AddDebugNodeTransition(boundConditionalStatement, *elseS);
                    }
                    SharedPtr<Cm.Core.GenResult> elseResult = resultStack.Pop();
                    falseLabel->Set(elseResult->GetLabel());
                    BackpatchNextTargets(elseResult->GetLabel());
                    result->Merge(elseResult);
                }
                else
                {
                    result->AddNextTarget(falseLabel);
                    AddToPrevDebugNodes(boundConditionalStatement);
                }
            }
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            if (debugNodeSetHandle != -1)
            {
                AddToPrevDebugNodes(debugNodeSetHandle);
            }
            result->Merge(conditionResult, true);
            resultStack.Push(result);
        }
        public override void BeginVisit(Cm.BoundTree.BoundWhileStatement& boundWhileStatement)
        {
            Llvm.Pusher x("BeginBoundWhileStatement");
            PushSkipContent();
            if (generateDebugInfo)
            {
                if (boundWhileStatement.Condition()->SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(boundWhileStatement, boundWhileStatement.Condition()->SyntaxNode()->GetSpan(), true);
            }
            functionDestructionStack.Push(Rvalue(currentCompoundDestructionStack));
            currentCompoundDestructionStack = CompoundDestructionStack();
        }
        public override void EndVisit(Cm.BoundTree.BoundWhileStatement& boundWhileStatement)
        {
            Llvm.Pusher x("EndBoundWhileStatement");
            PopSkipContent();
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            SharedPtr<Cm.Core.GenResult> conditionResult = resultStack.Pop();
            SharedPtr<Cm.Core.GenResult> statementResult;
            if (currentCompoundDestructionStack.IsEmpty())
            {
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                Cm.BoundTree.BoundStatement* statement = boundWhileStatement.Statement();
                PushBreakTargetStatement(&boundWhileStatement);
                PushContinueTargetStatement(&boundWhileStatement);
                BeginVisitStatement(*statement);
                statement->Accept(*this);
                if (generateDebugInfo)
                {
                    PatchPrevDebugNodes(boundWhileStatement);
                    AddDebugNodeTransition(boundWhileStatement, *statement);
                }
                statementResult = resultStack.Pop();
                emitter->Emit(Cm.IrIntf.Br(conditionResult->GetLabel()));
                conditionResult->BackpatchTrueTargets(statementResult->GetLabel());
                statementResult->BackpatchNextTargets(conditionResult->GetLabel());
                BackpatchNextTargets(statementResult->GetLabel());
                result->MergeTargets(result->NextTargets(), conditionResult->FalseTargets());
                result->MergeTargets(result->NextTargets(), boundWhileStatement.BreakTargetLabels());
                Ir.Intf.Backpatch(boundWhileStatement.ContinueTargetLabels(), conditionResult->GetLabel());
                PopContinueTargetStatement();
                PopBreakTargetStatement();
            }
            else
            {
                bool trueFirst = true;
                SharedPtr<Cm.Core.GenResult> trueResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                ExitCompound(*trueResult, currentCompoundDestructionStack, trueFirst);
                CompoundDestructionStack tempCompoundDestructionStack = Rvalue(currentCompoundDestructionStack);
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                conditionResult->BackpatchTrueTargets(trueResult->GetLabel());
                Ir.Intf.LabelObject* trueLabel = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(trueLabel);
                emitter->Emit(Cm.IrIntf.Br(trueLabel));
                Cm.BoundTree.BoundStatement* statement = boundWhileStatement.Statement();
                PushBreakTargetStatement(&boundWhileStatement);
                PushContinueTargetStatement(&boundWhileStatement);
                BeginVisitStatement(*statement);
                statement->Accept(*this);
                if (generateDebugInfo)
                {
                    PatchPrevDebugNodes(boundWhileStatement);
                    AddDebugNodeTransition(boundWhileStatement, *statement);
                }
                statementResult = resultStack.Pop();
                emitter->Emit(Cm.IrIntf.Br(conditionResult->GetLabel()));
                trueLabel->Set(statementResult->GetLabel());
                statementResult->BackpatchNextTargets(conditionResult->GetLabel());
                BackpatchNextTargets(statementResult->GetLabel());
                bool falseFirst = true;
                SharedPtr<Cm.Core.GenResult> falseResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                ExitCompound(*falseResult, tempCompoundDestructionStack, falseFirst);
                conditionResult->BackpatchFalseTargets(falseResult->GetLabel());
                Ir.Intf.LabelObject* falseLabel = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(falseLabel);
                emitter->Emit(Cm.IrIntf.Br(falseLabel));
                result->AddNextTarget(falseLabel);
                result->MergeTargets(result->NextTargets(), boundWhileStatement.BreakTargetLabels());
                Ir.Intf.Backpatch(boundWhileStatement.ContinueTargetLabels(), conditionResult->GetLabel());
                PopContinueTargetStatement();
                PopBreakTargetStatement();
            }
            if (generateDebugInfo)
            {
                AddToPrevDebugNodes(boundWhileStatement);
                AddToPrevDebugNodes(boundWhileStatement.BreakNextSet());
                PatchDebugNodes(boundWhileStatement.ContinueNextSet(), boundWhileStatement.CfgNode());
            }
            result->SetLabel(conditionResult->GetLabel());
            result->Merge(conditionResult, true);
            result->Merge(statementResult);
            resultStack.Push(result);
        }
        public override void BeginVisit(Cm.BoundTree.BoundDoStatement& boundDoStatement)
        {
            Llvm.Pusher x("BeginBoundDoStatement");
            PushSkipContent();
        }
        public override void EndVisit(Cm.BoundTree.BoundDoStatement& boundDoStatement)
        {
            Llvm.Pusher x("EndBoundDoStatement");
            PopSkipContent();
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Cm.BoundTree.BoundStatement* statement = boundDoStatement.Statement();
            PushBreakTargetStatement(&boundDoStatement);
            PushContinueTargetStatement(&boundDoStatement);
            BeginVisitStatement(*statement);
            statement->Accept(*this);
            if (generateDebugInfo)
            {
                SetCfgNode(*statement, boundDoStatement);
            }
            SharedPtr<Cm.Core.GenResult> statementResult = resultStack.Pop();
            Cm.BoundTree.BoundExpression* condition = boundDoStatement.Condition();
            if (generateDebugInfo)
            {
                if (condition->SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(*condition, condition->SyntaxNode()->GetSpan());
                AddDebugNodeTransition(*condition, boundDoStatement);
            }
            functionDestructionStack.Push(Rvalue(currentCompoundDestructionStack));
            currentCompoundDestructionStack = CompoundDestructionStack();
            condition->Accept(*this);
            SharedPtr<Cm.Core.GenResult> conditionResult = resultStack.Pop();
            statementResult->BackpatchNextTargets(conditionResult->GetLabel());
            if (currentCompoundDestructionStack.IsEmpty())
            {
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                conditionResult->BackpatchTrueTargets(statementResult->GetLabel());
                BackpatchNextTargets(statementResult->GetLabel());
                result->MergeTargets(result->NextTargets(), conditionResult->FalseTargets());
                result->MergeTargets(result->NextTargets(), boundDoStatement.BreakTargetLabels());
                Ir.Intf.Backpatch(boundDoStatement.ContinueTargetLabels(), conditionResult->GetLabel());
            }
            else
            {
                bool trueFirst = true;
                SharedPtr<Cm.Core.GenResult> trueResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                ExitCompound(*trueResult, currentCompoundDestructionStack, trueFirst);
                CompoundDestructionStack tempCompoundDestructionStack = Rvalue(currentCompoundDestructionStack);
                currentCompoundDestructionStack = functionDestructionStack.Pop();
                conditionResult->BackpatchTrueTargets(trueResult->GetLabel());
                Ir.Intf.LabelObject* trueLabel = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(trueLabel);
                emitter->Emit(Cm.IrIntf.Br(statementResult->GetLabel()));
                bool falseFirst = true;
                SharedPtr<Cm.Core.GenResult> falseResult(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                ExitCompound(*falseResult, tempCompoundDestructionStack, falseFirst);
                conditionResult->BackpatchFalseTargets(falseResult->GetLabel());
                Ir.Intf.Backpatch(boundDoStatement.BreakTargetLabels(), falseResult->GetLabel());
                Ir.Intf.Backpatch(boundDoStatement.ContinueTargetLabels(), conditionResult->GetLabel());
            }
            if (generateDebugInfo)
            {
                AddToPrevDebugNodes(*condition);
                AddToPrevDebugNodes(boundDoStatement.BreakNextSet());
                PatchDebugNodes(boundDoStatement.ContinueNextSet(), condition->CfgNode());
            }
            PopContinueTargetStatement();
            PopBreakTargetStatement();
            result->SetLabel(statementResult->GetLabel());
            result->Merge(statementResult);
            result->Merge(conditionResult);
            resultStack.Push(result);
        }
        public override void BeginVisit(Cm.BoundTree.BoundForStatement& boundForStatement)
        {
            Llvm.Pusher x("BeginBoundForStatement");
            PushSkipContent();
        }
        public override void EndVisit(Cm.BoundTree.BoundForStatement& boundForStatement)
        {
            Llvm.Pusher x("EndBoundForStatement");
            PopSkipContent();
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            PushBreakTargetStatement(&boundForStatement);
            PushContinueTargetStatement(&boundForStatement);
            Cm.Ast.Node* node = null;
            Cm.Ast.ForStatementNode* forStatementNode = null;
            if (generateDebugInfo)
            {
                node = boundForStatement.SyntaxNode();
                if (node == null)
                {
                    throw Exception("syntax node not set");
                }
                if (!(node is Cm.Ast.StatementNode*))
                {
                    throw Exception("statement node expected");
                }
                Cm.Ast.StatementNode* statementNode = cast<Cm.Ast.StatementNode*>(node);
                if (!(statementNode is Cm.Ast.ForStatementNode*))
                {
                    throw Exception("for statement node expected");
                }
                forStatementNode = cast<Cm.Ast.ForStatementNode*>(statementNode);
            }
            bool debugInfoDisabled = false;
            if (generateDebugInfo && forStatementNode != null && forStatementNode->IsRangeForStatement())
            {
                PushGenDebugInfo(false);
                debugInfoDisabled = true;
            }
            Cm.BoundTree.BoundStatement* initS = boundForStatement.InitS();
            BeginVisitStatement(*initS);
            initS->Accept(*this);
            if (debugInfoDisabled)
            {
                PopGenDebugInfo();
            }
            if (generateDebugInfo)
            {
                if (!debugInfoDisabled)
                {
                    SetCfgNode(*initS, boundForStatement);
                }
                if (boundForStatement.Condition()->SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(*boundForStatement.Condition(), boundForStatement.Condition()->SyntaxNode()->GetSpan());
            }
            SharedPtr<Cm.Core.GenResult> initResult = resultStack.Pop();
            Ir.Intf.LabelObject* initLabel = initResult->GetLabel();
            Cm.BoundTree.BoundExpression* condition = boundForStatement.Condition();
            condition->Accept(*this);
            SharedPtr<Cm.Core.GenResult> conditionResult = resultStack.Pop();
            initResult->BackpatchNextTargets(conditionResult->GetLabel());
            BackpatchNextTargets(initLabel);
            Cm.BoundTree.BoundStatement* action = boundForStatement.Action();
            BeginVisitStatement(*action);
            action->Accept(*this);
            if (generateDebugInfo)
            {
                AddDebugNodeTransition(*boundForStatement.Condition(), *action);
            }
            SharedPtr<Cm.Core.GenResult> actionResult = resultStack.Pop();
            conditionResult->BackpatchTrueTargets(actionResult->GetLabel());
            BackpatchNextTargets(actionResult->GetLabel());
            result->MergeTargets(result->NextTargets(), conditionResult->FalseTargets());
            Cm.BoundTree.BoundExpression* increment = boundForStatement.Increment();
            if (generateDebugInfo)
            {
                if (increment->SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(*increment, increment->SyntaxNode()->GetSpan());
            }
            increment->Accept(*this);
            if (generateDebugInfo)
            {
                AddDebugNodeTransition(*increment, *condition);
            }
            SharedPtr<Cm.Core.GenResult> incrementResult = resultStack.Pop();
            actionResult->BackpatchNextTargets(incrementResult->GetLabel());
            incrementResult->BackpatchNextTargets(conditionResult->GetLabel());
            emitter->Emit(Cm.IrIntf.Br(conditionResult->GetLabel()));
            result->MergeTargets(result->NextTargets(), boundForStatement.BreakTargetLabels());
            Ir.Intf.Backpatch(boundForStatement.ContinueTargetLabels(), incrementResult->GetLabel());
            PopContinueTargetStatement();
            PopBreakTargetStatement();
            if (generateDebugInfo)
            {
                AddToPrevDebugNodes(*condition);
                AddToPrevDebugNodes(boundForStatement.BreakNextSet());
                PatchDebugNodes(boundForStatement.ContinueNextSet(), increment->CfgNode());
            }
            result->Merge(initResult);
            result->Merge(initResult);
            result->Merge(actionResult);
            result->Merge(incrementResult);
            result->SetLabel(initLabel);
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundSwitchStatement& boundSwitchStatement)
        {
            Llvm.Pusher x("BoundSwitchStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            if (generateDebugInfo)
            {
                if (boundSwitchStatement.Condition()->SyntaxNode() == null)
                {
                    throw Exception("syntax node not set");
                }
                CreateDebugNode(boundSwitchStatement, boundSwitchStatement.Condition()->SyntaxNode()->GetSpan(), false);
            }
            PushBreakTargetStatement(&boundSwitchStatement);
            boundSwitchStatement.Condition()->Accept(*this);
            SharedPtr<Cm.Core.GenResult> conditionResult = resultStack.Pop();
            Ir.Intf.LabelObject* resultLabel = conditionResult->GetLabel();
            result->Merge(conditionResult);
            List<Ir.Intf.LabelObject*> caseLabels;
            HashMap<string, Pair<Ir.Intf.LabelObject*, Cm.BoundTree.BoundStatement*>> caseConstantMap;
            HashMap<string, Pair<Ir.Intf.LabelObject*, Cm.BoundTree.BoundStatement*>>* caseConstantMapPtr = &caseConstantMap;
            List<Pair<Ir.Intf.Object*, Ir.Intf.LabelObject*>> destinations;
            switchEmitStateStack.Push(currentSwitchEmitState);
            currentSwitchEmitState = SwitchEmitState.createSwitchTargets;
            switchCaseConstantMapStack.Push(currentSwitchCaseConstantMap);
            currentSwitchCaseConstantMap = caseConstantMapPtr;
            for (const UniquePtr<Cm.BoundTree.BoundStatement>& caseStatement : boundSwitchStatement.CaseStatements())
            {
                switchCaseConstants.Clear();
                caseStatement->Accept(*this);
                Ir.Intf.LabelObject* caseLabel = switchCaseLabel;
                for (Ir.Intf.Object* caseConstant : switchCaseConstants)
                {
                    destinations.Add(MakePair(caseConstant, caseLabel));
                }
                caseLabels.Add(caseLabel);
            }
            Ir.Intf.LabelObject* defaultDest = null;
            if (boundSwitchStatement.DefaultStatement() != null)
            {
                boundSwitchStatement.DefaultStatement()->Accept(*this);
                defaultDest = switchCaseLabel;
            }
            else
            {
                defaultDest = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(defaultDest);
                result->AddNextTarget(defaultDest);
                AddToPrevDebugNodes(boundSwitchStatement);
            }
            currentSwitchCaseConstantMap = switchCaseConstantMapStack.Pop();
            currentSwitchEmitState = switchEmitStateStack.Pop();
            Ir.Intf.Instruction* switchInst = Cm.IrIntf.Switch(result->MainObject()->GetType(), result->MainObject(), defaultDest, destinations);
            emitter->Emit(switchInst);
            List<int> prevDebugNodeHandles;
            int index = 0;
            for (UniquePtr<Cm.BoundTree.BoundStatement>& caseStatement : boundSwitchStatement.CaseStatements())
            {
                switchEmitStateStack.Push(currentSwitchEmitState);
                currentSwitchEmitState = SwitchEmitState.emitStatements;
                switchCaseConstantMapStack.Push(currentSwitchCaseConstantMap);
                currentSwitchCaseConstantMap = caseConstantMapPtr;
                switchCaseLabel = caseLabels[index];
                caseStatement->Accept(*this);
                if (generateDebugInfo)
                {
                    AddDebugNodeTransition(boundSwitchStatement, *caseStatement);
                    prevDebugNodeHandles.Add(RetrievePrevDebugNodes());
                }
                currentSwitchCaseConstantMap = switchCaseConstantMapStack.Pop();
                currentSwitchEmitState = switchEmitStateStack.Pop();
                SharedPtr<Cm.Core.GenResult> caseResult = resultStack.Pop();
                result->Merge(caseResult);
                ++index;
            }
            if (boundSwitchStatement.DefaultStatement() != null)
            {
                switchEmitStateStack.Push(currentSwitchEmitState);
                currentSwitchEmitState = SwitchEmitState.emitStatements;
                switchCaseConstantMapStack.Push(currentSwitchCaseConstantMap);
                currentSwitchCaseConstantMap = caseConstantMapPtr;
                switchCaseLabel = defaultDest;
                boundSwitchStatement.DefaultStatement()->Accept(*this);
                if (generateDebugInfo)
                {
                    AddDebugNodeTransition(boundSwitchStatement, *boundSwitchStatement.DefaultStatement());
                    prevDebugNodeHandles.Add(RetrievePrevDebugNodes());
                }
                currentSwitchCaseConstantMap = switchCaseConstantMapStack.Pop();
                currentSwitchEmitState = switchEmitStateStack.Pop();
                SharedPtr<Cm.Core.GenResult> defaultResult = resultStack.Pop();
                result->Merge(defaultResult);
            }
            result->MergeTargets(result->NextTargets(), boundSwitchStatement.BreakTargetLabels());
            if (resultLabel != null)
            {
                result->SetLabel(resultLabel);
            }
            PopBreakTargetStatement();
            if (generateDebugInfo)
            {
                for (int handle : prevDebugNodeHandles)
                {
                    AddToPrevDebugNodes(handle);
                }
                AddToPrevDebugNodes(boundSwitchStatement.BreakNextSet());
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundCaseStatement& boundCaseStatement)
        {
            Llvm.Pusher x("BoundCaseStatement");
            if (currentSwitchEmitState == SwitchEmitState.createSwitchTargets)
            {
                Ir.Intf.LabelObject* label = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(label);
                for (const UniquePtr<Cm.Sym.Value>& value : boundCaseStatement.Values())
                {
                    Ir.Intf.Object* caseConstant = value->CreateIrObject();
                    emitter->Own(caseConstant);
                    if (currentSwitchCaseConstantMap->CFind(caseConstant->Name()) != currentSwitchCaseConstantMap->CEnd())
                    {
                        Span span(0, 0, 0, 0);
                        if (boundCaseStatement.SyntaxNode() != null)
                        {
                            span = boundCaseStatement.SyntaxNode()->GetSpan();
                        }
                        throw Cm.Core.Error("duplicate case constant '" + caseConstant->Name() + "'", span);
                    }
                    currentSwitchCaseConstantMap->Insert(MakePair(caseConstant->Name(), MakePair(label, cast<Cm.BoundTree.BoundStatement*>(&boundCaseStatement))));
                    switchCaseConstants.Add(caseConstant);
                }
                switchCaseLabel = label;
            }
            else if (currentSwitchEmitState == SwitchEmitState.emitStatements)
            {
                SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                if (generateDebugInfo)
                {
                    if (boundCaseStatement.SyntaxNode() == null)
                    {
                        throw Exception("syntax node not set");
                    }
                    CreateEntryDebugNode(boundCaseStatement, boundCaseStatement.SyntaxNode()->GetSpan());
                    SharedPtr<Cm.Core.GenResult> entryResult = resultStack.Pop();
                    result->Merge(entryResult);
                    result->SetLabel(entryResult->GetLabel());
                    switchCaseLabel->Set(entryResult->GetLabel());
                }
                else
                {
                    emitter->AddNextInstructionLabel(switchCaseLabel);
                }
                for (const UniquePtr<Cm.BoundTree.BoundStatement>& statement : boundCaseStatement.Statements())
                {
                    statement->Accept(*this);
                    SharedPtr<Cm.Core.GenResult> statementResult = resultStack.Pop();
                    result->Merge(statementResult);
                }
                resultStack.Push(result);
            }
        }
        public override void Visit(Cm.BoundTree.BoundDefaultStatement& boundDefaultStatement)
        {
            Llvm.Pusher x("BoundDefaultStatement");
            if (currentSwitchEmitState == SwitchEmitState.createSwitchTargets)
            {
                Ir.Intf.LabelObject* label = Cm.IrIntf.CreateNextLocalLabel();
                emitter->Own(label);
                switchCaseLabel = label;
                currentSwitchCaseConstantMap->Insert(MakePair(string("@default"), MakePair(label, cast<Cm.BoundTree.BoundStatement*>(&boundDefaultStatement))));
            }
            else if (currentSwitchEmitState == SwitchEmitState.emitStatements)
            {
                SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                if (generateDebugInfo)
                {
                    if (boundDefaultStatement.SyntaxNode() == null)
                    {
                        throw Exception("syntax node not set");
                    }
                    CreateEntryDebugNode(boundDefaultStatement, boundDefaultStatement.SyntaxNode()->GetSpan());
                    SharedPtr<Cm.Core.GenResult> entryResult = resultStack.Pop();
                    result->Merge(entryResult);
                    result->SetLabel(entryResult->GetLabel());
                    switchCaseLabel->Set(entryResult->GetLabel());
                }
                else
                {
                    emitter->AddNextInstructionLabel(switchCaseLabel);
                }
                for (const UniquePtr<Cm.BoundTree.BoundStatement>& statement : boundDefaultStatement.Statements())
                {
                    statement->Accept(*this);
                    SharedPtr<Cm.Core.GenResult> statementResult = resultStack.Pop();
                    result->Merge(statementResult);
                }
                resultStack.Push(result);
            }
        }
        public override void Visit(Cm.BoundTree.BoundGotoCaseStatement& boundGotoCaseStatement)
        {
            Llvm.Pusher x("BoundGotoCaseStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            Cm.Sym.Value* value = boundGotoCaseStatement.Value();
            Ir.Intf.Object* caseConstant = value->CreateIrObject();
            emitter->Own(caseConstant);
            HashMap<string, Pair<Ir.Intf.LabelObject*, Cm.BoundTree.BoundStatement*>>.ConstIterator i = currentSwitchCaseConstantMap->CFind(caseConstant->Name());
            if (i != currentSwitchCaseConstantMap->CEnd())
            {
                Ir.Intf.LabelObject* target = i->second.first;
                Cm.BoundTree.BoundStatement* targetS = i->second.second;
                ExitCompounds(boundGotoCaseStatement.CompoundParent(), targetS->CompoundParent(), *result);
                if (generateDebugInfo)
                {
                    if (boundGotoCaseStatement.SyntaxNode() == null)
                    {
                        throw Exception("syntax node not set");
                    }
                    CreateDebugNode(boundGotoCaseStatement, boundGotoCaseStatement.SyntaxNode()->GetSpan(), false);
                    if (targetS->CfgNode() != null)
                    {
                        AddDebugNodeTransition(boundGotoCaseStatement, *targetS);
                    }
                    else
                    {
                        targetS->AddToPrevSet(boundGotoCaseStatement.CfgNode());
                    }
                }
                emitter->Emit(Cm.IrIntf.Br(target));
            }
            else
            {
                Span span(0, 0, 0, 0);
                if (boundGotoCaseStatement.SyntaxNode() != null)
                {
                    span = boundGotoCaseStatement.SyntaxNode()->GetSpan();
                }
                throw Cm.Core.Error("goto case statement target not found", span);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundGotoDefaultStatement& boundGotoDefaultStatement)
        {
            Llvm.Pusher x("BoundGotoDefaultStatement");
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            HashMap<string, Pair<Ir.Intf.LabelObject*, Cm.BoundTree.BoundStatement*>>.ConstIterator i = currentSwitchCaseConstantMap->CFind("@default");
            if (i != currentSwitchCaseConstantMap->CEnd())
            {
                Ir.Intf.LabelObject* target = i->second.first;
                Cm.BoundTree.BoundStatement* targetS = i->second.second;
                ExitCompounds(boundGotoDefaultStatement.CompoundParent(), targetS->CompoundParent(), *result);
                if (generateDebugInfo)
                {
                    if (boundGotoDefaultStatement.SyntaxNode() == null)
                    {
                        throw Exception("syntax node not set");
                    }
                    CreateDebugNode(boundGotoDefaultStatement, boundGotoDefaultStatement.SyntaxNode()->GetSpan(), false);
                    if (targetS->CfgNode() != null)
                    {
                        AddDebugNodeTransition(boundGotoDefaultStatement, *targetS);
                    }
                    else
                    {
                        targetS->AddToPrevSet(boundGotoDefaultStatement.CfgNode());
                    }
                }
                emitter->Emit(Cm.IrIntf.Br(target));
            }
            else
            {
                Span span(0, 0, 0, 0);
                if (boundGotoDefaultStatement.SyntaxNode() != null)
                {
                    span = boundGotoDefaultStatement.SyntaxNode()->GetSpan();
                }
                throw Cm.Core.Error("goto default statement target not found", span);
            }
            resultStack.Push(result);
        }
        public override void Visit(Cm.BoundTree.BoundPushGenDebugInfoStatement& boundPushGenDebugInfoStatement)
        {
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            resultStack.Push(result);
            PushGenDebugInfo(boundPushGenDebugInfoStatement.Generate());
        }
        public override void Visit(Cm.BoundTree.BoundPopGenDebugInfoStatement& boundPopGenDebugInfoStatement)
        {
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            resultStack.Push(result);
            PopGenDebugInfo();
        }
        public virtual void MapIrFunToFun(Ir.Intf.Function* irFun, Cm.Sym.FunctionSymbol* fun)
        {
        }
        public virtual void EmitDummyVar(Cm.Core.Emitter* emitter)
        {
        }
        public virtual Ir.Intf.Type* ReplaceFunctionPtrType(Ir.Intf.Type* localVariableIrType)
        {
            return localVariableIrType;
        }
        public virtual Cm.Core.CfgNode* CreateDebugNode(Cm.BoundTree.BoundStatement& statement, const Span& span, bool addToPrevNodes)
        {
            return null;
        }
        public virtual void CreateDebugNode(Cm.BoundTree.BoundExpression& expr, const Span& span)
        {
        }
        public virtual void CreateEntryDebugNode(Cm.BoundTree.BoundStatement& statement, const Span& span)
        {
        }
        public virtual void CreateExitDebugNode(Cm.BoundTree.BoundStatement& statement, const Span& span)
        {
        }
        public virtual void AddDebugNodeTransition(Cm.BoundTree.BoundStatement& fromStatement, Cm.BoundTree.BoundStatement& toStatement)
        {
        }
        public virtual void AddDebugNodeTransition(Cm.BoundTree.BoundExpression& fromExpression, Cm.BoundTree.BoundStatement& toStatement)
        {
        }
        public virtual void AddDebugNodeTransition(Cm.BoundTree.BoundExpression& fromExpression, Cm.BoundTree.BoundExpression& toExpression)
        {
        }
        public virtual Cm.Core.CFunctionDebugInfo* GetFunctionDebugInfo() const
        {
            return null;
        }
        public virtual int RetrievePrevDebugNodes()
        {
            return -1;
        }
        public virtual void AddToPrevDebugNodes(int debugNodeSetHandle)
        {
        }
        public virtual void AddToPrevDebugNodes(Cm.BoundTree.BoundStatement& statement)
        {
        }
        public virtual void AddToPrevDebugNodes(Cm.BoundTree.BoundExpression& expr)
        {
        }
        public virtual void AddToPrevDebugNodes(const HashSet<Cm.Core.CfgNode*>& nodeSet)
        {
        }
        public virtual void PatchPrevDebugNodes(Cm.BoundTree.BoundStatement& statement)
        {
        }
        public virtual void PatchDebugNodes(const HashSet<Cm.Core.CfgNode*>& nodeSet, Cm.Core.CfgNode* nextNode)
        {
        }
        public virtual void SetCfgNode(Cm.BoundTree.BoundStatement& fromStatement, Cm.BoundTree.BoundStatement& toStatement)
        {
        }
        public virtual void SetCallDebugInfoInfo(Ir.Intf.Instruction* callInst, Ir.Intf.Function* fun)
        {
        }
        public abstract void SetStringLiteralResult(Cm.Core.Emitter* emitter, Ir.Intf.Object* resultObject, Ir.Intf.Object* stringConstant, Ir.Intf.Object* stringObject);
        public abstract Ir.Intf.Object* MakeLocalVarIrObject(Cm.Sym.TypeSymbol* type, Ir.Intf.Object* source);
        public abstract void GenVirtualCall(Cm.Sym.FunctionSymbol* fun, Cm.Core.GenResult& memberFunctionResult);
        public abstract void DoNothing(Cm.Core.GenResult& genResult);
        public abstract void RegisterDestructor(Cm.Sym.MemberVariableSymbol* staticMemberVariableSymbol);
        public abstract Ir.Intf.LabelObject* CreateLandingPadLabel(int landingPadId);
        protected nothrow inline Cm.Core.Emitter* GetEmitter() const
        {
            return emitter.GetPtr();
        }
        protected nothrow inline Cm.Core.IrFunctionRepository& IrFunctionRepository()
        {
            return irFunctionRepository;
        }
        protected nothrow inline Cm.Core.StaticMemberVariableRepository& StaticMemberVariableRepository()
        {
            return staticMemberVariableRepository;
        }
        protected nothrow inline Cm.Core.GenFlags GenFlags() const
        {
            return genFlags;
        }
        protected nothrow inline Stack<SharedPtr<Cm.Core.GenResult>>& ResultStack() 
        {
            return resultStack;
        }
        protected nothrow inline Cm.Sym.TypeRepository& TypeRepository() 
        {
            return typeRepository;
        }
        protected nothrow inline Cm.Sym.ParameterSymbol* ThisParam()
        {
            return thisParam;
        }
        private void GenerateLandingPadCode()
        {
            const List<UniquePtr<Cm.BoundTree.LandingPad>>& landingPads = currentFunction->LandingPads();
            for (const UniquePtr<Cm.BoundTree.LandingPad>& landingPad : landingPads)
            {
                Ir.Intf.LabelObject* landingPadLabel = CreateLandingPadLabel(landingPad->Id());
                emitter->Own(landingPadLabel);
                emitter->SetGotoTargetLabel(landingPadLabel);
                SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
                result->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
                DoNothing(*result);
                for (const UniquePtr<Cm.BoundTree.BoundDestructionStatement>& destructionStatement : landingPad->DestructionStatements())
                {
                    destructionStatement->Accept(*this);
                }
                int jumpToCatchId = landingPad->JumpToCatchId();
                if (jumpToCatchId != -1)    // got handler to jump to...
                {
                    string continueLabelPrefix;
                    Cm.IrIntf.Backend backend = Cm.IrIntf.GetBackend();
                    if (backend == Cm.IrIntf.Backend.llvm)
                    {
                        continueLabelPrefix = "$C";
                    }
                    else if (backend == Cm.IrIntf.Backend.c)
                    {
                        continueLabelPrefix = "_C_";
                    }
                    Ir.Intf.LabelObject* catchIdLabel = Cm.IrIntf.CreateLabel(continueLabelPrefix + ToString(jumpToCatchId));
                    emitter->Own(catchIdLabel);
                    emitter->Emit(Cm.IrIntf.Br(catchIdLabel));
                }
                else    // no handler to jump to...
                {
                    if (currentFunction->FunctionSymbol()->CanThrow()) // propagate exception to caller
                    {
                        Ir.Intf.Object* exCodeParam = irFunctionRepository.GetExceptionCodeParam();
                        Ir.Intf.Object* exCodeVariable = localVariableIrObjectRepository.GetExceptionCodeVariable();
                        Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI32(), exCodeVariable, exCodeParam);
                    }
                    Cm.Sym.TypeSymbol* returnType = currentFunction->FunctionSymbol()->GetReturnType();
                    if (returnType == null || (returnType is Cm.Sym.VoidTypeSymbol*) || currentFunction->FunctionSymbol()->ReturnsClassObjectByValue())
                    {
                        emitter->Emit(Cm.IrIntf.Ret());
                    }
                    else
                    {
                        Ir.Intf.Object* retVal = returnType->IrType()->CreateDefaultValue();
                        emitter->Own(retVal);
                        emitter->Emit(Cm.IrIntf.Ret(retVal));
                    }
                }
            }
        }
        protected void GenJumpingBoolCode(Cm.Core.GenResult& result)
        {
            Ir.Intf.LabelObject* trueLabel = Cm.IrIntf.CreateLabel();
            emitter->Own(trueLabel);
            Ir.Intf.LabelObject* falseLabel = Cm.IrIntf.CreateLabel();
            emitter->Own(falseLabel);
            Ir.Intf.RegVar* flag = Cm.IrIntf.MakeTemporaryRegVar(Ir.Intf.Factory.Instance()->GetI1());
            emitter->Own(flag);
            Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI1(), result.MainObject(), flag);
            emitter->Emit(Cm.IrIntf.Br(flag, trueLabel, falseLabel));
            result.AddTrueTarget(trueLabel);
            result.AddFalseTarget(falseLabel);
            Cm.Core.ResetFlag(genFlags, Cm.Core.GenFlags.genJumpingBoolCode);
        }
        private void MakePlainValueResult(Cm.Sym.TypeSymbol* plainType, Cm.Core.GenResult& result)
        {
            Ir.Intf.Type* plainIrType = plainType->IrType();
            Ir.Intf.Object* plainObject = Cm.IrIntf.MakeTemporaryRegVar(plainIrType);
            emitter->Own(plainObject);
            Cm.IrIntf.Assign(*emitter, plainIrType, result.MainObject(), plainObject);
            result.SetMainObject(plainObject);
        }
        private void ExitCompound(Cm.Core.GenResult& result, const CompoundDestructionStack& compoundDestructionStack, bool& first)
        {
            int n = compoundDestructionStack.DestructionStatements().Count();
            for (int i = n - 1; i >= 0; --i)
            {
                const UniquePtr<Cm.BoundTree.BoundDestructionStatement>& boundDestructionStatement = compoundDestructionStack.DestructionStatements()[i];
                boundDestructionStatement->Accept(*this);
                SharedPtr<Cm.Core.GenResult> destructionResult = resultStack.Pop();
                if (first)
                {
                    first = false;
                    result.BackpatchNextTargets(destructionResult->GetLabel());
                    if (!result.LabelSet())
                    {
                        result.SetLabelSet();
                        result.SetLabel(destructionResult->GetLabel());
                    }
                }
            }
        }
        private void ExitCompounds(Cm.BoundTree.BoundCompoundStatement* fromCompound, Cm.BoundTree.BoundCompoundStatement* targetCompound, Cm.Core.GenResult& result)
        {
            bool first = true;
            const CompoundDestructionStack* compoundDestructionStack = &currentCompoundDestructionStack;
            Cm.BoundTree.BoundCompoundStatement* compound = fromCompound;
            int n = functionDestructionStack.CompoundDestructionStacks().Count();
            int i = n - 1;
            while (compound != null && compound != targetCompound)
            {
                ExitCompound(result, *compoundDestructionStack, first);
                compound = compound->CompoundParent();
                if (i < 0)
                {
                    throw Exception("runaway compound destruction stack");
                }
                compoundDestructionStack = &functionDestructionStack.CompoundDestructionStacks()[i];
                --i;
            }
        }
        private void ExitFunction(Cm.Core.GenResult& result)
        {
            bool first = true;
            ExitCompound(result,  currentCompoundDestructionStack, first);
            int n = functionDestructionStack.CompoundDestructionStacks().Count();
            for (int i = n - 1; i >= 0; --i)
            {
                const CompoundDestructionStack& compoundDestructionStack = functionDestructionStack.CompoundDestructionStacks()[i];
                ExitCompound(result, compoundDestructionStack, first);
            }
        }
        private void BackpatchNextTargets(Ir.Intf.LabelObject* label)
        {
            List<Ir.Intf.LabelObject*> nextTargets = nextTargetsStack.Pop();
            if (label != null)
            {
                Ir.Intf.Backpatch(nextTargets, label);
            }
            else
            {
                compoundResult->MergeTargets(compoundResult->NextTargets(), nextTargets);
            }
        }
        private void PushGenDebugInfo(bool generate)
        {
            generateDebugInfoStack.Push(generateDebugInfo);
            generateDebugInfo = generate;
        }
        private void PopGenDebugInfo()
        {
            generateDebugInfo = generateDebugInfoStack.Pop();
        }
        private void PushBreakTargetStatement(Cm.BoundTree.BoundStatement* statement)
        {
            breakTargetStatementStack.Push(breakTargetStatement);
            breakTargetStatement = statement;
        }
        private void PopBreakTargetStatement()
        {
            breakTargetStatement = breakTargetStatementStack.Pop();
        }
        private void PushContinueTargetStatement(Cm.BoundTree.BoundStatement* statement)
        {
            continueTargetStatementStack.Push(continueTargetStatement);
            continueTargetStatement = statement;
        }
        private void PopContinueTargetStatement()
        {
            continueTargetStatement = continueTargetStatementStack.Pop();
        }
        private void ClearCompoundDestructionStack(Cm.Core.GenResult& result)
        {
            bool first = true;
            while (!currentCompoundDestructionStack.IsEmpty())
            {
                UniquePtr<Cm.BoundTree.BoundDestructionStatement> boundDestructionStatement = currentCompoundDestructionStack.Pop();
                boundDestructionStatement->Accept(*this);
                SharedPtr<Cm.Core.GenResult> destructionResult = resultStack.Pop();
                if (first)
                {
                    first = false;
                    result.BackpatchNextTargets(destructionResult->GetLabel());
                    if (!result.LabelSet())
                    {
                        result.SetLabel(destructionResult->GetLabel());
                        result.SetLabelSet();
                    }
                }
            }
        }
        protected void GenerateCall(Cm.Sym.FunctionSymbol* fun, Cm.BoundTree.TraceCallInfo* traceCallInfo, Cm.Core.GenResult& result)
        {
            Cm.Ast.CompileUnitNode* thisUnit = currentFunction->FunctionSymbol()->CompileUnit();
            if (thisUnit != null)
            {
                Cm.Ast.CompileUnitNode* thatUnit = fun->CompileUnit();
                if (thatUnit != null)
                {
                    Cm.Core.CompileUnitMap* compileUnitMap = cast<Cm.Core.CompileUnitMap*>(Cm.Sym.GetCompileUnitMap());
                    Cm.BoundTree.BoundCompileUnit* thisBoundUnit = cast<Cm.BoundTree.BoundCompileUnit*>(compileUnitMap->GetBoundCompileUnit(thisUnit));
                    if (thisBoundUnit != null)
                    {
                        Cm.BoundTree.BoundCompileUnit* thatBoundUnit = cast<Cm.BoundTree.BoundCompileUnit*>(compileUnitMap->GetBoundCompileUnit(thatUnit));
                        if (thatBoundUnit != null && thatBoundUnit != thisBoundUnit)
                        {
                            thatBoundUnit->AddDependentUnit(thisBoundUnit);
                        }
                    }
                }
            }
            if (fun is Cm.Bind.ClassDelegateFromFunCtor*)
            {
                GenerateClassDelegateInitFromFun(cast<Cm.Bind.ClassDelegateFromFunCtor*>(fun), result);
            }
            else if (fun is Cm.Bind.ClassDelegateFromFunAssignment*)
            {
                GenerateClassDelegateAssignmentFromFun(cast<Cm.Bind.ClassDelegateFromFunAssignment*>(fun), result);
            }
            else if (fun is Cm.Core.BasicTypeOp*)
            {
                Cm.Core.BasicTypeOp* op = cast<Cm.Core.BasicTypeOp*>(fun);
                op->Generate(*emitter, result);
                if (op is Cm.Bind.PrimitiveArrayTypeDefaultConstructor*)
                {
                    externalFunctions.Insert(irFunctionRepository.GetMemSetFunction());
                }
                else  if ((op is Cm.Bind.PrimitiveArrayTypeCopyConstructor*) || (op is Cm.Bind.PrimitiveArrayTypeCopyAssignment*))
                {
                    externalFunctions.Insert(irFunctionRepository.GetMemCopyFunction());
                }
            }
            else
            {
                if (result.GenerateVirtualCall())
                {
                    Ir.Intf.Function* irFunction = irFunctionRepository.CreateIrFunction(fun);
                    externalFunctions.Insert(irFunction);
                    MapIrFunToFun(irFunction, fun);
                    GenerateVirtualCall(fun, traceCallInfo, result);
                }
                else
                {
                    Ir.Intf.Function* irFunction = irFunctionRepository.CreateIrFunction(fun);
                    externalFunctions.Insert(irFunction);
                    MapIrFunToFun(irFunction, fun);
                    GenerateCall(fun, irFunction, traceCallInfo, result, fun->IsConstructorOrDestructorSymbol());
                }
                bool boolResult = false;
                Cm.Sym.TypeSymbol* returnType = fun->GetReturnType();
                if (returnType != null)
                {
                    Cm.Sym.TypeSymbol* plainReturnType = typeRepository.MakePlainType(returnType);
                    boolResult = plainReturnType is Cm.Sym.BoolTypeSymbol*;
                }
                if (result.GenJumpingBoolCode() && boolResult)
                {
                    GenJumpingBoolCode(result);
                }
            }
        }
        protected void GenerateCall(Cm.Sym.FunctionSymbol* functionSymbol, Ir.Intf.Function* fun, Cm.BoundTree.TraceCallInfo* traceCallInfo, Cm.Core.GenResult& result, bool constructorOrDestructorCall)
        {
            if (traceCallInfo != null)
            {
                CallEnterFrame(traceCallInfo);
            }
            if (constructorOrDestructorCall)
            {
                Cm.Core.GenResult memberFunctionResult(emitter.GetPtr(), result.Flags());
                memberFunctionResult.SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
                for (Ir.Intf.Object* object : result.Objects())
                {
                    memberFunctionResult.AddObject(object);
                }
                if (functionSymbol != null && functionSymbol->CanThrow())
                {
                    memberFunctionResult.AddObject(localVariableIrObjectRepository.GetExceptionCodeVariable());
                }
                Ir.Intf.Instruction* callInst = Cm.IrIntf.Call(memberFunctionResult.MainObject(), fun, memberFunctionResult.Args());
                if (generateDebugInfo)
                {
                    SetCallDebugInfoInfo(callInst, fun);
                }
                emitter->Emit(callInst);
            }
            else
            {
                if (functionSymbol != null)
                {
                    CheckRvalueArrayCall(*emitter, functionSymbol, result);
                }
                if (functionSymbol != null && functionSymbol->CanThrow())
                {
                    Cm.Core.GenResult functionResult(emitter.GetPtr(), result.Flags());
                    for (Ir.Intf.Object* object : result.Objects())
                    {
                        functionResult.AddObject(object);
                    }
                    functionResult.AddObject(localVariableIrObjectRepository.GetExceptionCodeVariable());
                    Ir.Intf.Instruction* callInst = Cm.IrIntf.Call(functionResult.MainObject(), fun, functionResult.Args());
                    if (generateDebugInfo)
                    {
                        SetCallDebugInfoInfo(callInst, fun);
                    }
                    emitter->Emit(callInst);
                }
                else
                {
                    Ir.Intf.Instruction* callInst = Cm.IrIntf.Call(result.MainObject(), fun, result.Args());
                    if (endProfiledFunLabel != null)
                    {
                        callInst->SetLabel(endProfiledFunLabel);
                        endProfiledFunLabel = null;
                    }
                    if (generateDebugInfo)
                    {
                        SetCallDebugInfoInfo(callInst, fun);
                    }
                    emitter->Emit(callInst);
                }
            }
            if (traceCallInfo != null)
            {
                CallLeaveFrame(traceCallInfo);
            }
            if (functionSymbol != null && functionSymbol->CanThrow())
            {
                GenerateTestExceptionResult();
            }
            if (fun->IsDoNothingFunction())
            {
                externalFunctions.Insert(fun);
            }
        }
        private void GenerateVirtualCall(Cm.Sym.FunctionSymbol* fun, Cm.BoundTree.TraceCallInfo* traceCallInfo, Cm.Core.GenResult& result)
        {
            if (traceCallInfo != null)
            {
                CallEnterFrame(traceCallInfo);
            }
            Cm.Core.GenResult memberFunctionResult(emitter.GetPtr(), result.Flags());
            if (fun->IsConstructorOrDestructorSymbol())
            {
                memberFunctionResult.SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
            }
            for (Ir.Intf.Object* object : result.Objects())
            {
                memberFunctionResult.AddObject(object);
            }
            if (fun->CanThrow())
            {
                memberFunctionResult.AddObject(localVariableIrObjectRepository.GetExceptionCodeVariable());
            }
            GenVirtualCall(fun, memberFunctionResult);
            if (traceCallInfo != null)
            {
                CallLeaveFrame(traceCallInfo);
            }
            if (fun->CanThrow())
            {
                GenerateTestExceptionResult();
            }
        }
        private void GenerateClassDelegateInitFromFun(Cm.Bind.ClassDelegateFromFunCtor* ctor, Cm.Core.GenResult& result)
        {
            Cm.Sym.Symbol* objSymbol = ctor->ClassDelegateType()->GetContainerScope()->Lookup("obj");
            if (!(objSymbol is Cm.Sym.MemberVariableSymbol*))
            {
                throw Exception("member variable symbol expected");
            }
            Cm.Sym.MemberVariableSymbol* objMemberVarSymbol = cast<Cm.Sym.MemberVariableSymbol*>(objSymbol);
            UniquePtr<Cm.BoundTree.BoundMemberVariable> objMemberVar(new Cm.BoundTree.BoundMemberVariable(null, objMemberVarSymbol));
            Ir.Intf.Object* obj = irObjectRepository.MakeMemberVariableIrObject(objMemberVar.GetPtr(), result.MainObject());
            Cm.IrIntf.Init(*emitter, result.Arg1()->GetType(), result.Arg1(), obj);
            Cm.Sym.Symbol* dlgSymbol = ctor->ClassDelegateType()->GetContainerScope()->Lookup("dlg");
            if (!(dlgSymbol is Cm.Sym.MemberVariableSymbol*))
            {
                throw Exception("member variable symbol expected");
            }
            Cm.Sym.MemberVariableSymbol* dlgMemberVarSymbol = cast<Cm.Sym.MemberVariableSymbol*>(dlgSymbol);
            UniquePtr<Cm.BoundTree.BoundMemberVariable> dlgMemberVar(new Cm.BoundTree.BoundMemberVariable(null, dlgMemberVarSymbol));
            Ir.Intf.Object* dlg = irObjectRepository.MakeMemberVariableIrObject(dlgMemberVar.GetPtr(), result.MainObject());
            Ir.Intf.Type* funPtrIrType = irFunctionRepository.GetFunPtrIrType(ctor->FunctionSymbol());
            Ir.Intf.RegVar* delegatePtr = Cm.IrIntf.MakeTemporaryRegVar(ctor->DelegateType()->IrType());
            emitter->Own(delegatePtr);
            emitter->Emit(Cm.IrIntf.Bitcast(funPtrIrType, delegatePtr, result.Arg2(), ctor->DelegateType()->IrType()));
            Cm.IrIntf.Init(*emitter, ctor->DelegateType()->IrType(), delegatePtr, dlg);
        }
        private void GenerateClassDelegateAssignmentFromFun(Cm.Bind.ClassDelegateFromFunAssignment* assignment, Cm.Core.GenResult& result)
        {
            Cm.Sym.Symbol* objSymbol = assignment->ClassDelegateType()->GetContainerScope()->Lookup("obj");
            if (!(objSymbol is Cm.Sym.MemberVariableSymbol*))
            {
                throw Exception("member variable symbol expected");
            }
            Cm.Sym.MemberVariableSymbol* objMemberVarSymbol = cast<Cm.Sym.MemberVariableSymbol*>(objSymbol);
            UniquePtr<Cm.BoundTree.BoundMemberVariable> objMemberVar(new Cm.BoundTree.BoundMemberVariable(null, objMemberVarSymbol));
            Ir.Intf.Object* obj = irObjectRepository.MakeMemberVariableIrObject(objMemberVar.GetPtr(), result.MainObject());
            Cm.IrIntf.Assign(*emitter, result.Arg1()->GetType(), result.Arg1(), obj);
            Cm.Sym.Symbol* dlgSymbol = assignment->ClassDelegateType()->GetContainerScope()->Lookup("dlg");
            if (!(dlgSymbol is Cm.Sym.MemberVariableSymbol*))
            {
                throw Exception("member variable symbol expected");
            }
            Cm.Sym.MemberVariableSymbol* dlgMemberVarSymbol = cast<Cm.Sym.MemberVariableSymbol*>(dlgSymbol);
            UniquePtr<Cm.BoundTree.BoundMemberVariable> dlgMemberVar(new Cm.BoundTree.BoundMemberVariable(null, dlgMemberVarSymbol));
            Ir.Intf.Object* dlg = irObjectRepository.MakeMemberVariableIrObject(dlgMemberVar.GetPtr(), result.MainObject());
            Ir.Intf.Type* funPtrIrType = irFunctionRepository.GetFunPtrIrType(assignment->FunctionSymbol());
            Ir.Intf.RegVar* delegatePtr = Cm.IrIntf.MakeTemporaryRegVar(assignment->DelegateType()->IrType());
            emitter->Own(delegatePtr);
            emitter->Emit(Cm.IrIntf.Bitcast(funPtrIrType, delegatePtr, result.Arg2(), assignment->DelegateType()->IrType()));
            Cm.IrIntf.Assign(*emitter, assignment->DelegateType()->IrType(), delegatePtr, dlg);
        }
        private void CallEnterFrame(Cm.BoundTree.TraceCallInfo* traceCallInfo)
        {
            if (currentFunction->FunctionSymbol()->FullName() == "System.TracedFun.@constructor(System.TracedFun*, const char*, const char*, int)") return;
            if (currentFunction->FunctionSymbol()->FullName() == "System.TracedFun.@destructor(System.TracedFun*)") return;
            Ir.Intf.Function* enterFrameIrFun = irFunctionRepository.CreateIrFunction(enterFrameFun);
            externalFunctions.Insert(enterFrameIrFun);
            MapIrFunToFun(enterFrameIrFun, enterFrameFun);
            List<Ir.Intf.Object*> args;
            traceCallInfo->Fun()->Accept(*this);
            SharedPtr<Cm.Core.GenResult> funResult = resultStack.Pop();
            args.Add(funResult->MainObject());
            traceCallInfo->File()->Accept(*this);
            SharedPtr<Cm.Core.GenResult> fileResult = resultStack.Pop();
            args.Add(fileResult->MainObject());
            traceCallInfo->Line()->Accept(*this);
            SharedPtr<Cm.Core.GenResult> lineResult = resultStack.Pop();
            args.Add(lineResult->MainObject());
            Ir.Intf.Instruction* callInst = Cm.IrIntf.Call(null, enterFrameIrFun, args);
            emitter->Emit(callInst);
            if (Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.trace))
            {
                Ir.Intf.Function* enterTracedCallIrFun = irFunctionRepository.CreateIrFunction(enterTracedCallFun);
                externalFunctions.Insert(enterTracedCallIrFun);
                MapIrFunToFun(enterTracedCallIrFun, enterTracedCallFun);
                Ir.Intf.Instruction* enterTracedCallInst = Cm.IrIntf.Call(null, enterTracedCallIrFun, args);
                emitter->Emit(enterTracedCallInst);
            }
        }
        private void CallLeaveFrame(Cm.BoundTree.TraceCallInfo* traceCallInfo)
        {
            if (currentFunction->FunctionSymbol()->FullName() == "System.TracedFun.@constructor(System.TracedFun*, const char*, const char*, int)") return;
            if (currentFunction->FunctionSymbol()->FullName() == "System.TracedFun.@destructor(System.TracedFun*)") return;
            Ir.Intf.Function* leaveFrameIrFun = irFunctionRepository.CreateIrFunction(leaveFrameFun);
            List<Ir.Intf.Object*> args;
            externalFunctions.Insert(leaveFrameIrFun);
            MapIrFunToFun(leaveFrameIrFun, leaveFrameFun);
            Ir.Intf.Instruction* callInst = Cm.IrIntf.Call(null, leaveFrameIrFun, args);
            emitter->Emit(callInst);
            if (Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.trace))
            {
                Ir.Intf.Function* leaveTracedCallIrFun = irFunctionRepository.CreateIrFunction(leaveTracedCallFun);
                externalFunctions.Insert(leaveTracedCallIrFun);
                MapIrFunToFun(leaveTracedCallIrFun, leaveTracedCallFun);
                List<Ir.Intf.Object*> traceCallArgs;
                traceCallInfo->Fun()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> funResult = resultStack.Pop();
                traceCallArgs.Add(funResult->MainObject());
                traceCallInfo->File()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> fileResult = resultStack.Pop();
                traceCallArgs.Add(fileResult->MainObject());
                traceCallInfo->Line()->Accept(*this);
                SharedPtr<Cm.Core.GenResult> lineResult = resultStack.Pop();
                traceCallArgs.Add(lineResult->MainObject());
                Ir.Intf.Instruction* leaveTracedCallInst = Cm.IrIntf.Call(null, leaveTracedCallIrFun, traceCallArgs);
                emitter->Emit(leaveTracedCallInst);
            }
        }
        private void GenerateTestExceptionResult()
        {
            if (currentFunction->IsRealMainFunction()) return;  // in real main() exception code is tested explicitly after call to user$main()
            int landingPadId = currentFunction->GetNextLandingPadId();
            Cm.IrIntf.Backend backend = Cm.IrIntf.GetBackend();
            string labelPrefix;
            if (backend == Cm.IrIntf.Backend.llvm)
            {
                labelPrefix = "$P";
            }
            else if (backend == Cm.IrIntf.Backend.c)
            {
                labelPrefix = "_P_";
            }
            Ir.Intf.LabelObject* landingPadLabel = Cm.IrIntf.CreateLabel(labelPrefix + ToString(landingPadId));
            emitter->Own(landingPadLabel);
            Ir.Intf.LabelObject* nextLabel = Cm.IrIntf.CreateNextLocalLabel();
            emitter->Own(nextLabel);
            Ir.Intf.Object* exCodeVariable = localVariableIrObjectRepository.GetExceptionCodeVariable();
            Ir.Intf.RegVar* exCodeReg = Cm.IrIntf.MakeTemporaryRegVar(Ir.Intf.Factory.Instance()->GetI32());
            emitter->Own(exCodeReg);
            Cm.IrIntf.Assign(*emitter, Ir.Intf.Factory.Instance()->GetI32(), exCodeVariable, exCodeReg);
            Ir.Intf.RegVar* resultReg = Cm.IrIntf.MakeTemporaryRegVar(Ir.Intf.Factory.Instance()->GetI1());
            emitter->Own(resultReg);
            Ir.Intf.Object* zero = Ir.Intf.Factory.Instance()->GetI32()->CreateDefaultValue();
            emitter->Own(zero);
            emitter->Emit(Cm.IrIntf.ICmp(Ir.Intf.Factory.Instance()->GetI32(), resultReg, Ir.Intf.IConditionCode.ne, exCodeReg, zero));
            emitter->Emit(Cm.IrIntf.Br(resultReg, landingPadLabel, nextLabel));
            SharedPtr<Cm.Core.GenResult> result(new Cm.Core.GenResult(emitter.GetPtr(), genFlags));
            result->SetMainObject(typeRepository.GetType(Cm.Sym.TypeId(Cm.Sym.ShortBasicTypeId.voidId)), typeRepository);
            emitter->AddNextInstructionLabel(nextLabel);
            DoNothing(*result);
            CreateLandingPad(landingPadId);
        }
        private void CreateLandingPad(int landingPadId)
        {
            Cm.BoundTree.LandingPad* landingPad = new Cm.BoundTree.LandingPad(landingPadId, currentCatchId);
            int n = currentCompoundDestructionStack.DestructionStatements().Count();
            for (int i = n - 1; i >= 0; --i)
            {
                Cm.BoundTree.BoundDestructionStatement* destructionStatement = currentCompoundDestructionStack.DestructionStatements()[i].GetPtr();
                landingPad->AddDestructionStatement(new Cm.BoundTree.BoundDestructionStatement(destructionStatement->SyntaxNode(), destructionStatement->Object(), destructionStatement->Destructor()));
            }
            if (currentCatchId == -1)
            {
                int n = functionDestructionStack.CompoundDestructionStacks().Count();
                for (int i = n - 1; i >= 0; --i)
                {
                    const CompoundDestructionStack& compoundDestructionStack = functionDestructionStack.CompoundDestructionStacks()[i];
                    int m = compoundDestructionStack.DestructionStatements().Count();
                    for (int j = m - 1; j >= 0; --j)
                    {
                        Cm.BoundTree.BoundDestructionStatement* destructionStatement = compoundDestructionStack.DestructionStatements()[j].GetPtr();
                        landingPad->AddDestructionStatement(new Cm.BoundTree.BoundDestructionStatement(destructionStatement->SyntaxNode(), destructionStatement->Object(), destructionStatement->Destructor()));
                    }
                }
            }
            currentFunction->AddLandingPad(landingPad);
        }
        private void ExecutePostfixIncDecStatements(Cm.Core.GenResult& result)
        {
            if (executingPostfixIncDecStatements) return;
            if (!postfixIncDecStatements.IsEmpty())
            {
                executingPostfixIncDecStatements = true;
                for (const UniquePtr<Cm.BoundTree.BoundStatement>& statement : postfixIncDecStatements)
                {
                    statement->Accept(*this);
                    SharedPtr<Cm.Core.GenResult> statementResult = resultStack.Pop();
                    result.Merge(statementResult);
                }
                postfixIncDecStatements.Clear();
                executingPostfixIncDecStatements = false;
            }
        }
        private bool generateDebugInfo;
        private Stack<bool> generateDebugInfoStack;
        private UniquePtr<Cm.Core.Emitter> emitter;
        private CodeFormatter& codeFormatter;
        private Cm.Sym.TypeRepository& typeRepository;
        private Cm.Core.GenFlags genFlags;
        private SharedPtr<Cm.Core.GenResult> compoundResult;
        private Stack<SharedPtr<Cm.Core.GenResult>> compoundResultStack;
        private Stack<SharedPtr<Cm.Core.GenResult>> resultStack;
        private bool firstStatementInCompound;
        private Stack<bool> firstStatementInCompoundStack;
        private FunctionDestructionStack functionDestructionStack;
        private CompoundDestructionStack currentCompoundDestructionStack;
        private Cm.Core.IrFunctionRepository& irFunctionRepository;
        private Cm.Core.IrClassTypeRepository& irClassTypeRepository;
        private Cm.Core.StringRepository& stringRepository;
        private LocalVariableIrObjectRepository localVariableIrObjectRepository;
        private IrObjectRepository irObjectRepository;
        private Cm.Core.StaticMemberVariableRepository& staticMemberVariableRepository;
        private Cm.Core.ExternalConstantRepository& externalConstantRepository;
        private Cm.Ast.CompileUnitNode* currentCompileUnit;
        private Cm.BoundTree.BoundClass* currentClass;
        private Cm.BoundTree.BoundFunction* currentFunction;
        private bool profile;
        private uint fid;
        private Cm.Sym.ParameterSymbol* thisParam;
        private HashSet<string>& internalFunctionNames;
        private HashSet<Ir.Intf.Function*>& externalFunctions;
        private List<UniquePtr<Cm.BoundTree.BoundStatement>> postfixIncDecStatements;
        private Cm.BoundTree.BoundStatement* continueTargetStatement;
        private Stack<Cm.BoundTree.BoundStatement*> continueTargetStatementStack;
        private Cm.BoundTree.BoundStatement* breakTargetStatement;
        private Stack<Cm.BoundTree.BoundStatement*> breakTargetStatementStack;
        private bool executingPostfixIncDecStatements;
        private SwitchEmitState currentSwitchEmitState;
        private Stack<SwitchEmitState> switchEmitStateStack;
        private int currentCatchId;
        private Stack<int> catchIdStack;
        private Stack<HashMap<string, Pair<Ir.Intf.LabelObject*, Cm.BoundTree.BoundStatement*>>*> switchCaseConstantMapStack;
        private HashMap<string, Pair<Ir.Intf.LabelObject*, Cm.BoundTree.BoundStatement*>>* currentSwitchCaseConstantMap;
        private Ir.Intf.LabelObject* switchCaseLabel;
        private List<Ir.Intf.Object*> switchCaseConstants;
        private Cm.Sym.FunctionSymbol* enterFrameFun;
        private Cm.Sym.FunctionSymbol* leaveFrameFun;
        private Cm.Sym.FunctionSymbol* enterTracedCallFun;
        private Cm.Sym.FunctionSymbol* leaveTracedCallFun;
        private Stack<List<Ir.Intf.LabelObject*>> nextTargetsStack;
        private Ir.Intf.LabelObject* endProfiledFunLabel;
        private void* tpGraph;
    }
    
    internal void CheckRvalueArrayCall(Cm.Core.Emitter& emitter, Cm.Sym.FunctionSymbol* fun, Cm.Core.GenResult& result)
    {
        if (fun->GroupName() != "Rvalue") return;
        if (fun->Parameters().Count() != 1) return;
        Cm.Sym.ParameterSymbol* param = fun->Parameters()[0];
        if (!param->GetType()->IsArrayType()) return;
        if (result.Objects().Count() < 2) return;
        if (Cm.IrIntf.TypesEqual(result.Arg1()->GetType(), param->GetType()->IrType())) return;
        Ir.Intf.Object* temp = Cm.IrIntf.MakeTemporaryRegVar(param->GetType()->IrType());
        emitter.Own(temp);
        emitter.Emit(Cm.IrIntf.Bitcast(result.Arg1()->GetType(), temp, result.Arg1(), temp->GetType()));
        result.Objects()[1] = temp;
    }
}
