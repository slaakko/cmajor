/*========================================================================
    Copyright (c) 2012-2015 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;
using Span = System.Text.Parsing.Span;

namespace Cm.Sym
{
    public enum FunctionSymbolFlags : uint
    {
        none = 0u,
        constructorOrDestructorSymbol = 1u << 0u,
        memberFunctionSymbol = 1u << 1u,
        cdecl_ = 1u << 2u,
        virtual_ = 1u << 3u,
        abstract_ = 1u << 4u,
        override_ = 1u << 5u,
        virtuality = virtual_ | abstract_ | override_,
        nothrow_ = 1u << 6u,
        inline_ = 1u << 7u,
        replicated = 1u << 8u,
        suppressed = 1u << 9u,
        default_ = 1u << 10u,
        explicit_ = 1u << 11u,
        conversion = 1u << 12u,
        templateSpecialization = 1u << 13u,
        memberOfTemplateType = 1u << 14u,
        memberOfClassTemplate = 1u << 15u,
        arrayConstructor = 1u << 16u,
        arrayAssignment = 1u << 17u,
        new_ = 1u << 18u
    }
    
    public enum ConversionType : byte
    {
        explicit_, implicit
    }
    
    public enum ConversionRank : byte
    {
        exactMatch, promotion, conversion
    }
    
    public nothrow inline bool BetterConversionRank(ConversionRank left, ConversionRank right)
    {
        return left < right;
    }
    
    public class PersistentFunctionData
    {
        public ulong bodyPos;
        public ulong bodySize;
        public UniquePtr<Cm.Ast.Node> returnTypeExprNode;
        public UniquePtr<Cm.Ast.FunctionGroupIdNode> groupId;
        public UniquePtr<Cm.Ast.WhereConstraintNode> constraint;
        public Cm.Ast.Specifiers specifiers;
        public string cmlFilePath;
        public Cm.Ast.NodeList<Cm.Ast.Node> usingNodes;
        public UniquePtr<FileScope> functionFileScope;
        public ulong functionPos;
        public ulong functionSize;
        public UniquePtr<Cm.Ast.FunctionNode> functionNode;
    }
    
    public class FunctionSymbol : ContainerSymbol
    {
        public nothrow FunctionSymbol(const Span& span_, const string& name_) : 
            base(span_, name_), returnType(null), entrySymbol(null), returnValueSymbol(null), compileUnit(null), flags(FunctionSymbolFlags.none), vtblIndex(-1), mutexId(-1), 
            overriddenFunction(null), functionTemplate(null), classObjectResultIrParam(null)
        {
        }
        public nothrow override SymbolType GetSymbolType() const 
        {
            return SymbolType.functionSymbol;
        }
        public nothrow override const char* TypeString() const
        {
            return "function";
        }
        public nothrow override bool IsExportSymbol() const
        {
            if (IsFunctionTemplateSpecialization()) return false;
            if (Parent()->IsClassTemplateSymbol()) return false;
            if (Parent() is TemplateTypeSymbol*) return false;
            if (IsReplica()) return false;
            if (Source() == SymbolSource.project && GetGlobalFlag(GlobalFlags.optimize) && IsInline()) return true;
            return base->IsExportSymbol(); 
        }
        public nothrow void SetFlags(FunctionSymbolFlags flags_)
        {
            flags = flags_;
        }
        public inline nothrow const string& GroupName() const
        {
            return groupName;
        }
        public nothrow void SetGroupName(const string& groupName_)
        {
            groupName = groupName_;
        }
        public nothrow inline bool IsFunctionTemplateSpecialization() const 
        { 
            return GetFlag(FunctionSymbolFlags.templateSpecialization); 
        }
        public nothrow inline void SetFunctionTemplateSpecialization() 
        { 
            SetFlag(FunctionSymbolFlags.templateSpecialization); 
        }
        public nothrow inline bool IsConstructorOrDestructorSymbol() const
        {
            return GetFlag(FunctionSymbolFlags.constructorOrDestructorSymbol);
        }
        public nothrow inline void SetConstructorOrDestructorSymbol()
        {
            SetFlag(FunctionSymbolFlags.constructorOrDestructorSymbol);
        }
        public nothrow inline bool IsMemberFunctionSymbol() const
        {
            return GetFlag(FunctionSymbolFlags.memberFunctionSymbol);
        }
        public nothrow inline void SetMemberFunctionSymbol()
        {
            SetFlag(FunctionSymbolFlags.memberFunctionSymbol);
        }
        public nothrow inline bool IsCDecl() const
        {
            return GetFlag(FunctionSymbolFlags.cdecl_);
        }
        public nothrow inline void SetCDecl()
        {
            SetFlag(FunctionSymbolFlags.cdecl_);
        }
        public nothrow inline bool IsVirtual() const
        {
            return GetFlag(FunctionSymbolFlags.virtual_);
        }
        public nothrow inline void SetVirtual()
        {
            SetFlag(FunctionSymbolFlags.virtual_);
        }
        public nothrow inline bool IsAbstract() const
        {
            return GetFlag(FunctionSymbolFlags.abstract_);
        }
        public nothrow inline void SetAbstract()
        {
            SetFlag(FunctionSymbolFlags.abstract_);
        }
        public nothrow inline bool IsOverride() const
        {
            return GetFlag(FunctionSymbolFlags.override_);
        }
        public nothrow inline void SetOverride()
        {
            SetFlag(FunctionSymbolFlags.override_);
        }
        public nothrow inline bool IsVirtualAbstractOrOverride() const 
        { 
            return GetFlag(FunctionSymbolFlags.virtuality); 
        }
        public nothrow inline bool IsNothrow() const
        {
            return GetFlag(FunctionSymbolFlags.nothrow_);
        }
        public nothrow inline void SetNothrow()
        {
            SetFlag(FunctionSymbolFlags.nothrow_);
        }    
        public nothrow inline void ResetNothrow()
        {
            ResetFlag(FunctionSymbolFlags.nothrow_);
        }
        public nothrow inline bool CanThrow() const
        {
            return !IsCDecl() && !IsNothrow() && !IsDestructor();
        }
        public nothrow inline bool IsInline() const
        {
            return GetFlag(FunctionSymbolFlags.inline_);
        }
        public nothrow inline void SetInline()
        {
            SetFlag(FunctionSymbolFlags.inline_);
        }
        public nothrow inline bool IsReplicated() const
        {
            return GetFlag(FunctionSymbolFlags.replicated);
        }
        public nothrow inline void SetReplicated()
        {
            SetFlag(FunctionSymbolFlags.replicated);
        }
        public nothrow inline bool IsSuppressed() const
        {
            return GetFlag(FunctionSymbolFlags.suppressed);
        }
        public nothrow inline void SetSuppressed()
        {
            SetFlag(FunctionSymbolFlags.suppressed);
        }
        public nothrow inline bool IsDefault() const
        {
            return GetFlag(FunctionSymbolFlags.default_);
        }
        public nothrow inline void SetDefault()
        {
            SetFlag(FunctionSymbolFlags.default_);
        }
        public nothrow inline bool IsExplicit() const
        {
            return GetFlag(FunctionSymbolFlags.explicit_);
        }
        public nothrow inline void SetExplicit()
        {
            SetFlag(FunctionSymbolFlags.explicit_);
        }
        public nothrow inline bool IsMemberOfTemplateType() const
        {
            return GetFlag(FunctionSymbolFlags.memberOfTemplateType);
        }
        public nothrow inline void SetMemberOfTemplateType()
        {
            SetFlag(FunctionSymbolFlags.memberOfTemplateType);
        }
        public nothrow inline bool IsMemberOfClassTemplate() const
        {
            return GetFlag(FunctionSymbolFlags.memberOfClassTemplate);
        }
        public nothrow inline void SetMemberOfClassTemplate()
        {
            SetFlag(FunctionSymbolFlags.memberOfClassTemplate);
        }
        public nothrow inline bool IsArrayConstructor() const
        {
            return GetFlag(FunctionSymbolFlags.arrayConstructor);
        }
        public nothrow inline void SetArrayConstructor()
        {
            SetFlag(FunctionSymbolFlags.arrayConstructor);
        }
        public nothrow inline bool IsArrayAssignment() const
        {
            return GetFlag(FunctionSymbolFlags.arrayAssignment);
        }
        public nothrow inline void SetArrayAssignment()
        {
            SetFlag(FunctionSymbolFlags.arrayAssignment);
        }
        public nothrow inline bool IsNew() const
        {
            return GetFlag(FunctionSymbolFlags.new_);
        }
        public nothrow inline void SetNew()
        {
            SetFlag(FunctionSymbolFlags.new_);
        }
        public nothrow inline bool IsConstructor() const
        {
            return groupName == "@constructor" && !IsStatic();
        }
        public nothrow inline bool IsDefaultConstructor() const
        {
            return groupName == "@constructor" && !IsStatic() && parameters.Count() == 1;
        }
        public nothrow bool IsCopyConstructor() const
        {
            if (groupName == "@constructor" && !IsStatic() && parameters.Count() == 2)
            {
                TypeSymbol* firstParamType = parameters[0]->GetType();
                TypeSymbol* classType = firstParamType->GetBaseType();
                TypeSymbol* secondParamType = parameters[1]->GetType();
                if (secondParamType->IsConstReferenceType() && TypesEqual(secondParamType->GetBaseType(), classType))
                {
                    return true;
                }
            }
            return false;
        }
        public nothrow bool IsMoveConstructor() const
        {
            if (groupName == "@constructor" && !IsStatic() && parameters.Count() == 2)
            {
                TypeSymbol* firstParamType = parameters[0]->GetType();
                TypeSymbol* classType = firstParamType->GetBaseType();
                TypeSymbol* secondParamType = parameters[1]->GetType();
                if (secondParamType->IsRvalueRefType() && TypesEqual(secondParamType->GetBaseType(), classType))
                {
                    return true;
                }
            }
            return false;
        }
        public nothrow inline bool IsStaticConstructor() const
        {
            return groupName == "@static_constructor" && IsStatic() && parameters.IsEmpty();
        }
        public nothrow bool IsCopyAssignment() const
        {
            if (groupName == "operator=" && parameters.Count() == 2)
            {
                TypeSymbol* firstParamType = parameters[0]->GetType();
                TypeSymbol* classType = firstParamType->GetBaseType();
                TypeSymbol* secondParamType = parameters[1]->GetType();
                if (secondParamType->IsConstReferenceType() && TypesEqual(secondParamType->GetBaseType(), classType))
                {
                    return true;
                }
            }
            return false;
        }
        public nothrow bool IsMoveAssignment() const
        {
            if (groupName == "operator=" && parameters.Count() == 2)
            {
                TypeSymbol* firstParamType = parameters[0]->GetType();
                TypeSymbol* classType = firstParamType->GetBaseType();
                TypeSymbol* secondParamType = parameters[1]->GetType();
                if (secondParamType->IsRvalueRefType() && TypesEqual(secondParamType->GetBaseType(), classType))
                {
                    return true;
                }
            }
            return false;
        }
        public nothrow inline bool IsDestructor() const
        {
            return groupName == "@destructor" && parameters.Count() == 1;
        }
        public nothrow virtual bool IsConvertingConstructor() const
        {
            return IsConstructor() && GetFlag(FunctionSymbolFlags.conversion);
        }
        public nothrow inline void SetConvertingConstructor()
        {
            SetFlag(FunctionSymbolFlags.conversion);
        }
        public nothrow inline bool IsConversionFunction() const
        {
            return !IsConstructor() && GetFlag(FunctionSymbolFlags.conversion);
        }
        public nothrow inline void SetConversionFunction()
        {
            SetFlag(FunctionSymbolFlags.conversion);
        }
        public bool CheckIfConvertingConstructor() const
        {
            return IsConstructor() && parameters.Count() == 2 && !IsExplicit() && !IsStatic() && !IsCopyConstructor() && !IsMoveConstructor();
        }
        public nothrow inline bool IsFunctionTemplate() const 
        { 
            return !typeParameters.IsEmpty(); 
        }
        public nothrow inline int Arity() const
        {
            return parameters.Count();
        }
        public override void Read(Reader& reader)
        {
            base->Read(reader);
            flags = cast<FunctionSymbolFlags>(reader.GetBinaryReader().ReadUInt());
            groupName = reader.GetBinaryReader().ReadString();
            vtblIndex = reader.GetBinaryReader().ReadShort();
            bool justSymbol = JustSymbol();
            if (IsFunctionTemplate() && !justSymbol)
            {
                persistentFunctionData.Reset(new PersistentFunctionData());
                bool hasReturnTypeExpr = reader.GetBinaryReader().ReadBool();
                if (hasReturnTypeExpr)
                {
                    persistentFunctionData->returnTypeExprNode.Reset(reader.GetAstReader().ReadNode());
                }
                persistentFunctionData->specifiers = reader.GetAstReader().ReadSpecifiers();
                persistentFunctionData->groupId.Reset(reader.GetAstReader().ReadFunctionGroupIdNode());
                bool hasConstraint = reader.GetBinaryReader().ReadBool();
                if (hasConstraint)
                {
                    persistentFunctionData->constraint.Reset(reader.GetAstReader().ReadWhereConstraintNode());
                }
                bool hasUsingNodes = reader.GetBinaryReader().ReadBool();
                if (hasUsingNodes)
                {
                    persistentFunctionData->usingNodes.Read(reader.GetAstReader());
                }
                persistentFunctionData->bodySize = reader.GetBinaryReader().ReadULong();
                persistentFunctionData->bodyPos = reader.GetBinaryReader().Pos();
                persistentFunctionData->cmlFilePath = reader.GetBinaryReader().FileName();
                reader.GetBinaryReader().Skip(persistentFunctionData->bodySize);
            }
            else if (IsInline() && GetGlobalFlag(GlobalFlags.optimize) && !IsMemberOfClassTemplate() && !justSymbol)
            {
                persistentFunctionData.Reset(new PersistentFunctionData());
                bool hasUsingNodes = reader.GetBinaryReader().ReadBool();
                if (hasUsingNodes)
                {
                    persistentFunctionData->usingNodes.Read(reader.GetAstReader());
                }
                persistentFunctionData->functionSize = reader.GetBinaryReader().ReadULong();
                persistentFunctionData->functionPos = reader.GetBinaryReader().Pos();
                persistentFunctionData->cmlFilePath = reader.GetBinaryReader().FileName();
                reader.GetBinaryReader().Skip(persistentFunctionData->functionSize);
                bool hasReturnType = reader.GetBinaryReader().ReadBool();
                if (hasReturnType)
                {
                    reader.FetchTypeFor(this, 0);
                }
            }
            else
            {
                bool hasReturnType = reader.GetBinaryReader().ReadBool();
                if (hasReturnType)
                {
                    reader.FetchTypeFor(this, 0);
                }
            }
            int n = reader.GetBinaryReader().ReadInt();
            typeArguments.Resize(n);
            for (int i = 0; i < n; ++i)
            {
                reader.FetchTypeFor(this, i);
            }
        }
        public override void Write(Writer& writer)
        {
            bool justSymbol = false;
            if (IsFunctionTemplateSpecialization() || IsMemberOfTemplateType())
            {
                justSymbol = true;
                SetJustSymbol();
            }
            base->Write(writer);
            writer.GetBinaryWriter().Write(uint(flags));
            writer.GetBinaryWriter().Write(groupName);
            writer.GetBinaryWriter().Write(vtblIndex);
            if (IsFunctionTemplate() && !justSymbol)
            {
                SymbolTable& symbolTable = writer.GetSymbolTable();
                Cm.Ast.Node* node = symbolTable.GetNode(this);
                if (!(node is Cm.Ast.FunctionNode*))
                {
                    throw Exception("function node expected");
                }                
                Cm.Ast.FunctionNode* functionNode = cast<Cm.Ast.FunctionNode*>(node);
                bool hasReturnTypeExpr = functionNode->ReturnTypeExpr() != null;
                writer.GetBinaryWriter().Write(hasReturnTypeExpr);
                if (hasReturnTypeExpr)
                {
                    writer.GetAstWriter().Write(functionNode->ReturnTypeExpr());
                }
                writer.GetAstWriter().Write(functionNode->GetSpecifiers());
                writer.GetAstWriter().Write(functionNode->GroupId());
                bool hasConstraint = functionNode->Constraint() != null;
                writer.GetBinaryWriter().Write(hasConstraint);
                if (hasConstraint)
                {
                    writer.GetAstWriter().Write(functionNode->Constraint());
                }
                bool hasUsingNodes = true;
                if (persistentFunctionData.IsNull())
                {
                    hasUsingNodes = false;
                }
                writer.GetBinaryWriter().Write(hasUsingNodes);
                if (hasUsingNodes)
                {
                    persistentFunctionData->usingNodes.Write(writer.GetAstWriter());
                }
                if (functionNode->Body() == null)
                {
                    throw Exception("write: function node has no body");
                }
                ulong sizePos = writer.GetBinaryWriter().Pos();
                writer.GetBinaryWriter().Write(ulong(0u));
                ulong bodyPos = writer.GetBinaryWriter().Pos();
                writer.GetAstWriter().Write(functionNode->Body());
                ulong bodyEndPos = writer.GetBinaryWriter().Pos();
                ulong bodySize = bodyEndPos - bodyPos;
                writer.GetBinaryWriter().Seek(sizePos);
                writer.GetBinaryWriter().Write(bodySize);
                writer.GetBinaryWriter().Seek(bodyEndPos);
            }
            else if (IsInline() && GetGlobalFlag(GlobalFlags.optimize) && !IsMemberOfClassTemplate() && !justSymbol)
            {
                bool hasUsingNodes = true;
                if (persistentFunctionData.IsNull())
                {
                    hasUsingNodes = false;
                }
                writer.GetBinaryWriter().Write(hasUsingNodes);
                if (hasUsingNodes)
                {
                    persistentFunctionData->usingNodes.Write(writer.GetAstWriter());
                }
                SymbolTable& symbolTable = writer.GetSymbolTable();
                Cm.Ast.Node* node = symbolTable.GetNode(this);
                if (!(node is Cm.Ast.FunctionNode*))
                {
                    throw Exception("function node expected");
                }
                Cm.Ast.FunctionNode* functionNode = cast<Cm.Ast.FunctionNode*>(node);
                ulong sizePos = writer.GetBinaryWriter().Pos();
                writer.GetBinaryWriter().Write(ulong(0u));
                ulong functionPos = writer.GetBinaryWriter().Pos();
                writer.GetAstWriter().Write(functionNode);
                ulong functionEndPos = writer.GetBinaryWriter().Pos();
                ulong functionSize = functionEndPos - functionPos;
                writer.GetBinaryWriter().Seek(sizePos);
                writer.GetBinaryWriter().Write(functionSize);
                writer.GetBinaryWriter().Seek(functionEndPos);
                bool hasReturnType = returnType != null;
                writer.GetBinaryWriter().Write(hasReturnType);
                if (hasReturnType)
                {
                    writer.Write(returnType->Id());
                }
            }
            else
            {
                bool hasReturnType = returnType != null;
                writer.GetBinaryWriter().Write(hasReturnType);
                if (hasReturnType)
                {
                    writer.Write(returnType->Id());
                }
            }
            int n = typeArguments.Count();
            writer.GetBinaryWriter().Write(n);
            for (int i = 0; i < n; ++i)
            {
                TypeSymbol* typeArgument = typeArguments[i];
                writer.Write(typeArgument->Id());
            }
        }
        public override void AddSymbol(Symbol* symbol)
        {
            base->AddSymbol(symbol);
            if (symbol is ParameterSymbol*)
            {
                ParameterSymbol* parameterSymbol = cast<ParameterSymbol*>(symbol);
                parameters.Add(parameterSymbol);
            }
            else if (symbol is TypeParameterSymbol*)
            {
                TypeParameterSymbol* typeParameterSymbol = cast<TypeParameterSymbol*>(symbol);
                typeParameterSymbol->SetIndex(typeParameters.Count());
                typeParameters.Add(typeParameterSymbol);
            }
            else if (symbol is EntrySymbol*)
            {
                entrySymbol = cast<EntrySymbol*>(symbol);
            }
            else if (symbol is ReturnValueSymbol*)
            {
                returnValueSymbol = cast<ReturnValueSymbol*>(symbol);
            }
        }
        public nothrow inline void SetReturnType(TypeSymbol* returnType_)
        {
            returnType = returnType_;
        }
        public nothrow inline TypeSymbol* GetReturnType() const
        {
            return returnType;
        }
        public nothrow inline EntrySymbol* Entry() const
        {
            return entrySymbol;
        }
        public nothrow inline ReturnValueSymbol* ReturnValue()
        {
            return returnValueSymbol;
        }
        public override void SetType(TypeSymbol* type, int index) 
        {
            SetReturnType(type);
        }
        public nothrow inline short VtblIndex() const
        {
            return vtblIndex;
        }
        public nothrow inline void SetVtblIndex(short vtblIndex_)
        {
            vtblIndex = vtblIndex_;
        }
        public nothrow inline void SetOverriddenFunction(FunctionSymbol* overriddenFunction_)
        {
            overriddenFunction = overriddenFunction_;
        }
        public void AddToOverrideSet(FunctionSymbol* overrideFun)
        {
            overrideSet.Insert(overrideFun);
            if (overriddenFunction != null)
            {
                overriddenFunction->AddToOverrideSet(overrideFun);
            }
        }
        public nothrow inline const List<ParameterSymbol*>& Parameters() const
        {
            return parameters;
        }
        public nothrow inline const List<TypeParameterSymbol*>& TypeParameters() const
        {
            return typeParameters;
        }
        public void SetUsingNodes(const List<Cm.Ast.Node*>& usingNodes)
        {
            if (persistentFunctionData.IsNull())
            {
                persistentFunctionData.Reset(new PersistentFunctionData());
            }
            for (Cm.Ast.Node* usingNode : usingNodes)
            {
                Cm.Ast.CloneContext cloneContext;
                persistentFunctionData->usingNodes.Add(usingNode->Clone(cloneContext));
            }
        }
        public nothrow const Cm.Ast.NodeList<Cm.Ast.Node>& GetUsingNodes() const
        {
            return persistentFunctionData->usingNodes;
        }
        public nothrow Cm.Ast.Node* ReturnTypeExprNode() const
        {
            return persistentFunctionData->returnTypeExprNode.GetPtr();
        }
        public nothrow Cm.Ast.FunctionGroupIdNode* GroupId() const
        {
            return persistentFunctionData->groupId.GetPtr();
        }
        public nothrow bool HasConstraint() const
        {
            return !persistentFunctionData.IsNull() && !persistentFunctionData->constraint.IsNull();
        }
        public nothrow Cm.Ast.WhereConstraintNode* Constraint() const
        {
            return persistentFunctionData->constraint.GetPtr();
        }
        public nothrow inline ulong BodyPos() const
        {
            return persistentFunctionData->bodyPos;
        }
        public nothrow inline ulong BodySize() const
        {
            return persistentFunctionData->bodySize;
        }
        public nothrow inline Cm.Ast.Specifiers GetSpecifiers() const
        {
            return persistentFunctionData->specifiers;
        }
        public nothrow inline const string& CmlFilePath() const
        {
            return persistentFunctionData->cmlFilePath;
        }
        public nothrow inline Cm.Ast.CompileUnitNode* CompileUnit() const
        {
            return compileUnit;
        }
        public nothrow void SetCompileUnit(Cm.Ast.CompileUnitNode* compileUnit_)
        {
            compileUnit = compileUnit_;
        }
        public nothrow inline int MutexId() const
        {
            return mutexId;
        }
        public nothrow inline void SetMutexId(int mutexId_)
        {
            mutexId = mutexId_;
        }
        public TypeSymbol* SourceType() const
        {
            if (IsConvertingConstructor())
            {
                return parameters[1]->GetType()->GetBaseType();
            }
            else if (IsConversionFunction())
            {
                return parameters[1]->GetType()->GetBaseType();
            }
            else
            {
                throw Exception("converting constructor or conversion function exprected");
            }
        }
        public TypeSymbol* TargetType() const
        {
            if (IsConvertingConstructor())
            {
                return parameters[0]->GetType()->GetBaseType();
            }
            else if (IsConversionFunction())
            {
                return returnType;
            }
            else
            {
                throw Exception("converting constructor or conversion function exprected");
            }
        }
        public void ComputeName()
        {
            string s;
            if (IsConversionFunction())
            {
                groupName = "operator_" + GetReturnType()->FullName();
            }
            s.Append(groupName);
            if (!typeArguments.IsEmpty())
            {
                s.Append('<');
            }
            bool first = true;
            for (TypeSymbol* typeArgument : typeArguments)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    s.Append(", ");
                }
                s.Append(typeArgument->FullName());
            }
            s.Append('>');
            bool isConst = false;
            s.Append('(');
            first = true;
            for (ParameterSymbol* parameter : parameters)
            {
                if (first)
                {
                    first = false;
                    if (IsMemberFunctionSymbol())
                    {
                        if (parameter->GetType()->IsConstType())
                        {
                            isConst = true;
                        }
                    }
                }
                else
                {
                    s.Append(", ");
                }
                TypeSymbol* paramType = parameter->GetType();
                s.Append(paramType->FullName());
            }
            s.Append(')');
            if (isConst)
            {
                s.Append(" const");
            }
            SetName(s);
        }
        public nothrow virtual ConversionType GetConversionType() const 
        { 
            if (IsExplicit())
            {
                return Cm.Sym.ConversionType.explicit_;
            }
            return Cm.Sym.ConversionType.implicit;
        }        
        public nothrow virtual ConversionRank GetConversionRank() const 
        { 
            if (IsConvertingConstructor() || IsConversionFunction()) 
            {
                return ConversionRank.conversion;
            }
            else
            {
                return ConversionRank.exactMatch; 
            }
        }        
        public nothrow virtual int GetConversionDistance() const 
        { 
            if (IsConvertingConstructor() || IsConversionFunction())
            {
                return 100;
            }            
            return 0;
        }    
        public virtual Cm.Sym.TypeSymbol* GetTargetType() const
        {
            if (IsConvertingConstructor())
            {
                return parameters[0]->GetType()->GetBaseType();
            }
            else if (IsConversionFunction())
            {
                return returnType;
            }
            else
            {
                throw Error("not converting constructor or conversion function", GetSpan());
            }
        }
        public virtual Cm.Sym.TypeSymbol* GetSourceType() const
        {
            if (IsConvertingConstructor())
            {
                return parameters[1]->GetType()->GetBaseType();
            }
            else if (IsConversionFunction())
            {
                return parameters[0]->GetType()->GetBaseType();
            }
            else
            {
                throw Error("not converting constructor or conversion function", GetSpan());
            }
        }
        public nothrow override void ReplaceReplicaTypes()
        {
            if (IsFunctionTemplate()) return;
            base->ReplaceReplicaTypes();
            if (returnType != null && returnType->IsReplica() && (returnType is TemplateTypeSymbol*))
            {
                TemplateTypeSymbol* replica = cast<TemplateTypeSymbol*>(returnType);
                returnType = replica->GetPrimaryTemplateTypeSymbol();
            }
            int n = typeArguments.Count();
            for (int i = 0; i < n; ++i)
            {
                TypeSymbol* typeArgument = typeArguments[i];
                if (typeArgument->IsReplica() && (typeArgument is TemplateTypeSymbol*))
                {
                    TemplateTypeSymbol* replica = cast<TemplateTypeSymbol*>(typeArgument);
                    typeArguments[i] = replica->GetPrimaryTemplateTypeSymbol();
                }
            }
        }
        public nothrow inline bool GetFlag(FunctionSymbolFlags flag)
        {
            return (flags & flag) != FunctionSymbolFlags.none;
        }
        public nothrow inline void SetFlag(FunctionSymbolFlags flag)
        {
            flags = cast<FunctionSymbolFlags>(flags | flag);
        }
        public nothrow inline void ResetFlag(FunctionSymbolFlags flag)
        {
            flags = cast<FunctionSymbolFlags>(flags & ~flag);
        }
        public nothrow inline bool ReturnsClassObjectByValue() const
        {
            return returnType != null && (returnType is ClassTypeSymbol*);
        }
        public nothrow inline Ir.Intf.Parameter* ClassObjectResultIrParam() const
        {
            return classObjectResultIrParam;
        }
        public nothrow inline void SetClassObjectResultIrParam(Ir.Intf.Parameter* classObjectResultIrParam_)
        {
            classObjectResultIrParam = classObjectResultIrParam_;
        }
        public nothrow inline const List<TypeSymbol*>& TypeArguments() const
        {
            return typeArguments;
        }
        private FunctionSymbolFlags flags;
        private string groupName;
        private TypeSymbol* returnType;
        private EntrySymbol* entrySymbol;
        private ReturnValueSymbol* returnValueSymbol;
        private List<ParameterSymbol*> parameters;
        private List<TypeParameterSymbol*> typeParameters;
        private List<TypeSymbol*> typeArguments;
        private short vtblIndex;
        private Cm.Ast.CompileUnitNode* compileUnit;
        private int mutexId;
        private FunctionSymbol* overriddenFunction;
        private FunctionSymbol* functionTemplate;
        private HashSet<FunctionSymbol*> overrideSet;
        private Ir.Intf.Parameter* classObjectResultIrParam;
        private UniquePtr<PersistentFunctionData> persistentFunctionData;
    }
}
