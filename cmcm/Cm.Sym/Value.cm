/*========================================================================
    Copyright (c) 2012-2015 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;
using Span = System.Text.Parsing.Span;

namespace Cm.Sym
{
    public enum ValueType : byte
    {
        none, boolValue, charValue, sbyteValue, byteValue, shortValue, ushortValue, intValue, uintValue, longValue, ulongValue, floatValue, doubleValue, nullValue, stringValue, max
    }
    
    public concept ValueClass<T>
    {
        where Derived<T, Value>;
        typename T.OperandType;
        T();
        T(T.OperandType);
        T.OperandType T.GetValue();
    }
    
    public nothrow string ValueTypeStr(ValueType valueType)
    {
        switch (valueType)
        {
            case ValueType.none: return "";
            case ValueType.boolValue: return "bool";
            case ValueType.charValue: return "char";
            case ValueType.sbyteValue: return "sbyte";
            case ValueType.byteValue: return "byte";
            case ValueType.shortValue: return "short";
            case ValueType.ushortValue: return "ushort";
            case ValueType.intValue: return "int";
            case ValueType.uintValue: return "uint";
            case ValueType.longValue: return "long";
            case ValueType.ulongValue: return "ulong";
            case ValueType.floatValue: return "float";
            case ValueType.doubleValue: return "double";
            case ValueType.nullValue: return "@nullptrtype";
            case ValueType.stringValue: return "string";
        }
        return "";
    }
    
    internal class CommonTypeMap
    {
        static CommonTypeMap() : instance(new CommonTypeMap())
        {
        }
        public static nothrow CommonTypeMap& Instance()
        {
            return *instance;
        }
        public nothrow ValueType GetCommonType(ValueType left, ValueType right)
        {
            return commonTypeMap[cast<int>(left)][cast<int>(right)];
        }
        private CommonTypeMap()
        {
            commonTypeMap.Reserve(cast<int>(ValueType.max));
            
            List<ValueType> noneValues = None();
            commonTypeMap.Add(Rvalue(noneValues));
            
            List<ValueType> boolValues = None();
            boolValues[cast<int>(ValueType.boolValue)] = ValueType.boolValue;
            commonTypeMap.Add(Rvalue(boolValues));
            
            List<ValueType> charValues = None();
            charValues[cast<int>(ValueType.charValue)] = ValueType.charValue;
            commonTypeMap.Add(Rvalue(charValues));
            
            List<ValueType> sbyteValues = None();
            sbyteValues[cast<int>(ValueType.sbyteValue)] = ValueType.sbyteValue;
            sbyteValues[cast<int>(ValueType.byteValue)] = ValueType.shortValue;
            sbyteValues[cast<int>(ValueType.shortValue)] = ValueType.shortValue;
            sbyteValues[cast<int>(ValueType.ushortValue)] = ValueType.intValue;
            sbyteValues[cast<int>(ValueType.intValue)] = ValueType.intValue;
            sbyteValues[cast<int>(ValueType.uintValue)] = ValueType.longValue;
            sbyteValues[cast<int>(ValueType.longValue)] = ValueType.longValue;
            sbyteValues[cast<int>(ValueType.floatValue)] = ValueType.floatValue;
            sbyteValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(sbyteValues));

            List<ValueType> byteValues = None();
            byteValues[cast<int>(ValueType.sbyteValue)] = ValueType.shortValue;
            byteValues[cast<int>(ValueType.byteValue)] = ValueType.byteValue;
            byteValues[cast<int>(ValueType.shortValue)] = ValueType.shortValue;
            byteValues[cast<int>(ValueType.ushortValue)] = ValueType.ushortValue;
            byteValues[cast<int>(ValueType.intValue)] = ValueType.intValue;
            byteValues[cast<int>(ValueType.uintValue)] = ValueType.uintValue;
            byteValues[cast<int>(ValueType.longValue)] = ValueType.longValue;
            byteValues[cast<int>(ValueType.ulongValue)] = ValueType.ulongValue;
            byteValues[cast<int>(ValueType.floatValue)] = ValueType.floatValue;
            byteValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(byteValues));

            List<ValueType> shortValues = None();
            shortValues[cast<int>(ValueType.sbyteValue)] = ValueType.shortValue;
            shortValues[cast<int>(ValueType.byteValue)] = ValueType.shortValue;
            shortValues[cast<int>(ValueType.shortValue)] = ValueType.shortValue;
            shortValues[cast<int>(ValueType.ushortValue)] = ValueType.intValue;
            shortValues[cast<int>(ValueType.intValue)] = ValueType.intValue;
            shortValues[cast<int>(ValueType.uintValue)] = ValueType.longValue;
            shortValues[cast<int>(ValueType.longValue)] = ValueType.longValue;
            shortValues[cast<int>(ValueType.floatValue)] = ValueType.floatValue;
            shortValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(shortValues));

            List<ValueType> ushortValues = None();
            ushortValues[cast<int>(ValueType.sbyteValue)] = ValueType.intValue;
            ushortValues[cast<int>(ValueType.byteValue)] = ValueType.ushortValue;
            ushortValues[cast<int>(ValueType.shortValue)] = ValueType.intValue;
            ushortValues[cast<int>(ValueType.ushortValue)] = ValueType.ushortValue;
            ushortValues[cast<int>(ValueType.intValue)] = ValueType.intValue;
            ushortValues[cast<int>(ValueType.uintValue)] = ValueType.uintValue;
            ushortValues[cast<int>(ValueType.longValue)] = ValueType.longValue;
            ushortValues[cast<int>(ValueType.ulongValue)] = ValueType.ulongValue;
            ushortValues[cast<int>(ValueType.floatValue)] = ValueType.floatValue;
            ushortValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(ushortValues));

            List<ValueType> intValues = None();
            intValues[cast<int>(ValueType.sbyteValue)] = ValueType.intValue;
            intValues[cast<int>(ValueType.byteValue)] = ValueType.intValue;
            intValues[cast<int>(ValueType.shortValue)] = ValueType.intValue;
            intValues[cast<int>(ValueType.ushortValue)] = ValueType.intValue;
            intValues[cast<int>(ValueType.intValue)] = ValueType.intValue;
            intValues[cast<int>(ValueType.uintValue)] = ValueType.longValue;
            intValues[cast<int>(ValueType.longValue)] = ValueType.longValue;
            intValues[cast<int>(ValueType.floatValue)] = ValueType.floatValue;
            intValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(intValues));

            List<ValueType> uintValues = None();
            uintValues[cast<int>(ValueType.sbyteValue)] = ValueType.longValue;
            uintValues[cast<int>(ValueType.byteValue)] = ValueType.uintValue;
            uintValues[cast<int>(ValueType.shortValue)] = ValueType.longValue;
            uintValues[cast<int>(ValueType.ushortValue)] = ValueType.uintValue;
            uintValues[cast<int>(ValueType.intValue)] = ValueType.longValue;
            uintValues[cast<int>(ValueType.uintValue)] = ValueType.uintValue;
            uintValues[cast<int>(ValueType.longValue)] = ValueType.longValue;
            uintValues[cast<int>(ValueType.ulongValue)] = ValueType.ulongValue;
            uintValues[cast<int>(ValueType.floatValue)] = ValueType.floatValue;
            uintValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(uintValues));

            List<ValueType> longValues = None();
            longValues[cast<int>(ValueType.sbyteValue)] = ValueType.longValue;
            longValues[cast<int>(ValueType.byteValue)] = ValueType.longValue;
            longValues[cast<int>(ValueType.shortValue)] = ValueType.longValue;
            longValues[cast<int>(ValueType.ushortValue)] = ValueType.longValue;
            longValues[cast<int>(ValueType.intValue)] = ValueType.longValue;
            longValues[cast<int>(ValueType.uintValue)] = ValueType.longValue;
            longValues[cast<int>(ValueType.longValue)] = ValueType.longValue;
            longValues[cast<int>(ValueType.floatValue)] = ValueType.floatValue;
            longValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(longValues));
                        
            List<ValueType> ulongValues = None();
            ulongValues[cast<int>(ValueType.byteValue)] = ValueType.ulongValue;
            ulongValues[cast<int>(ValueType.ushortValue)] = ValueType.ulongValue;
            ulongValues[cast<int>(ValueType.uintValue)] = ValueType.ulongValue;
            ulongValues[cast<int>(ValueType.ulongValue)] = ValueType.ulongValue;
            ulongValues[cast<int>(ValueType.floatValue)] = ValueType.floatValue;
            ulongValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(ulongValues));

            List<ValueType> floatValues = None();
            floatValues[cast<int>(ValueType.sbyteValue)] = ValueType.floatValue;
            floatValues[cast<int>(ValueType.byteValue)] = ValueType.floatValue;
            floatValues[cast<int>(ValueType.shortValue)] = ValueType.floatValue;
            floatValues[cast<int>(ValueType.ushortValue)] = ValueType.floatValue;
            floatValues[cast<int>(ValueType.intValue)] = ValueType.floatValue;
            floatValues[cast<int>(ValueType.uintValue)] = ValueType.floatValue;
            floatValues[cast<int>(ValueType.longValue)] = ValueType.floatValue;
            floatValues[cast<int>(ValueType.ulongValue)] = ValueType.floatValue;
            floatValues[cast<int>(ValueType.floatValue)] = ValueType.floatValue;
            floatValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(floatValues));

            List<ValueType> doubleValues = None();
            doubleValues[cast<int>(ValueType.sbyteValue)] = ValueType.doubleValue;
            doubleValues[cast<int>(ValueType.byteValue)] = ValueType.doubleValue;
            doubleValues[cast<int>(ValueType.shortValue)] = ValueType.doubleValue;
            doubleValues[cast<int>(ValueType.ushortValue)] = ValueType.doubleValue;
            doubleValues[cast<int>(ValueType.intValue)] = ValueType.doubleValue;
            doubleValues[cast<int>(ValueType.uintValue)] = ValueType.doubleValue;
            doubleValues[cast<int>(ValueType.longValue)] = ValueType.doubleValue;
            doubleValues[cast<int>(ValueType.ulongValue)] = ValueType.doubleValue;
            doubleValues[cast<int>(ValueType.floatValue)] = ValueType.doubleValue;
            doubleValues[cast<int>(ValueType.doubleValue)] = ValueType.doubleValue;
            commonTypeMap.Add(Rvalue(doubleValues));

            List<ValueType> nullValues = None();
            nullValues[cast<int>(ValueType.nullValue)] = ValueType.nullValue;
            commonTypeMap.Add(Rvalue(nullValues));

            List<ValueType> stringValues = None();
            stringValues[cast<int>(ValueType.stringValue)] = ValueType.stringValue;
            commonTypeMap.Add(Rvalue(stringValues));
        }
        private List<ValueType> None()
        {
            List<ValueType> none;
            int n = cast<int>(ValueType.max);
            none.Reserve(n);
            for (int i = 0; i < n; ++i)
            {
                none.Add(ValueType.none);
            }
            return none;
        }
        private static UniquePtr<CommonTypeMap> instance;    
        private List<List<ValueType>> commonTypeMap;
    }
    
    public nothrow ValueType GetCommonType(ValueType left, ValueType right)
    {
        return CommonTypeMap.Instance().GetCommonType(left, right);
    }
    
    internal class ValueTypeMap
    {
        static ValueTypeMap() : instance(new ValueTypeMap())
        {
        }
        public nothrow static ValueTypeMap& Instance() 
        {
            return *instance;
        }
        private ValueTypeMap()
        {
            int n = SymbolType.maxSymbol;
            valueTypes.Reserve(n);
            for (int i = 0; i < n; ++i)
            {
                valueTypes.Add(ValueType.none);
            }
            valueTypes[cast<int>(SymbolType.boolSymbol)] = ValueType.boolValue;
            valueTypes[cast<int>(SymbolType.charSymbol)] = ValueType.charValue;
            valueTypes[cast<int>(SymbolType.sbyteSymbol)] = ValueType.sbyteValue;
            valueTypes[cast<int>(SymbolType.byteSymbol)] = ValueType.byteValue;
            valueTypes[cast<int>(SymbolType.shortSymbol)] = ValueType.shortValue;
            valueTypes[cast<int>(SymbolType.ushortSymbol)] = ValueType.ushortValue;
            valueTypes[cast<int>(SymbolType.intSymbol)] = ValueType.intValue;
            valueTypes[cast<int>(SymbolType.uintSymbol)] = ValueType.uintValue;
            valueTypes[cast<int>(SymbolType.longSymbol)] = ValueType.longValue;
            valueTypes[cast<int>(SymbolType.ulongSymbol)] = ValueType.ulongValue;
            valueTypes[cast<int>(SymbolType.floatSymbol)] = ValueType.floatValue;
            valueTypes[cast<int>(SymbolType.doubleSymbol)] = ValueType.doubleValue;
            valueTypes[cast<int>(SymbolType.nullptrSymbol)] = ValueType.nullValue;

        }
        public nothrow ValueType GetValueType(SymbolType symbolType) const
        {
            return valueTypes[cast<int>(symbolType)];
        }
        private static UniquePtr<ValueTypeMap> instance;
        private List<ValueType> valueTypes;
    }
    
    public nothrow ValueType GetValueTypeFor(SymbolType symbolType)
    {
        return ValueTypeMap.Instance().GetValueType(symbolType);
    }
    
    public abstract class Value
    {
        public virtual ~Value()
        {
        }
        public abstract nothrow ValueType GetValueType() const;
        public abstract nothrow Value* Clone() const;
        public virtual void Read(Cm.Ser.BinaryReader& reader)
        {
        }
        public virtual void Write(Cm.Ser.BinaryWriter& writer)
        {
        }
        public abstract Value* As(ValueType targetType, bool cast_, const Span& span_);
        public abstract Ir.Intf.Object* CreateIrObject() const;
        public virtual nothrow bool IsScopedValue() const 
        {
            return false;
        }
        public virtual nothrow string ToString() const
        {
            return "";
        }
    }
    
    public class BoolValue : Value
    {
        public typedef bool OperandType;
        
        public nothrow BoolValue() : value(false)
        {
        }
        public nothrow BoolValue(bool value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.boolValue;
        }
        public nothrow override Value* Clone() const
        {
            return new BoolValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadBool();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    return new BoolValue(value);
                }                
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    if (cast_)
                    {
                        return new ShortValue(cast<short>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    if (cast_)
                    {
                        return new IntValue(cast<int>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.uintValue:
                {
                    if (cast_)
                    {
                        return new UIntValue(cast<uint>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.longValue:
                {
                    if (cast_)
                    {
                        return new LongValue(cast<long>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ulongValue:
                {
                    if (cast_)
                    {
                        return new ULongValue(cast<ulong>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.floatValue:
                {
                    if (cast_)
                    {
                        return new FloatValue(cast<float>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.doubleValue:
                {
                    if (cast_)
                    {
                        return new DoubleValue(cast<double>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            if (value)
            {
                return Cm.IrIntf.True();
            }
            return Cm.IrIntf.False();
        }
        public nothrow inline bool GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            if (value) return "true";
            return "false";
        }
        private bool value;
    }

    public class CharValue : Value
    {
        public typedef char OperandType;
        
        public nothrow CharValue() : value('\0')
        {
        }
        public nothrow CharValue(char value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.charValue;
        }
        public nothrow override Value* Clone() const
        {
            return new CharValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadChar();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    return new CharValue(value);
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    if (cast_)
                    {
                        return new ShortValue(cast<short>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    if (cast_)
                    {
                        return new IntValue(cast<int>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.uintValue:
                {
                    if (cast_)
                    {
                        return new UIntValue(cast<uint>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.longValue:
                {
                    if (cast_)
                    {
                        return new LongValue(cast<long>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ulongValue:
                {
                    if (cast_)
                    {
                        return new ULongValue(cast<ulong>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.floatValue:
                {
                    if (cast_)
                    {
                        return new FloatValue(cast<float>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.doubleValue:
                {
                    if (cast_)
                    {
                        return new DoubleValue(cast<double>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeCharConstant(value);
        }
        public nothrow inline char GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return System.Text.MakeCharLiteral(value);
        }
        private char value;
    }    

    public class SByteValue : Value
    {
        public typedef sbyte OperandType;
        
        public nothrow SByteValue() : value(0)
        {
        }
        public nothrow SByteValue(sbyte value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.sbyteValue;
        }
        public nothrow override Value* Clone() const
        {
            return new SByteValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadSByte();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    return new SByteValue(value);
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    return new ShortValue(value);
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    return new IntValue(value);
                }
                case ValueType.uintValue:
                {
                    if (cast_)
                    {
                        return new UIntValue(cast<uint>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.longValue:
                {
                    return new LongValue(value);
                }
                case ValueType.ulongValue:
                {
                    if (cast_)
                    {
                        return new ULongValue(cast<ulong>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.floatValue:
                {
                    return new FloatValue(value);
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeI8Constant(value);
        }
        public nothrow inline sbyte GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private sbyte value;
    }    

    public class ByteValue : Value
    {
        public typedef byte OperandType;
        
        public nothrow ByteValue() : value(0u)
        {
        }
        public nothrow ByteValue(byte value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.byteValue;
        }
        public nothrow override Value* Clone() const
        {
            return new ByteValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadByte();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    return new ByteValue(value);
                }
                case ValueType.shortValue: 
                {
                    return new ShortValue(value);
                }
                case ValueType.ushortValue: 
                {
                    return new UShortValue(value);
                }
                case ValueType.intValue: 
                {
                    return new IntValue(value);
                }
                case ValueType.uintValue:
                {
                    return new UIntValue(value);
                }
                case ValueType.longValue:
                {
                    return new LongValue(value);
                }
                case ValueType.ulongValue:
                {
                    return new ULongValue(value);
                }
                case ValueType.floatValue:
                {
                    return new FloatValue(value);
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeUI8Constant(value);
        }
        public nothrow inline byte GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private byte value;
    }    
    
    public class ShortValue : Value
    {
        public typedef short OperandType;
        
        public nothrow ShortValue() : value(0)
        {
        }
        public nothrow ShortValue(short value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.shortValue;
        }
        public nothrow override Value* Clone() const
        {
            return new ShortValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadShort();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    return new ShortValue(value);
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    return new IntValue(value);
                }
                case ValueType.uintValue:
                {
                    if (cast_)
                    {
                        return new UIntValue(cast<uint>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.longValue:
                {
                    return new LongValue(value);
                }
                case ValueType.ulongValue:
                {
                    if (cast_)
                    {
                        return new ULongValue(cast<ulong>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.floatValue:
                {
                    return new FloatValue(value);
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeI16Constant(value);
        }
        public nothrow inline short GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private short value;
    }    

    public class UShortValue : Value
    {
        public typedef ushort OperandType;
        
        public nothrow UShortValue() : value(0u)
        {
        }
        public nothrow UShortValue(ushort value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.ushortValue;
        }
        public nothrow override Value* Clone() const
        {
            return new UShortValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadUShort();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    if (cast_)
                    {
                        return new ShortValue(cast<short>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ushortValue: 
                {
                    return new UShortValue(value);
                }
                case ValueType.intValue: 
                {
                    return new IntValue(value);
                }
                case ValueType.uintValue:
                {
                    return new UIntValue(value);
                }
                case ValueType.longValue:
                {
                    return new LongValue(value);
                }
                case ValueType.ulongValue:
                {
                    return new ULongValue(value);
                }
                case ValueType.floatValue:
                {
                    return new FloatValue(value);
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeUI16Constant(value);
        }
        public nothrow inline ushort GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private ushort value;
    }    

    public class IntValue : Value
    {
        public typedef int OperandType;
        
        public nothrow IntValue() : value(0)
        {
        }
        public nothrow IntValue(int value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.intValue;
        }
        public nothrow override Value* Clone() const
        {
            return new IntValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadInt();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    if (cast_)
                    {
                        return new ShortValue(cast<short>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    return new IntValue(value);
                }
                case ValueType.uintValue:
                {
                    if (cast_)
                    {
                        return new UIntValue(cast<uint>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.longValue:
                {
                    return new LongValue(value);
                }
                case ValueType.ulongValue:
                {
                    if (cast_)
                    {
                        return new ULongValue(cast<ulong>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.floatValue:
                {
                    return new FloatValue(value);
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeI32Constant(value);
        }
        public nothrow inline int GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private int value;
    } 

    public class UIntValue : Value
    {
        public typedef uint OperandType;
        
        public nothrow UIntValue() : value(0u)
        {
        }
        public nothrow UIntValue(uint value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.uintValue;
        }
        public nothrow override Value* Clone() const
        {
            return new UIntValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadUInt();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    if (cast_)
                    {
                        return new ShortValue(cast<short>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    if (cast_)
                    {
                        return new IntValue(cast<int>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.uintValue:
                {
                    return new UIntValue(value);
                }
                case ValueType.longValue:
                {
                    return new LongValue(value);
                }
                case ValueType.ulongValue:
                {
                    return new ULongValue(value);
                }
                case ValueType.floatValue:
                {
                    return new FloatValue(value);
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeUI32Constant(value);
        }
        public nothrow inline uint GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private uint value;
    }    

    public class LongValue : Value
    {
        public typedef long OperandType;
        
        public nothrow LongValue () : value(0)
        {
        }
        public nothrow LongValue(long value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.longValue;
        }
        public nothrow override Value* Clone() const
        {
            return new LongValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadLong();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    if (cast_)
                    {
                        return new ShortValue(cast<short>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    if (cast_)
                    {
                        return new IntValue(cast<int>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.uintValue:
                {
                    if (cast_)
                    {
                        return new UIntValue(cast<uint>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.longValue:
                {
                    return new LongValue(value);
                }
                case ValueType.ulongValue:
                {
                    if (cast_)
                    {
                        return new ULongValue(cast<ulong>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.floatValue:
                {
                    if (cast_)
                    {
                        return new FloatValue(cast<float>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeI64Constant(value);
        }
        public nothrow inline long GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private long value;
    } 

    public class ULongValue : Value
    {
        public typedef ulong OperandType;
        
        public nothrow ULongValue() : value(0u)
        {
        }
        public nothrow ULongValue(ulong value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.ulongValue;
        }
        public nothrow override Value* Clone() const
        {
            return new ULongValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadULong();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    if (cast_)
                    {
                        return new ShortValue(cast<short>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    if (cast_)
                    {
                        return new IntValue(cast<int>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.uintValue:
                {
                    if (cast_)
                    {
                        return new UIntValue(cast<uint>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.longValue:
                {
                    if (cast_)
                    {
                        return new LongValue(cast<long>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ulongValue:
                {
                    return new ULongValue(value);
                }
                case ValueType.floatValue:
                {
                    if (cast_)
                    {
                        return new FloatValue(cast<float>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeUI64Constant(value);
        }
        public nothrow inline ulong GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private ulong value;
    }    

    public class FloatValue : Value
    {
        public typedef float OperandType;
        
        public nothrow FloatValue() : value(0.0f)
        {
        }
        public nothrow FloatValue(float value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.floatValue;
        }
        public nothrow override Value* Clone() const
        {
            return new FloatValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadFloat();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    if (cast_)
                    {
                        return new ShortValue(cast<short>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    if (cast_)
                    {
                        return new IntValue(cast<int>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.uintValue:
                {
                    if (cast_)
                    {
                        return new UIntValue(cast<uint>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.longValue:
                {
                    if (cast_)
                    {
                        return new LongValue(cast<long>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ulongValue:
                {
                    if (cast_)
                    {
                        return new ULongValue(cast<ulong>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.floatValue:
                {
                    return new FloatValue(value);
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeFloatConstant(value);
        }
        public nothrow inline float GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private float value;
    }    

    public class DoubleValue : Value
    {
        public typedef double OperandType;
        
        public nothrow DoubleValue() : value(0.0)
        {
        }
        public nothrow DoubleValue(double value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.doubleValue;
        }
        public nothrow override Value* Clone() const
        {
            return new DoubleValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadDouble();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            switch (targetType)
            {
                case ValueType.boolValue: 
                {
                    if (cast_)
                    {
                        return new BoolValue(cast<bool>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.charValue:
                {
                    if (cast_)
                    {
                        return new CharValue(cast<char>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.sbyteValue: 
                {
                    if (cast_)
                    {
                        return new SByteValue(cast<sbyte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.byteValue: 
                {
                    if (cast_)
                    {
                        return new ByteValue(cast<byte>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.shortValue: 
                {
                    if (cast_)
                    {
                        return new ShortValue(cast<short>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ushortValue: 
                {
                    if (cast_)
                    {
                        return new UShortValue(cast<ushort>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.intValue: 
                {
                    if (cast_)
                    {
                        return new IntValue(cast<int>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.uintValue:
                {
                    if (cast_)
                    {
                        return new UIntValue(cast<uint>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.longValue:
                {
                    if (cast_)
                    {
                        return new LongValue(cast<long>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.ulongValue:
                {
                    if (cast_)
                    {
                        return new ULongValue(cast<ulong>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.floatValue:
                {
                    if (cast_)
                    {
                        return new FloatValue(cast<float>(value));
                    }
                    else
                    {
                        throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType) + " without a cast", span_);
                    }
                }
                case ValueType.doubleValue:
                {
                    return new DoubleValue(value);
                }
                default:
                {
                    throw Error("invalid conversion", span_);
                }
            }
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeDoubleConstant(value);
        }
        public nothrow inline double GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return ToString(value);
        }
        private double value;
    }
    
    public class NullValue : Value
    {
        typedef char OperandType; // dummy operand type to satisfy requirements of ValueClass
        
        public nothrow NullValue() : type(null)
        {
        }
        public nothrow NullValue(char dummy) // dummy constructor to satisfy requirements of ValueClass
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.nullValue;
        }
        public nothrow override Value* Clone() const
        {
            return new NullValue();
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType), span_);
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            Ir.Intf.Type* irType = null;
            if (type != null)
            {
                irType = type->IrType();
            }
            else
            {
                irType = Cm.IrIntf.Pointer(Ir.Intf.Factory.Instance()->GetI1(), 1u);
            }
            return Cm.IrIntf.MakeNull(irType);
        }
        public nothrow inline void SetType(TypeSymbol* type_)
        {
            type = type_;
        }
        public nothrow override string ToString() const
        {
            return "null";
        }
        public nothrow inline char GetValue() const // dummy GetValue() function to satisfy requirements of ValueClass
        {
            return '\0';
        }
        private TypeSymbol* type;
    }    
    
    public class StringValue : Value
    {
        typedef string OperandType;
        
        public nothrow StringValue() : value("")
        {
        }
        public nothrow StringValue(const string& value_) : value(value_)
        {
        }
        public nothrow override ValueType GetValueType() const
        {
            return ValueType.stringValue;
        }
        public nothrow override Value* Clone() const
        {
            return new StringValue(value);
        }
        public override void Read(Cm.Ser.BinaryReader& reader)
        {
            value = reader.ReadString();
        }
        public override void Write(Cm.Ser.BinaryWriter& writer)
        {
            writer.Write(value);
        }
        public override Value* As(ValueType targetType, bool cast_, const Span& span_) const
        {
            throw Error("cannot convert " + ValueTypeStr(GetValueType()) + " to " + ValueTypeStr(targetType), span_);
        }
        public override Ir.Intf.Object* CreateIrObject() const
        {
            return Cm.IrIntf.MakeStringConstant(value);
        }
        public nothrow inline const string& GetValue() const
        {
            return value;
        }
        public nothrow override string ToString() const
        {
            return System.Text.MakeStringLiteral(value);
        }
        private string value;
    }    
}
