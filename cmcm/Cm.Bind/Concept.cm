/*========================================================================
    Copyright (c) 2012-2015 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;

namespace Cm.Bind
{
    internal bool CheckConstraint(Cm.Sym.ContainerScope* containerScope, Cm.BoundTree.BoundCompileUnit& boundCompileUnit, Cm.Sym.FileScope* functionFileScope, Cm.Ast.WhereConstraintNode* constraint, 
        const List<Cm.Sym.TypeParameterSymbol*>& templateParameters, const List<Cm.Sym.TypeSymbol*>& templateArguments, Cm.Core.ConceptCheckError& exception)
    {
        bool result = false;
        try
        {
            Cm.Sym.ContainerScope constraintCheckScope;
            constraintCheckScope.SetParent(containerScope);
            int n = templateParameters.Count();
            if (n != templateArguments.Count())
            {
                throw Exception("wrong number of template arguments");
            }
            List<UniquePtr<Cm.Sym.BoundTypeParameterSymbol>> boundTypeParameters;
            Cm.Sym.TypeSymbol* firstTypeArgument = null;
            Cm.Sym.TypeSymbol* secondTypeArgument = null;
            for (int i = 0; i < n; ++i)
            {
                Cm.Sym.TypeParameterSymbol* templateParameter = templateParameters[i];
                Cm.Sym.TypeSymbol* templateArgument = templateArguments[i];
                if (i == 0)
                {
                    firstTypeArgument = templateArgument;
                }
                else if (i == 1)
                {
                    secondTypeArgument = templateArgument;
                }
                Cm.Sym.BoundTypeParameterSymbol* boundTypeParameter = new Cm.Sym.BoundTypeParameterSymbol(templateParameter->GetSpan(), templateParameter->Name());
                boundTypeParameter->SetType(templateArgument);
                boundTypeParameters.Add(UniquePtr<Cm.Sym.BoundTypeParameterSymbol>(boundTypeParameter));
                constraintCheckScope.Install(boundTypeParameter);
                result = true; // todo
            }
        }
        catch (Cm.Core.ConceptCheckError& ex)
        {
            exception = ex;
            result = false;
        }
        return result;
    }
    
    internal class ConstraintChecker : Cm.Ast.Visitor
    {
        public nothrow ConstraintChecker(Cm.Sym.TypeSymbol* firstTypeArgument_, Cm.Sym.TypeSymbol* secondTypeArgument_, Cm.Sym.ContainerScope* containerScope_, Cm.BoundTree.BoundCompileUnit& boundCompileUnit_,
            Cm.Sym.FileScope* functionFileScope_) : base(false, true), firstTypeArgument(firstTypeArgument_), secondTypeArgument(secondTypeArgument_), containerScope(containerScope_), 
            boundCompileUnit(boundCompileUnit_), functionFileScope(functionFileScope_), type(null), conceptGroup(null), lookupId(Cm.Sym.SymbolTypeSetId.lookupTypeAndConceptSymbols)
        {
        }
        private Cm.Sym.TypeSymbol* firstTypeArgument;
        private Cm.Sym.TypeSymbol* secondTypeArgument;
        private Cm.Sym.ContainerScope* containerScope;
        private Cm.BoundTree.BoundCompileUnit& boundCompileUnit;
        private Cm.Sym.FileScope* functionFileScope;
        private Stack<bool> constraintCheckStack;
        private Cm.Sym.TypeSymbol* type;
        private Cm.Sym.ConceptGroupSymbol* conceptGroup;
        private Cm.Sym.SymbolTypeSetId lookupId;
        private Stack<Cm.Sym.SymbolTypeSetId> lookupIdStack;
        
    }
}
