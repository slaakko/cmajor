/*========================================================================
    Copyright (c) 2012-2016 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;

namespace Cm.Bind
{
    public class Binder : Cm.Ast.Visitor
    {
        public nothrow Binder(Cm.BoundTree.BoundCompileUnit& boundCompileUnit_) : 
            base(true, false), boundCompileUnit(boundCompileUnit_), currentContainerScope(null), switchStatement(null)
        {
        }
        public override void BeginVisit(Cm.Ast.NamespaceNode& namespaceNode)
        {
            Cm.Sym.ContainerScope* containerScope = boundCompileUnit.SymbolTable().GetContainerScope(&namespaceNode);
            BeginContainerScope(containerScope);
        }
        public override void EndVisit(Cm.Ast.NamespaceNode& namespaceNode)
        {
            EndContainerScope();
        }
        public override void BeginVisit(Cm.Ast.ClassNode& classNode)
        {
            if (classNode.TemplateParameters().Count() > 0)
            {
                PushSkipContent(true);
            }
            else
            {
                Cm.Sym.ContainerScope* containerScope = boundCompileUnit.SymbolTable().GetContainerScope(&classNode);
                Cm.Sym.ClassTypeSymbol* classTypeSymbol = containerScope->Class();
                if (!boundCompileUnit.IsPrebindCompileUnit())
                {
                    AddClassTypeToIrClassTypeRepository(classTypeSymbol, boundCompileUnit, currentContainerScope);
                }
                boundClassStack.Push(Rvalue(boundClass));
                boundClass.Reset(new Cm.BoundTree.BoundClass(classTypeSymbol, &classNode));
                BeginContainerScope(containerScope);
            }
        }
        public override void EndVisit(Cm.Ast.ClassNode& classNode)
        {
            if (classNode.TemplateParameters().Count() > 0)
            {
                PopSkipContent();
            }
            else
            {
                EndContainerScope();
                Cm.Sym.ClassTypeSymbol* classTypeSymbol = boundClass->Symbol();
                if (!classTypeSymbol->HasUserDefinedDestructor())
                {
                    for (Cm.Sym.MemberVariableSymbol* memberVar : classTypeSymbol->MemberVariables())
                    {
                        if (!memberVar->GetType()->IsBound() && (memberVar->GetType() is Cm.Sym.TemplateTypeSymbol*))
                        {
                            Cm.Sym.TemplateTypeSymbol* templateTypeSymbol = cast<Cm.Sym.TemplateTypeSymbol*>(memberVar->GetType());
                            boundCompileUnit.ClassTemplateRepository().BindTemplateTypeSymbol(templateTypeSymbol, currentContainerScope, boundCompileUnit.FileScopes());
                        }
                    }
                    if (classTypeSymbol->DoGenerateDestructor())
                    {
                        Cm.Sym.FunctionSymbol* destructor = GenerateDestructorSymbol(boundCompileUnit.SymbolTable(), classNode.GetSpan(), classTypeSymbol, boundCompileUnit.SyntaxUnit());
                        destructor->SetPublic();
                        classTypeSymbol->AddSymbol(destructor);
                    }
                    if (classTypeSymbol->Destructor() != null)
                    {
                        GenerateDestructorImplementation(classNode.GetSpan(), classTypeSymbol, currentContainerScope, boundCompileUnit);
                    }
                }
                if (!classTypeSymbol->HasUserDefinedStaticConstructor())
                {
                    if (classTypeSymbol->StaticConstructor() != null)
                    {
                        GenerateStaticConstructorImplementation(boundClass.GetPtr(), currentContainerScope, classNode.GetSpan(), classTypeSymbol, boundCompileUnit);
                    }
                }
                boundCompileUnit.AddBoundNode(boundClass.Release());
                boundClass = Rvalue(boundClassStack.Pop());
            }
        }
        public override void BeginVisit(Cm.Ast.ConstructorNode& constructorNode)
        {
            if ((constructorNode.GetSpecifiers() & (Cm.Ast.Specifiers.default_ | Cm.Ast.Specifiers.suppress_)) == Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&constructorNode);
                BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&constructorNode));
                boundFunction.Reset(new Cm.BoundTree.BoundFunction(&constructorNode, functionSymbol));
            }
        }
        public override void EndVisit(Cm.Ast.ConstructorNode& constructorNode)
        {
            if ((constructorNode.GetSpecifiers() & Cm.Ast.Specifiers.default_) != Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&constructorNode);
                bool unique = !(boundClass->Symbol() is Cm.Sym.TemplateTypeSymbol*);
                GenerateSynthesizedFunctionImplementation(functionSymbol, constructorNode.GetSpan(), boundClass->Symbol(), currentContainerScope, boundCompileUnit, unique);
            }
            else if ((constructorNode.GetSpecifiers() & Cm.Ast.Specifiers.suppress_) == Cm.Ast.Specifiers.none)
            {
                CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
                if (boundFunction->Body() != null)
                {
                    GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                    bool callToThisInitializerGenerated = false;
                    GenerateClassInitStatement(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &constructorNode, 
                        callToThisInitializerGenerated);
                    if (boundClass->Symbol()->IsVirtual() && !callToThisInitializerGenerated)
                    {
                        GenerateInitVPtrStatement(boundClass->Symbol(), boundFunction.GetPtr());
                    }
                    if (!callToThisInitializerGenerated)
                    {
                        GenerateMemberVariableInitStatements(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &constructorNode);
                    }
                    boundClass->AddMember(boundFunction.Release());
                }
                EndContainerScope();
            }
        }
        public override void BeginVisit(Cm.Ast.DestructorNode& destructorNode)
        {
            if ((destructorNode.GetSpecifiers() & Cm.Ast.Specifiers.default_) == Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&destructorNode);
                BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&destructorNode));
                boundFunction.Reset(new Cm.BoundTree.BoundFunction(&destructorNode, functionSymbol));
            }
        }
        public override void EndVisit(Cm.Ast.DestructorNode& destructorNode)
        {
            if ((destructorNode.GetSpecifiers() & Cm.Ast.Specifiers.default_) == Cm.Ast.Specifiers.none)
            {
                CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
                if (boundFunction->Body() != null)
                {
                    GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                    if (boundClass->Symbol()->IsVirtual())
                    {
                        GenerateInitVPtrStatement(boundClass->Symbol(), boundFunction.GetPtr());
                    }
                    GenerateMemberVariableDestructionStatements(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &destructorNode);
                    GenerateBaseClassDestructionStatement(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &destructorNode);
                    boundClass->AddMember(boundFunction.Release());
                }
                EndContainerScope();
            }
        }
        public override void BeginVisit(Cm.Ast.MemberFunctionNode& memberFunctionNode)
        {
            if ((memberFunctionNode.GetSpecifiers() & (Cm.Ast.Specifiers.default_ | Cm.Ast.Specifiers.suppress_)) == Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&memberFunctionNode);
                BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&memberFunctionNode));
                boundFunction.Reset(new Cm.BoundTree.BoundFunction(&memberFunctionNode, functionSymbol));
                if (!functionSymbol->IsVirtualAbstractOrOverride() && !functionSymbol->IsNew())
                {
                    Cm.Sym.ClassTypeSymbol* ownerClass = boundClass->Symbol();
                    if (ownerClass != null && ownerClass->BaseClass() != null)
                    {
                        Cm.Sym.ClassTypeSymbol* baseClass = ownerClass->BaseClass();
                        for (Cm.Sym.FunctionSymbol* f : baseClass->Vtbl())
                        {
                            if (f != null && f->IsVirtualAbstractOrOverride())
                            {
                                if (Cm.Sym.Overrides(functionSymbol, f))
                                {
                                    string warningMessage = "function '" + functionSymbol->FullName() + "' hides base class virtual function '" + f->FullName() + "'. " +
                                        "To get rid of this warning declare the function either 'override' or 'new'.";
                                    Console.Out() << "warning: " << warningMessage << endl();
                                    Cm.Sym.Warning warning(Cm.Sym.CompileWarningCollection.Instance().GetCurrentProjectName(), warningMessage);
                                    warning.SetDefined(functionSymbol->GetSpan());
                                    warning.SetReferenced(f->GetSpan());
                                    Cm.Sym.CompileWarningCollection.Instance().AddWarning(warning);
                                }
                            }
                        }
                    }
                }
            }
        }
        public override void EndVisit(Cm.Ast.MemberFunctionNode& memberFunctionNode)
        {
            if ((memberFunctionNode.GetSpecifiers() & Cm.Ast.Specifiers.default_) != Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&memberFunctionNode);
                bool unique = !(boundClass->Symbol() is Cm.Sym.TemplateTypeSymbol*);
                GenerateSynthesizedFunctionImplementation(functionSymbol, memberFunctionNode.GetSpan(), boundClass->Symbol(), currentContainerScope, boundCompileUnit, unique);
            }
            else if ((memberFunctionNode.GetSpecifiers() & Cm.Ast.Specifiers.suppress_) == Cm.Ast.Specifiers.none)
            {
                if (!boundFunction->FunctionSymbol()->IsAbstract() && boundFunction->Body() != null)
                {
                    CheckFunctionReturnPaths(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol(), 
                        &memberFunctionNode);
                    CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
                    GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                    if (boundFunction->FunctionSymbol()->IsStatic() && boundClass->Symbol()->StaticConstructor() != null)
                    {
                        GenerateStaticConstructorCall(boundCompileUnit, boundFunction.GetPtr(), boundClass->Symbol(), &memberFunctionNode);
                    }
                    boundClass->AddMember(boundFunction.Release());
                }
                EndContainerScope();
            }
        }
        public override void BeginVisit(Cm.Ast.ConversionFunctionNode& conversionFunctionNode)
        {
            Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&conversionFunctionNode);
            BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&conversionFunctionNode));
            boundFunction.Reset(new Cm.BoundTree.BoundFunction(&conversionFunctionNode, functionSymbol));
        }
        public override void EndVisit(Cm.Ast.ConversionFunctionNode& conversionFunctionNode)
        {
            CheckFunctionReturnPaths(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol(),
                &conversionFunctionNode);
            CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
            if (boundFunction->Body() != null)
            {
                GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                boundClass->AddMember(boundFunction.Release());
            }
            EndContainerScope();
        }
        public override void BeginVisit(Cm.Ast.StaticConstructorNode& staticConstructorNode)
        {
            Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&staticConstructorNode);
            BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&staticConstructorNode));
            boundFunction.Reset(new Cm.BoundTree.BoundFunction(&staticConstructorNode, functionSymbol));
        }
        public override void EndVisit(Cm.Ast.StaticConstructorNode& staticConstructorNode)
        {
            if (boundFunction->Body() != null)
            {
                GenerateStaticInitStatement(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &staticConstructorNode);
                boundClass->AddMember(boundFunction.Release());
            }
            EndContainerScope();
        }
        public override void BeginVisit(Cm.Ast.FunctionNode& functionNode)
        {
            if (functionNode.TemplateParameters().Count() > 0)
            {
                PushSkipContent(true);
            }
            else
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&functionNode);
                BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&functionNode));
                boundFunction.Reset(new Cm.BoundTree.BoundFunction(&functionNode, functionSymbol));
            }
        }
        public override void EndVisit(Cm.Ast.FunctionNode& functionNode)
        {
            if (functionNode.TemplateParameters().Count() > 0)
            {
                PopSkipContent();
            }
            else 
            {
                CheckFunctionReturnPaths(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol(), 
                    &functionNode);
                CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
                GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                boundCompileUnit.AddBoundNode(boundFunction.Release());
                EndContainerScope();
            }
        }
        public override void BeginVisit(Cm.Ast.CompoundStatementNode& compoundStatementNode)
        {
            BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&compoundStatementNode));
            parentStack.Push(currentParent.Release());
            currentParent.Reset(new Cm.BoundTree.BoundCompoundStatement(&compoundStatementNode));
        }
        public override void EndVisit(Cm.Ast.CompoundStatementNode& compoundStatementNode)
        {
            Cm.BoundTree.BoundParentStatement* parent = parentStack.Pop();
            if (parent != null)
            {
                parent->AddStatement(currentParent.Release());
                currentParent.Reset(parent);
            }
            else
            {
                if (currentParent.GetPtr() is Cm.BoundTree.BoundCompoundStatement*)
                {
                    Cm.BoundTree.BoundCompoundStatement* compound = cast<Cm.BoundTree.BoundCompoundStatement*>(currentParent.Release());
                    boundFunction->SetBody(compound);
                }
                else
                {
                    throw Exception("current parent not compound statement");
                }
            }
            EndContainerScope();
        }
        public override void BeginVisit(Cm.Ast.ForStatementNode& forStatementNode)
        {
            parentStack.Push(currentParent.Release());
            currentParent.Reset(new Cm.BoundTree.BoundForStatement(&forStatementNode));
            BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&forStatementNode));
        }
        public override void EndVisit(Cm.Ast.ForStatementNode& forStatementNode)
        {
            Cm.BoundTree.BoundParentStatement* cp = currentParent.Release();
            if (cp is Cm.BoundTree.BoundForStatement*)
            {
                Cm.BoundTree.BoundForStatement* forStatement = cast<Cm.BoundTree.BoundForStatement*>(cp);
                ForStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), forStatement);
                forStatementNode.Accept(binder);
                Cm.BoundTree.BoundParentStatement* parent = parentStack.Pop();
                if (parent != null)
                {
                    parent->AddStatement(forStatement);
                    currentParent.Reset(parent);
                }
                else
                {
                    throw Exception("no parent");
                }
            }
            else
            {
                throw Exception("for statement expected");
            }
            EndContainerScope();
        }
        public override void BeginVisit(Cm.Ast.RangeForStatementNode& rangeForStatementNode)
        {
            RangeForStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), *this);
            rangeForStatementNode.Accept(binder);
        }
        public override void BeginVisit(Cm.Ast.ReturnStatementNode& returnStatementNode)
        {
            ReturnStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr());
            returnStatementNode.Accept(binder);
            currentParent->AddStatement(binder.Result());
        }
        public override void BeginVisit(Cm.Ast.ConditionalStatementNode& conditionalStatementNode)
        {
            parentStack.Push(currentParent.Release());
            currentParent.Reset(new Cm.BoundTree.BoundConditionalStatement(&conditionalStatementNode));
        }
        public override void EndVisit(Cm.Ast.ConditionalStatementNode& conditionalStatementNode)
        {
            Cm.BoundTree.BoundParentStatement* cp = currentParent.Release();
            if (cp is Cm.BoundTree.BoundConditionalStatement*)
            {
                Cm.BoundTree.BoundConditionalStatement* conditionalStatement = cast<Cm.BoundTree.BoundConditionalStatement*>(cp);
                ConditionalStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), conditionalStatement);
                conditionalStatementNode.Accept(binder);
                Cm.BoundTree.BoundParentStatement* parent = parentStack.Pop();
                if (parent != null)
                {
                    parent->AddStatement(conditionalStatement);
                    currentParent.Reset(parent);
                }
                else
                {
                    throw Exception("no parent");
                }
            }
            else
            {
                throw Exception("conditional statement expected");
            }
        }
        public override void BeginVisit(Cm.Ast.SwitchStatementNode& switchStatementNode)
        {
            parentStack.Push(currentParent.Release());
            switchStatementStack.Push(switchStatement);
            switchStatement = new Cm.BoundTree.BoundSwitchStatement(&switchStatementNode);
            SwitchStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), switchStatement);
            switchStatementNode.Accept(binder);
            currentParent.Reset(switchStatement);
        }
        public override void EndVisit(Cm.Ast.SwitchStatementNode& switchStatementNode)
        {
            Cm.BoundTree.BoundParentStatement* cp = currentParent.Release();
            if (cp is Cm.BoundTree.BoundSwitchStatement*)
            {
                Cm.BoundTree.BoundSwitchStatement* switchStatement = cast<Cm.BoundTree.BoundSwitchStatement*>(cp);
                Cm.BoundTree.BoundParentStatement* parent = parentStack.Pop();
                if (parent != null)
                {
                    parent->AddStatement(switchStatement);
                    currentParent.Reset(parent);
                }
                else
                {
                    throw Exception("no parent");
                }
            }
            else
            {
                throw Exception("switch statement expected");
            }
            switchStatement = switchStatementStack.Pop();
        }
        public override void BeginVisit(Cm.Ast.CaseStatementNode& caseStatementNode)
        {
            parentStack.Push(currentParent.Release());
            currentParent.Reset(new Cm.BoundTree.BoundCaseStatement(&caseStatementNode));
        }
        public override void EndVisit(Cm.Ast.CaseStatementNode& caseStatementNode)
        {
            Cm.BoundTree.BoundParentStatement* cp = currentParent.Release();
            if (cp is Cm.BoundTree.BoundCaseStatement*)
            {
                Cm.BoundTree.BoundCaseStatement* caseStatement = cast<Cm.BoundTree.BoundCaseStatement*>(cp);
                CaseStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), caseStatement, switchStatement);
                caseStatementNode.Accept(binder);
                Cm.BoundTree.BoundParentStatement* parent = parentStack.Pop();
                if (parent != null)
                {
                    parent->AddStatement(caseStatement);
                    currentParent.Reset(parent);
                }
                else
                {
                    throw Exception("no parent");
                }
            }
            else
            {
                throw Exception("case statement expected");
            }
        }
        public override void BeginVisit(Cm.Ast.DefaultStatementNode& defaultStatementNode)
        {
            parentStack.Push(currentParent.Release());
            currentParent.Reset(new Cm.BoundTree.BoundDefaultStatement(&defaultStatementNode));
        }
        public override void EndVisit(Cm.Ast.DefaultStatementNode& defaultStatementNode)
        {
            Cm.BoundTree.BoundParentStatement* cp = currentParent.Release();
            if (cp is Cm.BoundTree.BoundDefaultStatement*)
            {
                Cm.BoundTree.BoundDefaultStatement* defaultStatement = cast<Cm.BoundTree.BoundDefaultStatement*>(cp);
                DefaultStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), defaultStatement);
                defaultStatementNode.Accept(binder);
                Cm.BoundTree.BoundParentStatement* parent = parentStack.Pop();
                if (parent != null)
                {
                    parent->AddStatement(defaultStatement);
                    currentParent.Reset(parent);
                }
                else
                {
                    throw Exception("no parent");
                }
            }
            else
            {
                throw Exception("default statement expected");
            }        
        }
        public override void EndVisit(Cm.Ast.GotoCaseStatementNode& gotoCaseStatementNode)
        {
            GotoCaseStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), switchStatement);
            gotoCaseStatementNode.Accept(binder);
            AddBoundStatement(binder.Result());
        }
        public override void Visit(Cm.Ast.GotoDefaultStatementNode& gotoDefaultStatementNode)
        {
            GotoDefaultStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr());
            gotoDefaultStatementNode.Accept(binder);
            AddBoundStatement(binder.Result());
        }
        public override void BeginVisit(Cm.Ast.WhileStatementNode& whileStatementNode)
        {
            parentStack.Push(currentParent.Release());
            currentParent.Reset(new Cm.BoundTree.BoundWhileStatement(&whileStatementNode));
        }
        public override void EndVisit(Cm.Ast.WhileStatementNode& whileStatementNode)
        {
            Cm.BoundTree.BoundParentStatement* cp = currentParent.Release();
            if (cp is Cm.BoundTree.BoundWhileStatement*)
            {
                Cm.BoundTree.BoundWhileStatement* whileStatement = cast<Cm.BoundTree.BoundWhileStatement*>(cp);
                WhileStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), whileStatement);
                whileStatementNode.Accept(binder);
                Cm.BoundTree.BoundParentStatement* parent = parentStack.Pop();
                if (parent != null)
                {
                    parent->AddStatement(whileStatement);
                    currentParent.Reset(parent);
                }
                else
                {
                    throw Exception("no parent");
                }
            }
            else
            {
                throw Exception("while statement expected");
            }
        }
        public override void BeginVisit(Cm.Ast.DoStatementNode& doStatementNode)
        {
            parentStack.Push(currentParent.Release());
            currentParent.Reset(new Cm.BoundTree.BoundDoStatement(&doStatementNode));
        }
        public override void EndVisit(Cm.Ast.DoStatementNode& doStatementNode)
        {
            Cm.BoundTree.BoundParentStatement* cp = currentParent.Release();
            if (cp is Cm.BoundTree.BoundDoStatement*)
            {
                Cm.BoundTree.BoundDoStatement* doStatement = cast<Cm.BoundTree.BoundDoStatement*>(cp);
                DoStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), doStatement);
                doStatementNode.Accept(binder);
                Cm.BoundTree.BoundParentStatement* parent = parentStack.Pop();
                if (parent != null)
                {
                    parent->AddStatement(doStatement);
                    currentParent.Reset(parent);
                }
                else
                {
                    throw Exception("no parent");
                }
            }
            else
            {
                throw Exception("do statement expected");
            }    
        }
        public override void Visit(Cm.Ast.BreakStatementNode& breakStatementNode)
        {
            BreakStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr());
            breakStatementNode.Accept(binder);
            AddBoundStatement(binder.Result());
        }
        public override void Visit(Cm.Ast.ContinueStatementNode& continueStatementNode)
        {
            ContinueStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr());
            continueStatementNode.Accept(binder);
            AddBoundStatement(binder.Result());
        }
        public override void Visit(Cm.Ast.GotoStatementNode& gotoStatementNode)
        {
            boundFunction->SetHasGotos();
            boundCompileUnit.SetHasGotos();
            Cm.BoundTree.BoundGotoStatement* boundGotoStatement = new Cm.BoundTree.BoundGotoStatement(&gotoStatementNode, gotoStatementNode.Target()->Label());
            if (gotoStatementNode.IsExceptionHandlingGoto())
            {
                boundGotoStatement->SetExceptionHandlingGoto();
            }
            AddBoundStatement(boundGotoStatement);
        }
        public override void BeginVisit(Cm.Ast.SimpleStatementNode& simpleStatementNode)
        {
            SimpleStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), *this);
            simpleStatementNode.Accept(binder);
            if (binder.Result() != null)
            {
                AddBoundStatement(binder.Result());
            }
        }
        public override void BeginVisit(Cm.Ast.AssignmentStatementNode& assignmentStatementNode)
        {
            AssignmentStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr());
            assignmentStatementNode.Accept(binder);
            AddBoundStatement(binder.Result());
        }
        public override void BeginVisit(Cm.Ast.ConstructionStatementNode& constructionStatementNode)
        {
            ConstructionStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr());
            constructionStatementNode.Accept(binder);
            AddBoundStatement(binder.Result());
        }
        public override void BeginVisit(Cm.Ast.DeleteStatementNode& deleteStatementNode)
        {
            DeleteStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr());
            deleteStatementNode.Accept(binder);
            if (binder.Result() != null)
            {
                AddBoundStatement(binder.Result());
            }            
            Cm.BoundTree.BoundStatement* freeStatement = binder.FreeStatement();
            AddBoundStatement(freeStatement);
        }
        public override void BeginVisit(Cm.Ast.DestroyStatementNode& destroyStatementNode)
        {
            DestroyStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr());
            destroyStatementNode.Accept(binder);
            if (binder.Result() != null)
            {
                AddBoundStatement(binder.Result());
            }
        }
        public override void BeginVisit(Cm.Ast.ThrowStatementNode& throwStatementNode)
        {
            ThrowStatementBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), *this);
            throwStatementNode.Accept(binder);
        }
        public override void Visit(Cm.Ast.TryStatementNode& tryStatementNode)
        {
            TryBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), *this);
            tryStatementNode.Accept(binder);
        }
        public override void Visit(Cm.Ast.CatchNode& catchNode)
        {
            CatchBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), *this);
            catchNode.Accept(binder);
        }
        public override void Visit(Cm.Ast.ExitTryStatementNode& exitTryStatementNode)
        {
            ExitTryBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), *this);
            exitTryStatementNode.Accept(binder);
        }
        public override void Visit(Cm.Ast.BeginCatchStatementNode& beginCatchStatementNode)
        {
            AddBoundStatement(new Cm.BoundTree.BoundBeginCatchStatement(&beginCatchStatementNode));
        }
        public override void Visit(Cm.Ast.AssertStatementNode& assertStatementNode)
        {
            if (Cm.Core.GetConfig() == "debug")
            {
                AssertBinder binder(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr());
                assertStatementNode.Accept(binder);
                AddBoundStatement(binder.Result());
            }
        }
        public override void EndVisit(Cm.Ast.CondCompDisjunctionNode& condCompDisjunctionNode)
        {
            bool right = PopCondCompValue();
            bool left = PopCondCompValue();
            bool value = left || right;
            PushCondCompValue(value);
        }
        public override void EndVisit(Cm.Ast.CondCompConjunctionNode& condCompConjunctionNode)
        {
            bool right = PopCondCompValue();
            bool left = PopCondCompValue();
            bool value = left && right;
            PushCondCompValue(value);
        }
        public override void EndVisit(Cm.Ast.CondCompNotNode& condCompNotNode)
        {
            bool value = PopCondCompValue();
            PushCondCompValue(!value);
        }
        public override void Visit(Cm.Ast.CondCompPrimaryNode& condCompPrimaryNode)
        {
            bool defined = Cm.Sym.IsSymbolDefined(condCompPrimaryNode.Symbol()->Str());
            PushCondCompValue(defined);
        }
        public override void Visit(Cm.Ast.CondCompStatementNode& condCompStatementNode)
        {
            if (!condCompilationEvaluationStack.IsEmpty())
            {
                throw Exception("conditional compilation evaluation stack is not empty");
            }
            Cm.Ast.CondCompPartNode* ifPartNode = condCompStatementNode.IfPart();
            if (ifPartNode == null)
            {
                throw Exception("conditional compilation if part is empty");
            }
            if (ifPartNode->Expr() == null)
            {
                throw Exception("conditional compilation if part expression is empty");
            }
            ifPartNode->Expr()->Accept(*this);
            bool execute = PopCondCompValue();
            if (execute)
            {
                ifPartNode->Accept(*this);
            }
            else
            {
                const Cm.Ast.NodeList<Cm.Ast.CondCompPartNode>& elifPartNodes = condCompStatementNode.ElifParts();
                int n = elifPartNodes.Count();
                for (int i = 0; i < n; ++i)
                {
                    Cm.Ast.CondCompPartNode* elifPartNode = elifPartNodes[i];
                    if (elifPartNode == null)
                    {
                        throw Exception("conditional compilation elif part is empty");
                    }
                    if (elifPartNode->Expr() == null)
                    {
                        throw Exception("conditional compilation elif part expression is empty");
                    }
                    elifPartNode->Expr()->Accept(*this);
                    execute = PopCondCompValue();
                    if (execute)
                    {
                        elifPartNode->Accept(*this);
                        break;
                    }
                }
                if (!execute)
                {
                    Cm.Ast.CondCompPartNode* elsePartNode = condCompStatementNode.ElsePart();
                    if (elsePartNode != null)
                    {
                        elsePartNode->Accept(*this);
                    }
                }
            }
        }
        public nothrow void SetCurrentFunction(Cm.BoundTree.BoundFunction* function)
        {
            boundFunction.Reset(function);
        }
        public nothrow Cm.BoundTree.BoundFunction* ReleaseCurrentFunction()
        {
            return boundFunction.Release();
        }
        public void AddBoundStatement(Cm.BoundTree.BoundStatement* boundStatement)
        {
            if (currentParent.IsNull())
            {
                throw Exception("binder has no current parent");
            }
            currentParent->AddStatement(boundStatement);
        }
        public void BeginContainerScope(Cm.Sym.ContainerScope* containerScope)
        {
            containerScopeStack.Push(currentContainerScope);
            currentContainerScope = containerScope;
        }
        public void EndContainerScope()
        {
            currentContainerScope = containerScopeStack.Pop();
        }
        public Cm.BoundTree.BoundCompoundStatement* GetCurrentCompound() 
        {
            Cm.BoundTree.BoundParentStatement* parent = currentParent.GetPtr();
            if (parent is Cm.BoundTree.BoundCompoundStatement*)
            {
                return cast<Cm.BoundTree.BoundCompoundStatement*>(parent);
            }
            else
            {
                return parent->CompoundParent();
            }
        }
        private void PushCondCompValue(bool value)
        {
            condCompilationEvaluationStack.Push(value);
        }
        private bool PopCondCompValue()
        {
            return condCompilationEvaluationStack.Pop();
        }
        private Cm.BoundTree.BoundCompileUnit& boundCompileUnit;
        private UniquePtr<Cm.BoundTree.BoundFunction> boundFunction;
        private UniquePtr<Cm.BoundTree.BoundParentStatement> currentParent;
        private Stack<Cm.BoundTree.BoundParentStatement*> parentStack;
        private Cm.BoundTree.BoundSwitchStatement* switchStatement;
        private Stack<Cm.BoundTree.BoundSwitchStatement*> switchStatementStack;
        private Stack<Cm.Sym.ContainerScope*> containerScopeStack;
        private Cm.Sym.ContainerScope* currentContainerScope;
        private UniquePtr<Cm.BoundTree.BoundClass> boundClass;
        private Stack<UniquePtr<Cm.BoundTree.BoundClass>> boundClassStack;
        private Stack<bool> condCompilationEvaluationStack;
    }
}
