/*========================================================================
    Copyright (c) 2012-2016 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;

namespace Cm.Bind
{
    public class Binder : Cm.Ast.Visitor
    {
        public nothrow Binder(Cm.BoundTree.BoundCompileUnit& boundCompileUnit_) : 
            base(true, false), boundCompileUnit(boundCompileUnit_), currentContainerScope(null)
        {
        }
        public override void BeginVisit(Cm.Ast.NamespaceNode& namespaceNode)
        {
            Cm.Sym.ContainerScope* containerScope = boundCompileUnit.SymbolTable().GetContainerScope(&namespaceNode);
            BeginContainerScope(containerScope);
        }
        public override void EndVisit(Cm.Ast.NamespaceNode& namespaceNode)
        {
            EndContainerScope();
        }
        public override void BeginVisit(Cm.Ast.ClassNode& classNode)
        {
            if (classNode.TemplateParameters().Count() > 0)
            {
                PushSkipContent(true);
            }
            else
            {
                Cm.Sym.ContainerScope* containerScope = boundCompileUnit.SymbolTable().GetContainerScope(&classNode);
                Cm.Sym.ClassTypeSymbol* classTypeSymbol = containerScope->Class();
                if (!boundCompileUnit.IsPrebindCompileUnit())
                {
                    AddClassTypeToIrClassTypeRepository(classTypeSymbol, boundCompileUnit, currentContainerScope);
                }
                boundClassStack.Push(Rvalue(boundClass));
                boundClass.Reset(new Cm.BoundTree.BoundClass(classTypeSymbol, &classNode));
                BeginContainerScope(containerScope);
            }
        }
        public override void EndVisit(Cm.Ast.ClassNode& classNode)
        {
            if (classNode.TemplateParameters().Count() > 0)
            {
                PopSkipContent();
            }
            else
            {
                EndContainerScope();
                Cm.Sym.ClassTypeSymbol* classTypeSymbol = boundClass->Symbol();
                if (!classTypeSymbol->HasUserDefinedDestructor())
                {
                    for (Cm.Sym.MemberVariableSymbol* memberVar : classTypeSymbol->MemberVariables())
                    {
                        if (!memberVar->GetType()->IsBound() && (memberVar->GetType() is Cm.Sym.TemplateTypeSymbol*))
                        {
                            Cm.Sym.TemplateTypeSymbol* templateTypeSymbol = cast<Cm.Sym.TemplateTypeSymbol*>(memberVar->GetType());
                            boundCompileUnit.ClassTemplateRepository().BindTemplateTypeSymbol(templateTypeSymbol, currentContainerScope, boundCompileUnit.FileScopes());
                        }
                    }
                    if (classTypeSymbol->DoGenerateDestructor())
                    {
                        Cm.Sym.FunctionSymbol* destructor = GenerateDestructorSymbol(boundCompileUnit.SymbolTable(), classNode.GetSpan(), classTypeSymbol, boundCompileUnit.SyntaxUnit());
                        destructor->SetPublic();
                        classTypeSymbol->AddSymbol(destructor);
                    }
                    if (classTypeSymbol->Destructor() != null)
                    {
                        GenerateDestructorImplementation(classNode.GetSpan(), classTypeSymbol, currentContainerScope, boundCompileUnit);
                    }
                }
                if (!classTypeSymbol->HasUserDefinedStaticConstructor())
                {
                    if (classTypeSymbol->StaticConstructor() != null)
                    {
                        GenerateStaticConstructorImplementation(boundClass.GetPtr(), currentContainerScope, classNode.GetSpan(), classTypeSymbol, boundCompileUnit);
                    }
                }
                boundCompileUnit.AddBoundNode(boundClass.Release());
                boundClass = Rvalue(boundClassStack.Pop());
            }
        }
        public override void BeginVisit(Cm.Ast.ConstructorNode& constructorNode)
        {
            if ((constructorNode.GetSpecifiers() & (Cm.Ast.Specifiers.default_ | Cm.Ast.Specifiers.suppress_)) == Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&constructorNode);
                BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&constructorNode));
                boundFunction.Reset(new Cm.BoundTree.BoundFunction(&constructorNode, functionSymbol));
            }
        }
        public override void EndVisit(Cm.Ast.ConstructorNode& constructorNode)
        {
            if ((constructorNode.GetSpecifiers() & Cm.Ast.Specifiers.default_) != Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&constructorNode);
                bool unique = !(boundClass->Symbol() is Cm.Sym.TemplateTypeSymbol*);
                GenerateSynthesizedFunctionImplementation(functionSymbol, constructorNode.GetSpan(), boundClass->Symbol(), currentContainerScope, boundCompileUnit, unique);
            }
            else if ((constructorNode.GetSpecifiers() & Cm.Ast.Specifiers.suppress_) == Cm.Ast.Specifiers.none)
            {
                CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
                if (boundFunction->Body() != null)
                {
                    GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                    bool callToThisInitializerGenerated = false;
                    GenerateClassInitStatement(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &constructorNode, 
                        callToThisInitializerGenerated);
                    if (boundClass->Symbol()->IsVirtual() && !callToThisInitializerGenerated)
                    {
                        GenerateInitVPtrStatement(boundClass->Symbol(), boundFunction.GetPtr());
                    }
                    if (!callToThisInitializerGenerated)
                    {
                        GenerateMemberVariableInitStatements(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &constructorNode);
                    }
                    boundClass->AddMember(boundFunction.Release());
                }
                EndContainerScope();
            }
        }
        public override void BeginVisit(Cm.Ast.DestructorNode& destructorNode)
        {
            if ((destructorNode.GetSpecifiers() & Cm.Ast.Specifiers.default_) == Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&destructorNode);
                BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&destructorNode));
                boundFunction.Reset(new Cm.BoundTree.BoundFunction(&destructorNode, functionSymbol));
            }
        }
        public override void EndVisit(Cm.Ast.DestructorNode& destructorNode)
        {
            if ((destructorNode.GetSpecifiers() & Cm.Ast.Specifiers.default_) == Cm.Ast.Specifiers.none)
            {
                CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
                if (boundFunction->Body() != null)
                {
                    GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                    if (boundClass->Symbol()->IsVirtual())
                    {
                        GenerateInitVPtrStatement(boundClass->Symbol(), boundFunction.GetPtr());
                    }
                    GenerateMemberVariableDestructionStatements(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &destructorNode);
                    GenerateBaseClassDestructionStatement(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &destructorNode);
                    boundClass->AddMember(boundFunction.Release());
                }
                EndContainerScope();
            }
        }
        public override void BeginVisit(Cm.Ast.MemberFunctionNode& memberFunctionNode)
        {
            if ((memberFunctionNode.GetSpecifiers() & (Cm.Ast.Specifiers.default_ | Cm.Ast.Specifiers.suppress_)) == Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&memberFunctionNode);
                BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&memberFunctionNode));
                boundFunction.Reset(new Cm.BoundTree.BoundFunction(&memberFunctionNode, functionSymbol));
                if (!functionSymbol->IsVirtualAbstractOrOverride() && !functionSymbol->IsNew())
                {
                    Cm.Sym.ClassTypeSymbol* ownerClass = boundClass->Symbol();
                    if (ownerClass != null && ownerClass->BaseClass() != null)
                    {
                        Cm.Sym.ClassTypeSymbol* baseClass = ownerClass->BaseClass();
                        for (Cm.Sym.FunctionSymbol* f : baseClass->Vtbl())
                        {
                            if (f != null && f->IsVirtualAbstractOrOverride())
                            {
                                if (Cm.Sym.Overrides(functionSymbol, f))
                                {
                                    string warningMessage = "function '" + functionSymbol->FullName() + "' hides base class virtual function '" + f->FullName() + "'. " +
                                        "To get rid of this warning declare the function either 'override' or 'new'.";
                                    Console.Out() << "warning: " << warningMessage << endl();
                                    Cm.Sym.Warning warning(Cm.Sym.CompileWarningCollection.Instance().GetCurrentProjectName(), warningMessage);
                                    warning.SetDefined(functionSymbol->GetSpan());
                                    warning.SetReferenced(f->GetSpan());
                                    Cm.Sym.CompileWarningCollection.Instance().AddWarning(warning);
                                }
                            }
                        }
                    }
                }
            }
        }
        public override void EndVisit(Cm.Ast.MemberFunctionNode& memberFunctionNode)
        {
            if ((memberFunctionNode.GetSpecifiers() & Cm.Ast.Specifiers.default_) != Cm.Ast.Specifiers.none)
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&memberFunctionNode);
                bool unique = !(boundClass->Symbol() is Cm.Sym.TemplateTypeSymbol*);
                GenerateSynthesizedFunctionImplementation(functionSymbol, memberFunctionNode.GetSpan(), boundClass->Symbol(), currentContainerScope, boundCompileUnit, unique);
            }
            else if ((memberFunctionNode.GetSpecifiers() & Cm.Ast.Specifiers.suppress_) == Cm.Ast.Specifiers.none)
            {
                if (!boundFunction->FunctionSymbol()->IsAbstract() && boundFunction->Body() != null)
                {
                    CheckFunctionReturnPaths(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol(), 
                        &memberFunctionNode);
                    CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
                    GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                    if (boundFunction->FunctionSymbol()->IsStatic() && boundClass->Symbol()->StaticConstructor() != null)
                    {
                        GenerateStaticConstructorCall(boundCompileUnit, boundFunction.GetPtr(), boundClass->Symbol(), &memberFunctionNode);
                    }
                    boundClass->AddMember(boundFunction.Release());
                }
                EndContainerScope();
            }
        }
        public override void BeginVisit(Cm.Ast.ConversionFunctionNode& conversionFunctionNode)
        {
            Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&conversionFunctionNode);
            BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&conversionFunctionNode));
            boundFunction.Reset(new Cm.BoundTree.BoundFunction(&conversionFunctionNode, functionSymbol));
        }
        public override void EndVisit(Cm.Ast.ConversionFunctionNode& conversionFunctionNode)
        {
            CheckFunctionReturnPaths(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol(),
                &conversionFunctionNode);
            CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
            if (boundFunction->Body() != null)
            {
                GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                boundClass->AddMember(boundFunction.Release());
            }
            EndContainerScope();
        }
        public override void BeginVisit(Cm.Ast.StaticConstructorNode& staticConstructorNode)
        {
            Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&staticConstructorNode);
            BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&staticConstructorNode));
            boundFunction.Reset(new Cm.BoundTree.BoundFunction(&staticConstructorNode, functionSymbol));
        }
        public override void EndVisit(Cm.Ast.StaticConstructorNode& staticConstructorNode)
        {
            if (boundFunction->Body() != null)
            {
                GenerateStaticInitStatement(boundCompileUnit, currentContainerScope, boundCompileUnit.FileScopes(), boundFunction.GetPtr(), boundClass->Symbol(), &staticConstructorNode);
                boundClass->AddMember(boundFunction.Release());
            }
            EndContainerScope();
        }
        public override void BeginVisit(Cm.Ast.FunctionNode& functionNode)
        {
            if (functionNode.TemplateParameters().Count() > 0)
            {
                PushSkipContent(true);
            }
            else
            {
                Cm.Sym.FunctionSymbol* functionSymbol = boundCompileUnit.SymbolTable().GetFunctionSymbol(&functionNode);
                BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&functionNode));
                boundFunction.Reset(new Cm.BoundTree.BoundFunction(&functionNode, functionSymbol));
            }
        }
        public override void EndVisit(Cm.Ast.FunctionNode& functionNode)
        {
            if (functionNode.TemplateParameters().Count() > 0)
            {
                PopSkipContent();
            }
            else 
            {
                CheckFunctionReturnPaths(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol(), 
                    &functionNode);
                CheckFunctionAccessLevels(boundCompileUnit.SymbolTable(), currentContainerScope, boundCompileUnit.FileScopes(), boundCompileUnit.ClassTemplateRepository(), boundFunction->FunctionSymbol());
                GenerateReceives(currentContainerScope, boundCompileUnit, boundFunction.GetPtr());
                boundCompileUnit.AddBoundNode(boundFunction.Release());
                EndContainerScope();
            }
        }
        public override void BeginVisit(Cm.Ast.CompoundStatementNode& compoundStatementNode)
        {
            BeginContainerScope(boundCompileUnit.SymbolTable().GetContainerScope(&compoundStatementNode));
            parentStack.Push(currentParent.Release());
            currentParent.Reset(new Cm.BoundTree.BoundCompoundStatement(&compoundStatementNode));
        }
        public override void EndVisit(Cm.Ast.CompoundStatementNode& compoundStatementNode)
        {
            Cm.BoundTree.BoundParentStatement* parent = parentStack.Pop();
            if (parent != null)
            {
                parent->AddStatement(currentParent.Release());
                currentParent.Reset(parent);
            }
            else
            {
                if (currentParent.GetPtr() is Cm.BoundTree.BoundCompoundStatement*)
                {
                    Cm.BoundTree.BoundCompoundStatement* compound = cast<Cm.BoundTree.BoundCompoundStatement*>(currentParent.Release());
                    boundFunction->SetBody(compound);
                }
                else
                {
                    throw Exception("current parent not compound statement");
                }
            }
            EndContainerScope();
        }
        public nothrow void SetCurrentFunction(Cm.BoundTree.BoundFunction* function)
        {
            boundFunction.Reset(function);
        }
        public nothrow Cm.BoundTree.BoundFunction* ReleaseCurrentFunction()
        {
            return boundFunction.Release();
        }
        public void AddBoundStatement(Cm.BoundTree.BoundStatement* boundStatement)
        {
            if (currentParent.IsNull())
            {
                throw Exception("binder has no current parent");
            }
            currentParent->AddStatement(boundStatement);
        }
        public void BeginContainerScope(Cm.Sym.ContainerScope* containerScope)
        {
            containerScopeStack.Push(currentContainerScope);
            currentContainerScope = containerScope;
        }
        public void EndContainerScope()
        {
            currentContainerScope = containerScopeStack.Pop();
        }
        public Cm.BoundTree.BoundCompoundStatement* GetCurrentCompound() 
        {
            Cm.BoundTree.BoundParentStatement* parent = currentParent.GetPtr();
            if (parent is Cm.BoundTree.BoundCompoundStatement*)
            {
                return cast<Cm.BoundTree.BoundCompoundStatement*>(parent);
            }
            else
            {
                return parent->CompoundParent();
            }
        }
        private Cm.BoundTree.BoundCompileUnit& boundCompileUnit;
        private UniquePtr<Cm.BoundTree.BoundFunction> boundFunction;
        private UniquePtr<Cm.BoundTree.BoundParentStatement> currentParent;
        private Stack<Cm.BoundTree.BoundParentStatement*> parentStack;
        private Stack<Cm.Sym.ContainerScope*> containerScopeStack;
        private Cm.Sym.ContainerScope* currentContainerScope;
        private UniquePtr<Cm.BoundTree.BoundClass> boundClass;
        private Stack<UniquePtr<Cm.BoundTree.BoundClass>> boundClassStack;
    }
}
