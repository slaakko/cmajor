\documentclass[a4paper,oneside,11pt]{article}
\usepackage{CmBook}

\begin{document}

\title{Cmajor Programming Language Specification\\Version 3.6}
\author{Seppo Laakko}
\date{\today}
\maketitle
\tableofcontents

\clearpage

\section{Grammar Notation}

The lexical and syntactical structure of Cmajor programs is presented in this text
using grammars that are in parsing expression grammar (\cite{PEG}) form.
A grammar consists of

\begin{enumerate}
\item
\emph{Terminal} symbols that are the elementary symbols of the language generated by the grammar.
Terminals are presented like \lit*{this} in a type-writer font.
\item
\emph{Nonterminal} symbols also called syntactic variables that represent sets of strings of terminal symbols.
Nonterminals are presented like \synt{this} in italic font within angle brackets.
\item
\emph{Operators} ( ), $|$, $-$, *, +, ?, [ ], and $\backslash$ that operate on strings of terminals and nonterminals.
If an operator character is ment to be a terminal symbol, it is quoted like this: \lit{*}.
The meaning of each operator appears in table \ref{tab:operators}.
\item
\emph{Productions} each of which consists of a nonterminal symbol called the \emph{head} of the production, symbol ::= (pronounced ``produces''), and
a sequence of terminals, nonterminals and operators collectively called the \emph{body} of the production.
\end{enumerate}

\begin{table}[htb]
\caption{Grammar Operators}\label{tab:operators}
\begin{tabular}{ll}
\bf{Expression}& \bf{Meaning}\\
\hline
$\alpha$ $|$ $\beta$ & $\alpha$ or $\beta$\\
$\alpha$ $-$ $\beta$ & $\alpha$ but not $\beta$\\
$\alpha$* & zero or more $\alpha$'s\\
$\alpha$+ & one or more $\alpha$'s\\
$\alpha$? & zero or one $\alpha$'s\\
($\alpha$ $\beta$) & grouping of $\alpha$ and $\beta$ together\\
\verb|[a-z]| & a terminal character in range a \ldots{} z\\
\verb|[^\r\na-c]| & any terminal character except a carriage return, a newline or\\& a character in range a \ldots{} c\\
\end{tabular}
\end{table}

\section{Lexical Structure}

\subsection{White Space and Comments}

Lexical elements in program texts can be separated by one or more instance of white space characters and comments.

\begin{align*}
spaces\textrm{-}and\textrm{-}comments &\rightarrow \> (\> space \> | \> comment \>)^+\\
space &\rightarrow \> \textrm{'any ASCII whitespace character'}\\
comment &\rightarrow \> line\textrm{-}comment \> | \> block\textrm{-}comment\\
line\textrm{-}comment &\rightarrow \> \texttt{//} \> [\> \hat{} \> \backslash r\backslash n\>]^* \> new\textrm{-}line\\
new\textrm{-}line &\rightarrow \>  "\backslash r\backslash n" \>  | \> "\backslash n" \> | \> "\backslash r"\\
block\textrm{-}comment &\rightarrow \> \texttt{"/*"}\> ( \> any\textrm{-}char \> - \texttt{"*/"} \> ) \> \texttt{"*/"}\\
any\textrm{-}char &\rightarrow \> \textrm{'any 8-bit ASCII character'}
\end{align*}

\subsection{Keywords}\label{keyword}

Keywords have reserved context-dependent meaning in a program and they cannot be used as identifiers.

\begin{align*}
keyword \rightarrow \> \textrm{'see table \ref{tab:keywords}'}
\end{align*}

\begin{table}[htb]
\caption{Keywords}\label{tab:keywords}
\begin{tabular}{llllll}
\\
\bf{abstract} & \bf{and} & \bf{as} & \bf{axiom} & \bf{base} & \bf{bool}\\
\bf{break} & \bf{byte} & \bf{case} & \bf{cast} & \bf{catch} & \bf{cdecl}\\
\bf{char} & \bf{class} & \bf{concept} & \bf{const} & \bf{constexpr} & \bf{construct}\\
\bf{continue} & \bf{default} & \bf{delegate} & \bf{delete} & \bf{destroy} & \bf{do}\\
\bf{double} & \bf{else} & \bf{enum} & \bf{explicit} & \bf{extern} & \bf{false}\\
\bf{float} & \bf{for} & \bf{goto} & \bf{if} & \bf{inline} & \bf{int}\\
\bf{interface} & \bf{internal} & \bf{is} & \bf{long} & \bf{namespace} & \bf{new}\\
\bf{not} & \bf{nothrow} & \bf{null} & \bf{operator} & \bf{or} & \bf{override}\\
\bf{private} & \bf{protected} & \bf{public} & \bf{return} & \bf{sbyte} & \bf{short}\\
\bf{sizeof} & \bf{static} & \bf{suppress} & \bf{switch} & \bf{this} & \bf{throw}\\
\bf{true} & \bf{try} & \bf{typedef} & \bf{typename} & \bf{uchar} & \bf{uint}\\
\bf{ulong} & \bf{unit\_test} & \bf{ushort} & \bf{using} & \bf{virtual} & \bf{void}\\
\bf{wchar} & \bf{where} & \bf{while}
\end{tabular}
\end{table}

\subsection{Identifiers}\label{identifier}\label{qualifiedid}

Identifiers are used to name entities in a program.
Identifiers that begin with double underscores are reserved for the compiler.

\begin{align*}
identifier &\rightarrow \> id\textrm{-}char\textrm{-}sequence - \hyperref[keyword]{keyword}\\
id\textrm{-}char\textrm{-}sequence &\rightarrow \> ( \> letter \> \> | \> \texttt{\_} \> ) \> ( \> letter \> | \> \texttt{\_} \> | \> digit \>)^*\\
letter &\rightarrow \> [\texttt{A-Za-z}]\\
digit &\rightarrow [\texttt{0-9}]\\
qualified\textrm{-}id &\rightarrow \> identifier \> ( \> \texttt{'.'} \> identifier \> )^*
\end{align*}

\subsection{Literals}\label{literal}

Literals are used to write values in a program.

\begin{align*}
literal &\rightarrow \> & &\hyperref[booleanliteral]{boolean\textrm{-}literal} \> | \> \hyperref[integerliteral]{integer\textrm{-}literal} \> | \>
\hyperref[floatingliteral]{floating\textrm{-}literal} \> | \> \hyperref[characterliteral]{character\textrm{-}literal}\\
&| & &\hyperref[stringliteral]{string\textrm{-}literal} \> | \> \hyperref[nullliteral]{null\textrm{-}literal}
\end{align*}

\subsubsection{Boolean Literals}\label{booleanliteral}

\begin{align*}
boolean\textrm{-}literal \rightarrow \> \textbf{true} \> | \> \textbf{false}
\end{align*}

The type of a boolean literal is \bf{bool}.

\subsubsection{Integer Literals}\label{integerliteral}\label{decimaldigitsequence}\label{hexadecimaldigitsequence}

\begin{align*}
integer\textrm{-}literal &\rightarrow & &decimal\textrm{-}digit\textrm{-}sequence \> unsigned\textrm{-}suffix?\\
&| & &(\> \texttt{"0x"} \> | \> \texttt{"0X"} \>) \> hexadecimal\textrm{-}digit\textrm{-}sequence\\
& & &unsigned\textrm{-}suffix?\\
decimal\textrm{-}digit\textrm{-}sequence &\rightarrow & &decimal\textrm{-}digit^+\\
decimal\textrm{-}digit &\rightarrow & &[\texttt{0-9}]\\
unsigned\textrm{-}suffix &\rightarrow & &\texttt{'u'} \> | \> \texttt{'U'}\\
hexadecimal\textrm{-}digit\textrm{-}sequence &\rightarrow & &hexadecimal\textrm{-}digit^+\\
hexadecimal\textrm{-}digit &\rightarrow & &[\texttt{0-9a-fA-F}]
\end{align*}

If integer literal has no unsigned suffix, the type of the integer literal
is first of the following types that can represent the value:
\bf{sbyte}, \bf{byte}, \bf{short}, \bf{ushort}, \bf{int}, \bf{uint}, \bf{long}, \bf{ulong}.

If integer literal has an unsigned suffix, the type of the integer literal is
first of the following types that can represent the value:
\bf{byte}, \bf{ushort}, \bf{uint}, \bf{ulong}.

\subsubsection{Floating Literals}\label{floatingliteral}

\begin{align*}
floating\textrm{-}literal &\rightarrow & &( \> fractional\textrm{-}floating\textrm{-}literal \> | \> exponent\textrm{-}floating\textrm{-}literal \>)\\
& & &floating\textrm{-}suffix?\\
fractional\textrm{-}floating\textrm{-}literal &\rightarrow & &\hyperref[decimaldigitsequence]{decimal\textrm{-}digit\textrm{-}sequence}? \> \texttt{.}
\> \hyperref[decimaldigitsequence]{decimal\textrm{-}digit\textrm{-}sequence}\\
& & &exponent\textrm{-}part?\\
&| & &\hyperref[decimaldigitsequence]{decimal\textrm{-}digit\textrm{-}sequence} \> \texttt{.}\\
exponent\textrm{-}part &\rightarrow & &(\> \texttt{e} \> | \> \texttt{E} \>) \> sign? \> \hyperref[decimaldigitsequence]{decimal\textrm{-}digit\textrm{-}sequence}\\
sign &\rightarrow & &\texttt{+} \> | \> \texttt{-}\\
exponent\textrm{-}floating\textrm{-}literal &\rightarrow & &\hyperref[decimaldigitsequence]{decimal\textrm{-}digit\textrm{-}sequence} \> exponent\textrm{-}part\\
floating\textrm{-}suffix &\rightarrow & &\texttt{'f'} \> | \> \texttt{'F'}
\end{align*}

If a floating literal has a floating suffix, the type of it is \bf{float},
otherwise the type of the floating literal is \bf{double}.

\subsubsection{Character Literals}\label{characterliteral}\label{escape}

\begin{align*}
character\textrm{-}literal &\rightarrow \texttt{'} \> ( \> [\> \hat{}\> \backslash r \backslash n] \> | \> escape \>) \> \texttt{'}\\
escape &\rightarrow \backslash \> ( \> hex\textrm{-}escape \> | \> decimal\textrm{-}escape \> | \> char\textrm{-}escape \>)\\
hex\textrm{-}escape &\rightarrow [\texttt{xX}] \> \hyperref[hexadecimaldigitsequence]{hexadecimal\textrm{-}digit\textrm{-}sequence}\\
decimal\textrm{-}escape & \rightarrow [\texttt{dD}] \> \hyperref[decimaldigitsequence]{decimal\textrm{-}digit\textrm{-}sequence}\\
char\textrm{-}escape &\rightarrow [\> \hat{}\> \texttt{dDxX} \backslash r \backslash n] \> | \> \texttt{'see table \ref{tab:charescape}'}
\end{align*}

\begin{table}[htb]
\caption{Character Escape Sequences}\label{tab:charescape}
\begin{tabular}{lll}
\textbf{Escape Sequence }& \textbf{Character Name} & \textbf{Character Code}\\
\hline
'$\backslash$n' & new line& 10\\
'$\backslash$t' & horizontal tab& 9\\
'$\backslash$v' & vertical tab& 11\\
'$\backslash$b' & backspace & 8\\
'$\backslash$r' & carriage return & 13\\
'$\backslash$f' & form feed & 12\\
'$\backslash$a' & alert & 7\\
'$\backslash$$\backslash$' & backslash & 92\\
'$\backslash$0' & null & 0\\
'$\backslash$x' & any other character x stands for itself
\end{tabular}
\end{table}
The type of a character literals is \bf{char}.

\subsubsection{String Literals}\label{stringliteral}

The backslash character provides an escaping mechanism for regular string literals, UTF-16 string literals and UTF-32 string literals.
There are no escapes in raw string literals. The content is taken literally.

\begin{align*}
string\textrm{-}literal &\rightarrow & &regular\textrm{-}string\textrm{-}literal\\
&| & &utf16\textrm{-}string\textrm{-}literal\\
&| & &utf32\textrm{-}string\textrm{-}literal\\
&| & &raw\textrm{-}string\textrm{-}literal\\
regular\textrm{-}string\textrm{-}literal &\rightarrow & &\texttt{"} \> ( \> [\> \hat{} \> \texttt{"} \backslash r \backslash n] \> | \>
\hyperref[escape]{escape} \>)^* \>
\texttt{"}\\
utf16\textrm{-}string\textrm{-}literal &\rightarrow & &\texttt{w}\texttt{"} \>
( \> [\> \hat{} \> \texttt{"} \backslash r \backslash n] \> | \> \hyperref[escape]{escape} \>)^*
\> \texttt{"}\\
utf32\textrm{-}tring\textrm{-}literal &\rightarrow & &\texttt{u}\texttt{"} \> ( \> [\> \hat{} \> \texttt{"} \backslash r \backslash n] \> | \>
\hyperref[escape]{escape} \>)^*
\> \texttt{"}\\
raw\textrm{-}string\textrm{-}literal &\rightarrow  & &\texttt{@} \texttt{"} \> ( \> [\> \hat{} \> \texttt{"} \backslash r \backslash n] \> )^* \> \texttt{"}
\end{align*}

The type of a string literal and raw string literal is \bf{const char*}.
The type of UTF-16 string literal is \bf{const wchar*}.
The type of UTF-32 string literal is \bf{const uchar*}.

\subsubsection{Null-literal}\label{nullliteral}

\begin{align*}
null\textrm{-}literal &\rightarrow \texttt{null}
\end{align*}

The null literal can be implicitly converted to any pointer or delegate type.

\section{Basic Types}\label{sec:basictypes}\label{basictype}

Cmajor has basic types for representing Boolean, integer, floating-point and character values,
and for expressing lack of type.

\begin{align*}
basic\textrm{-}type &\rightarrow & &\textbf{bool} \> | \> \textbf{sbyte} \> | \> \textbf{byte} \> | \> \textbf{short} \> | \> \textbf{ushort}
\> | \> \textbf{int} \> | \> \textbf{uint} \> | \> \textbf{long} \> | \> \textbf{ulong}\\
&| & &\textbf{float} \> | \> \textbf{double} \> | \> \textbf{char} \> | \> \textbf{wchar} \> | \> \textbf{uchar} \> | \> \textbf{void}
\end{align*}

\subsection{Boolean Type}

The Boolean type \bf{bool} is an 8-bit integral type with a value 1 representing \bf{true} and value 0 representing \bf{false}.

Operators unary !, and binary $||$, \&\& and == operate on Boolean type operands.

The default value of a \bf{bool} type object is \bf{false}.

A Boolean type value can be converted to an integer type, floating-point type or \bf{char} type with an explicit \bf{cast}.

\subsection{Integer Types}

\bf{sbyte} is an 8-bit signed integer type for representing values in range $-128 \ldots 127$.\\
\bf{byte} is an 8-bit unsigned integer type for representing values in range $0 \ldots 255$.\\
\bf{short} is a 16-bit signed integer type for representing values in range $-32768 \ldots 32767$.\\
\bf{ushort} is a 16-bit unsigned integer type for representing values in range $0 \ldots 65535$.\\
\bf{int} is a 32-bit signed integer type for representing values in range $-2147483648 \ldots 2147483647$.\\
\bf{uint} is a 32-bit unsigned integer type for representing values in range $0 \ldots 4294967295$.\\
\bf{long} is a 64-bit signed integer type for representing values in range\\
$-9223372036854775808 \ldots 9223372036854775807$.\\
\bf{ulong} is a 64-bit unsigned integer type for representing values in range $0 \ldots 18446744073709551615$.\\

The default value of an integer type is 0.

Unary operators $-$, $+$, $\sim$, prefix operators $++$ and $--$,
binary operators $+$, $-$, $*$, $/$, $\%$, $==$, $<$, \&, $|$, \^{}, $<<$, and $>>$ operate on integer type operands.

There is an implicit conversion from a signed or unsigned integer type whose bit width is smaller to a signed integer type whose bit width is larger.
For example, a \bf{sbyte} can be implicitly converted to an \bf{int}, because the bit width of \bf{sbyte} is 8 and the bit width of \bf{int} is 32.
There is an implicit conversion from an unsigned integer type whose bit width is smaller to an unsigned integer type whose bit width is larger.
For example, a \bf{ushort} can be implicitly converted to an \bf{uint}, because the bit width of \bf{ushort} is 16 and the bit width of \bf{uint} is 32.
Other conversions between integer types are explicit (they need a \bf{cast}).

There is an implicit conversion from integer types whose bit width is less than or equal to 32 bits to \bf{float} floating-point type.

There is an implicit conversion from all integer types to \bf{double} floating-point type.

An integer type value can be converted to a \bf{char} or \bf{bool} value with an explicit \bf{cast}.

\subsection{Floating-point Types}

Floating-point type \bf{float} is a 32-bit IEEE 754 type.
The default value of a \bf{float} type object is 0.0f.

Floating-point type \bf{double} is a 64-bit IEEE 754 type.
The default value of a \bf{double} type object is 0.0.

There is an implicit conversion from \bf{float} to \bf{double}.

A \bf{double} type value can be converted to \bf{float} with an explicit \bf{cast}.

A floating-point type value can be converted to integer type, \bf{char} type or \bf{bool} type with an explicit \bf{cast}.

Operators unary $-$, $+$, binary $+$, $-$, $*$, $/$, $==$ and $<$ operate on floating-point type operands.
A floating-point type value can be converted to an integer type with an explicit \bf{cast} operator.

\subsection{Character Types}

The character type \bf{char} is a 8-bit integral unsigned type for representing character code values in range $0 \ldots 255$.
The default value of a \bf{char} type object is '$\backslash$0'.
The character type \bf{wchar} is a 16-bit integral unsigned type for representing UTF-16 Unicode code point in range $0 \ldots 65535$.
The default value of a \bf{wchar} type object is '$\backslash$0'.
The character type \bf{uchar} is a 32-bit integral unsigned type for representing UTF-32 Unicode code point in range $0 \ldots 4294967295$.
The default value of a \bf{uchar} type object is '$\backslash$0'.

Character code values can be compared for equality with operator $==$ and for less-than relationship with operator $<$.

There are implicit conversions from \bf{char} to \bf{wchar} and \bf{uchar} type and from \bf{wchar} to \bf{uchar} type and
explicit conversions from \bf{wchar} to \bf{char} and from \bf{uchar} to \bf{wchar} and \bf{char} type.
In addition all character types can be explicitly converted an integer type, floating-point type or \bf{bool} type with a \bf{cast}.
There are also explicit conversions from integer types to character types so that you can construct a character if you know
its code value by using a cast.

\subsection{Void Type}

The type \bf{void} represents lack of type. It is an incomplete type that cannot be completed, meaning you cannot have an object of type \bf{void}.

\section{Expressions}\label{expression}

An expression represents a computation that usually produces a value \footnote{Calling a void function does not produce a value.}.
This grammar accepts a superset of valid expressions. The implementation contains special disambiguation rules that reject syntactically
valid (according to the grammar) but meaningless expressions.
The type checking phase of the compiler further rejects semantically invalid expressions.

\begin{align*}
expression \rightarrow \hyperref[equivalence]{equivalence}
\end{align*}

\subsection{Equivalence}\label{equivalence}

\begin{align*}
equivalence \rightarrow \hyperref[implication]{implication} \>( \> \texttt{<=>} \> implication \> )^*
\end{align*}

The $<=>$ operator is used in axioms (\ref{axiom}) to state that operand expressions are logically equivalent.
It groups operands from left to right.

\subsection{Implication}\label{implication}

\begin{align*}
implication \rightarrow \hyperref[disjunction]{disjunction} \> ( \> \texttt{=>} \> implication \> )?
\end{align*}

The $=>$ operator is used in axioms (\ref{axiom}) to state that the right operand is logical implication of the left
operand. It groups operands from right to left.

\subsection{Disjunction}\label{disjunction}

\begin{align*}
disjunction \rightarrow  \hyperref[conjunction]{conjunction} \> ( \> \texttt{||} \> \hyperref[conjunction]{conjunction} \>)^*
\end{align*}

The $||$ operator takes boolean operands and yields a boolean value. It groups operands from left to right.
Expression $a || b$ is \bf{true} when \emph{a} is \bf{true}, or \emph{a} is \bf{false} and \emph{b} is \bf{true}
(in the first case operand \emph{b} is not evaluated); otherwise \bf{false}.

A user-defined class cannot overload the $||$ operator.

\subsection{Conjunction}\label{conjunction}

\begin{align*}
conjunction \rightarrow \hyperref[bitor]{bit\textrm{-}or\textrm{-}expr} \> ( \> \texttt{\&\&} \> \hyperref[bitor]{bit\textrm{-}or\textrm{-}expr} \>)^*
\end{align*}

The $\&\&$ operator takes boolean operands and yields a boolean value. It groups operands from left to right.
Expression $a \&\& b$ is \bf{false} when \emph{a} is \bf{false}, or \emph{a} is \bf{true} and \emph{b} is \bf{false}
(in the first case operand \emph{b} is not evaluated); otherwise \bf{true}.

A user-defined class cannot overload the $\&\&$ operator.

\subsection{Bitwise OR-expression}\label{bitor}

\begin{align*}
bit\textrm{-}or\textrm{-}expr \rightarrow \hyperref[bitxor]{bit\textrm{-}xor\textrm{-}expr} \> ( \> \texttt{|} \>
\hyperref[bitxor]{bit\textrm{-}xor\textrm{-}expr} \> )^*
\end{align*}

The $|$ operator with integer operands yields an integer value. It groups operands from left to right.
The result is a bitwise OR of its operands:
that is, each bit of the result will be 1 if one or both of the corresponding bits of the operands is 1; 0 otherwise.

A user-defined class can overload the $|$ operator by implementing the \bf{operator$|$} function.

\subsection{Bitwise XOR-expression}\label{bitxor}

\begin{align*}
bit\textrm{-}xor\textrm{-}expr \rightarrow \hyperref[bitand]{bit\textrm{-}and\textrm{-}expr} \> ( \> \hat{} \>\>
\hyperref[bitand]{bit\textrm{-}and\textrm{-}expr} \>)^*
\end{align*}

The \^{} operator with integer operands yields an integer value. It groups operands from left to right.
The result is a bitwise XOR of its operands:
that is, each bit of the result will be 1 if either but not both of the corresponding bits of the operands is 1; 0 otherwise.

A user-defined class can overload the \^{} operator by implementing the \bf{operator\^{}} function.

\subsection{Bitwise AND-expression}\label{bitand}

\begin{align*}
bit\textrm{-}and\textrm{-}expr \rightarrow \hyperref[equality]{equality\textrm{-}expr} \> ( \> \texttt{\&} \> \hyperref[equality]{equality\textrm{-}expr} \> )^*
\end{align*}

The \& operator with integer operands yields an integer value. It groups operands from left to right.
The result is a bitwise AND of its operands:
that is, each bit of the result will be 1 if both of the corresponding bits of the operands is 1; 0 otherwise.

A user-defined class can overload the \& operator by implementing the \bf{operator\&} function.

\subsection{Equality-expression}\label{equality}

\begin{align*}
equality\textrm{-}expr \rightarrow \hyperref[relational]{relational\textrm{-}expr} \> ( \> ( \> \texttt{==} \> | \> \texttt{!=} \> ) \>
\hyperref[relational]{relational\textrm{-}expr} \>)^*
\end{align*}

The == operator compares equality. It groups operands from left to right.

The compiler will automatically implement the != operator for a type if it implements the == operator.
Then expression a != b will be evaluated as \bf{operator!(operator==(a,b))}.

A user-defined class can overload the == and != operators by implementing the \bf{operator==} function.

\subsection{Relational Expression}\label{relational}

\begin{align*}
relational\textrm{-}expr &\rightarrow & &\hyperref[shift]{shift\textrm{-}expr} \> ( \> ( \> \texttt{<} \> | \> \texttt{>} \> | \> \texttt{<=} \> |
\> \texttt{>=} \> ) \> \hyperref[shift]{shift\textrm{-}expr} \> )^*\\
&| & &\hyperref[shift]{shift\textrm{-}expr} \> ( \> ( \> \textbf{is} \> | \> \textbf{as} \> ) \> \hyperref[typeexpr]{type\textrm{-}expr} \>)^*
\end{align*}

The $<$ operator compares less-than relationship. It groups operands from left to right.

The compiler will automatically implement operators $>$, $<=$ and $>=$ for a type if it implements the $<$ operator.
Then expression $a > b$ will be evaluated as \bf{operator$<$(b,a)},
expression $a <= b$ as \bf{operator!(operator$<$(b,a))},
expression $a >= b$ as \bf{operator!(operator$<$(a,b))}.

A user-defined class can overload the $<$ and $>$, $<=$ and $>=$ operators by implementing the \bf{operator$<$} function.

\subsubsection{\bf{Is} and \bf{As} Operators}

Consider following code:

\begin{lstlisting}[frame=trBL]
public class Base
{
    public virtual ~Base()
    {
    }
    //  ...
}

public class Derived : Base
{
    // ...
}

public Base* GetBasePtrFromSomewhere()
{
    return new Derived();
}

void main()
{
    Base* b1 = GetBasePtrFromSomewhere();
    if (b1 is Derived*)
    {
        // do something with b1
    }

    Base* b2 = GetBasePtrFromSomewhere();
    Derived* d = b2 as Derived*;
    if (d != null)
    {
        // do something with d
    }
}

\end{lstlisting}

The \bf{is} operator tests if the left operand can be legally casted to a pointer type on the right-hand side.
That is: if the pointer \emph{b1} in fact points to a \emph{Derived} class object or an object of class derived from \emph{Derived}.
The left operand of the \bf{is} operator must be a pointer to a virtual class object
\footnote{to a class object containing virtual, abstract or overridden member functions}
and the right operand must be a pointer to virtual class type. The \bf{is} operator yields a Boolean result.

The \bf{as} operator tries to convert the left operand to a pointer type on the right-hand side.
If the conversion succeeds you got a non-null pointer to \emph{Derived} class, otherwise the result is \bf{null}.
In the case of previous example the conversion succeeds if pointer \emph{b2} in fact points to \emph{Derived} class object or an object of class derived
from \emph{Derived}.
The left operand of the \bf{as} operator must be pointer to a virtual class object and the right operand must be a pointer to virtual class type.
The \bf{as} operator yields \bf{null} or non-null pointer result. It performs an operation similar to C++ \bf{dynamic\_cast}.

Note: in the \bf{debug}, \bf{release} and \bf{profile} configurations the \bf{is} and \bf{as} operators generate a call to a function
that traverses the class hierarchy, but in \bf{full} configuration the class identifiers are chosen so that the \bf{is} and \bf{as} generate only
a single modulo operation in addition to retrieving the class identifier from the run-time type information table.
In the \bf{full} configuration the compiler does whole-program analysis and implements a scheme described in
\url {http://www.stroustrup.com/fast_dynamic_casting.pdf} by Michael Gibbs and Bjarne Stroustrup.

\subsection{Shift Expression}\label{shift}

\begin{align*}
shift\textrm{-}expr \rightarrow \hyperref[additive]{additive\textrm{-}expr} \> ( \> ( \> \texttt{<<} \> | \> \texttt{>>} \> ) \>
\hyperref[additive]{additive\textrm{-}expr} \> )^*
\end{align*}

The $<<$ operator with integer operands will yield an integer value. It groups operands from left to right.
Expression $a << b$ with integer operands \emph{a} and \emph{b} will yield a value of \emph{a} shifted \emph{b} bit positions left and
filling the vacant bit positions of \emph{a} with 0-bits from right.
If \emph{a} is non-negative and \emph{b} small enough the result will be $2^ba$.

The $>>$ operator with integer operands will yield an integer value. It groups operands from left to right.
Expression $a >> b$ with integer operands \emph{a} and \emph{b} will yield a value of \emph{a} shifted \emph{b} bit positions right and
filling the vacant bit positions of \emph{a} with 0-bits from left.
If \emph{a} is non-negative the result will be $a / 2^b$ (`/' meaning integer division).

A user-defined class can overload the $<<$ and $>>$ operators by implementing the \bf{operator$<<$} and \bf{operator$>>$} functions respectively.

\subsection{Additive Expression}\label{additive}

\begin{align*}
additive\textrm{-}expr \rightarrow \hyperref[multiplicative]{multiplicative\textrm{-}expr} \> ( \> ( \> \texttt{+} \> | \> \texttt{-} \> ) \>
\hyperref[multiplicative]{multiplicative\textrm{-}expr} \>)^*
\end{align*}

The $+$ and $-$ operators with arithmetic type operands will yield same arithmetic type values.
If one of the operands is integer and one is floating-point type the integer type operand will be first converted to a floating-point type.
Resulting values with operands \emph{a} and \emph{b} will be $a + b$ and $a - b$ respectively,
if possible overflow or loss of precision is not taken account.

For $+$ and $-$ operators it is also possible that the left operand is of a pointer type (\emph{p}) and the right operand is of integer type (\emph{i}).
In that case the expression $p+i$ yields a pointer value pointing \emph{i} objects after \emph{p} in memory and
expression $p-i$ yields a pointer value pointing \emph{i} objects before \emph{p} in memory.

For $-$ operator it is also possible that both operands are of a pointer type (p and q).
In that case the expression $p-q$ yields an integer counting the number of objects between pointers \emph{p} and \emph{q}.

A user-defined class can overload the $+$ and $-$ operators by implement
the \bf{operator$+$} and \bf{operator$-$} functions respectively.

\subsection{Multiplicative Expression}\label{multiplicative}

\begin{align*}
multiplicative\textrm{-}expr \rightarrow \hyperref[prefix]{prefix\textrm{-}expr} \> ( \> ( \> \texttt{*} \> | \> \texttt{/} \> | \> \texttt{\%} \>) \>
\hyperref[prefix]{prefix\textrm{-}expr} \>)^*
\end{align*}

The $*$ and $/$ operators with arithmetic type operands will yield same arithmetic type values. They groups operands from left to right.
If one of the operands is integer and one is floating-point type the integer type operand will be first converted to a floating-point type.
Resulting values with operands \emph{a} and \emph{b} will be $a b$ and $a / b$ respectively,
if possible overflow or loss of precision is not taken account.

The $\%$ operator with integer operands will yield integer type values. It groups operands from left to right.
The resulting value will be remainder of integer division $a / b$.

A user-defined class can overload the $*$, $/$ and $\%$ operators by implement the \bf{operator$*$}, \bf{operator$/$}, and \bf{operator$\%$}
functions respectively.

\subsection{Prefix Expression}\label{prefix}

\begin{align*}
prefix\textrm{-}expr \rightarrow \> ( \> \texttt{++} \> | \> \texttt{--} \> | \> \texttt{+} \> | \> \texttt{-} \> | \>
\texttt{!} \> | \> \sim \> | \> \texttt{\&} \> | \> \texttt{*} \>) \> prefix\textrm{-}expr \> | \> \hyperref[postfix]{postfix\textrm{-}expr}
\end{align*}

The prefix \texttt{++} and \texttt{--} operators can have an integer or pointer type operand.
The operand shall be an lvalue \footnote{A variable, a reference or a result of a dereference operator.}.
When the operand is of integer type, the \texttt{++} operator will increment its operand by 1 and the operator \texttt{--} will decrement its operand by 1.
When the operand is of pointer type with pointer \emph{p} pointing to an object of type T,
the expression \texttt{++p} increments pointer \emph{p} so that \emph{p} points to next object of type T in memory.
Correspondingly \texttt{--p} decrements pointer \emph{p} so that \emph{p} points to previous object of type T in memory.
The result of an increment or decrement operator is a value of the same type as the operand after incrementing or decrementing it.

The prefix \texttt{+} and \texttt{-} operators can have an arithmetic type operand.
Expression \texttt{+p} will yield $p$ and \texttt{-p} will yield the negation of $p$.

The prefix \texttt{!} operator can have a Boolean operand. The result of !\bf{true} is \bf{false} and !\bf{false} is \bf{true}.

The $\sim$ operator can have an integer operand. It will yield a bitwise complement of its operand.

The \texttt{\&} operator shall have an lvalue operand.
If the operand is an object of type is T, it returns an address or memory location of the object.
The resulting value will be a pointer pointing to the object and it will have a type \texttt{T*}.

The \texttt{*} operator can have a pointer operand. If the operand \emph{p} is of a type pointer to T,
the expression \texttt{*p} dereferences \emph{p} yielding an lvalue of type T.

A user-defined class can overload any prefix operator \emph{op} by implement the \bf{operator\emph{op}} function.

\subsection{Postfix Expression}\label{postfix}\label{expressionlist}\label{argumentlist}

\begin{align*}
postfix\textrm{-}expr &\rightarrow & &\hyperref[primary]{primary\textrm{-}expr}\\
&( & &\hyperref[postfixincdec]{\texttt{++}}\\
&| & &\hyperref[postfixincdec]{\texttt{--}}\\
&| & &\hyperref[member]{\texttt{.}} \> \hyperref[identifier]{identifier}\\
&| & &\hyperref[ptrmember]{\texttt{->}} \> \hyperref[identifier]{identifier}\\
&| & &\hyperref[invocation]{\texttt{(} argument\textrm{-}list \texttt{)}}\\
&| & &\hyperref[indexing]{\texttt{[} expression \texttt{]}}\\
&)^*\\
argument\textrm{-}list &\rightarrow & &expression\textrm{-}list?\\
expression\textrm{-}list &\rightarrow & &\hyperref[expression]{expression} \> (\> \texttt{,} \> \hyperref[expression]{expression} \>)^*
\end{align*}

\subsubsection{Postfix Increment and Decrement Operators}\label{postfixincdec}

The postfix \texttt{++} and \texttt{--} operators can have an integer or pointer type operand. The operand shall be an lvalue.
The result of the operator is the value of the operand before incrementing or decrementing it.
When the operand is of integer type, the \texttt{++} operator will increment its operand by 1 and the operator \texttt{--} will decrement its operand by 1.
When the operand is of pointer type with pointer \emph{p} pointing to an object of type T,
the expression \texttt{p++} increments pointer \emph{p} so that \emph{p} points to next object of type T in memory.
Correspondingly \texttt{p--} decrements pointer \emph{p} so that \emph{p} points to previous object of type T in memory.

A user-defined class cannot overload the postfix forms of \texttt{++} or \texttt{--} operators.
They are automatically implemented by the compiler if the prefix versions of those operators are implemented.

\subsubsection{Member Access Operator}\label{member}

The member access operator \texttt{.} will access the member named by the right operand from the entity specified by the left operand.
The left operand can be a namespace, a class type, or an enumerated type.
The type of the expression is the type of the right operand.

\subsubsection{Pointer Member Access Operator}\label{ptrmember}

The pointer member access operator \texttt{->} will access a member named by the right operand from the entity specified by the left operand.
The left operand can be a pointer type or class type object. In the latter case the class type shall implement the \texttt{operator->}
function that returns a pointer or another class type object. The type of the expression is the type of the right operand.

\subsubsection{Invocation Operator}\label{invocation}

The invocation operator \texttt{()} will invoke a function specified by the left operand with the specified list of arguments.
The left operand can be a function, a member, an object of a class type that implements the \texttt{operator()} function or a type.
The type of the expression is the return type of the function.

\subsubsection{Indexing Operator}\label{indexing}

The the left operand of the indexing operator \texttt{[]} shall be of a pointer type, an array type or a class type object.
When the left operand is pointer \emph{p}, the expression \texttt{p[i]} is evaluated as \texttt{*(p + i)}.
When the left operand is an array, the expression \texttt{a[i]} returns a reference to the i'th element of array \emph{a},
where \emph{i} can range 0 to \emph{N} - 1, where \emph{N} is the dimension of the array \emph{a} (see \ref{postfixtypeexpr}).
When the left operand is of a class type, it shall implement the \texttt{operator[]} function taking one parameter.

\subsection{Primary Expression}\label{primary}

\begin{align*}
primary\_expr &\rightarrow & &\texttt{(} \> \hyperref[expression]{expression} \> \texttt{)}\\
&| & &\hyperref[literal]{literal}\\
&| & &\hyperref[basictype]{basic\textrm{-}type}\\
&| & &\hyperref[identifier]{identifier}\\
&| & &\textbf{typename} \> \texttt{(} \> \hyperref[expression]{expression} \> \texttt{)}\\
&| & &\textbf{this}\\
&| & &\textbf{base}\\
&| & &\hyperref[sizeof]{sizeof\textrm{-}expr}\\
&| & &\hyperref[cast]{cast\textrm{-}expr}\\
&| & &\hyperref[new]{new\textrm{-}expr}\\
&| & &\hyperref[construct]{construct\textrm{-}expr}\\
&| & &\hyperref[templateid]{template\textrm{-}id}
\end{align*}

An expression in parenthesis, a literal (\ref{literal}), a name of a basic type (\ref{sec:basictypes}) and an identifier are primary expressions.

Keyword \bf{typename} followed by an expression in parenthesis yields the full name of the dynamic type of the expression.
The type of it is \bf{const char*}.

Keyword \bf{this} represents a pointer to the current class object in class member functions.

Keyword \bf{base} represents a pointer to the base class object in class member functions.

\subsection{Size-of Expression}\label{sizeof}

\begin{align*}
sizeof\textrm{-}expr \rightarrow \textbf{sizeof} \> \texttt{(} \> \hyperref[expression]{expression} \> \texttt{)}
\end{align*}

The operand of the \bf{sizeof} operator can be a type or an entity having a type.
If the type in question is T, the operator yields constant of type \bf{ulong} that is equal to the size of object of type T in bytes.

\subsection{Cast Expression}\label{cast}

\begin{align*}
cast\textrm{-}expr \rightarrow \textbf{cast} \> \texttt{<} \> \hyperref[typeexpr]{type\textrm{-}expression} \> \texttt{>} \> \texttt{(} \>
\hyperref[expression]{expression} \> \texttt{)}
\end{align*}

The \bf{cast} operator performs explicit type conversion.
In order to the cast operation to succeeed, there shall be a built-in conversion, a conversion function (\ref{sec:conversionfunctions}) in the source type,
or a converting constructor in the target type taking one parameter of type of the source expression.

\subsection{New Expression}\label{new}

\begin{align*}
new\textrm{-}expr \rightarrow \> \textbf{new} \> \hyperref[typeexpr]{type\textrm{-}expression} \> \texttt{(} \> \hyperref[argumentlist]{argument\textrm{-}list} \> \texttt{)}
\end{align*}

The \bf{new} operator reserves memory from the free store for an object of the requested type,
constructs the object by issuing the \bf{construct} operator with the specified arguments,
and returns a pointer to the newly constructed object.

\subsection{Construct Expression}\label{construct}

\begin{align*}
construct\textrm{-}expr \rightarrow \> &\textbf{construct} \> \texttt{<} \> \hyperref[typeexpr]{type\textrm{-}expression} \> \texttt{>}\\
&\texttt{(} \> \hyperref[expressionlist]{expression\textrm{-}list} \> \texttt{)}
\end{align*}

The \bf{construct} operator takes a type, a generic pointer to memory and constructor arguments.
It constructs an object of requested type to the memory by calling the constructor with arguments,
and returns a pointer to the newly constructed object.

\subsection{Template Identifier}\label{templateid}

\begin{align*}
template\textrm{-}id &\rightarrow & &function\textrm{-}or\textrm{-}class\textrm{-}name\\
& & &\texttt{<} \> \hyperref[typeexpr]{type\textrm{-}expression} \> ( \> \texttt{,} \> \hyperref[typeexpr]{type\textrm{-}expression} \> )^* \> \texttt{>}\\
function\textrm{-}or\textrm{-}class\textrm{-}name &\rightarrow & &\hyperref[qualifiedid]{qualified\textrm{-}id}
\end{align*}

A template identifier is a primary expression.

\subsection{Type Expression}\label{typeexpr}

\begin{align*}
type\textrm{-}expression \rightarrow \hyperref[prefixtypeexpr]{prefix\textrm{-}type\textrm{-}expr}
\end{align*}

\subsubsection{Prefix Type Expression}\label{prefixtypeexpr}

\begin{align*}
prefix\textrm{-}type\_expr &\rightarrow & &\textbf{const} \> \hyperref[postfixtypeexpr]{postfix\textrm{-}type\textrm{-}expr}\\
&| & &\hyperref[postfixtypeexpr]{postfix\textrm{-}type\textrm{-}expr}
\end{align*}

A prefix type expression is either a \bf{const} qualified postfix type expression,
or sole postfix type expression.

\subsubsection{Postfix Type Expression}\label{postfixtypeexpr}

\begin{align*}
postfix\textrm{-}type\textrm{-}expr &\rightarrow & &\hyperref[primarytypeexpr]{primary\textrm{-}type\textrm{-}expr}\\
&( & &\texttt{.} \> \hyperref[identifier]{identifier}\\
&| & &\texttt{\&\&}\\
&| & &\texttt{\&}\\
&| & &\texttt{*}\\
&| & &\texttt{[} \> array\textrm{-}dimension \> \texttt{]}\\
&)^*\\
array\textrm{-}dimension &\rightarrow & &\hyperref[constantexpr]{constant\textrm{-}expression}
\end{align*}

A postfix type expression is a primary type expression optionally followed by sequence of the
following:
a member selection operator '.' and an identifier, an rvalue reference type operator (see \ref{sec:rvaluereferencetypes}),
an lvalue reference type operator (see \ref{sec:lvaluereferencetypes}), a pointer type operator (see \ref{sec:pointertypes}),
or an array type operator (see \ref{sec:arraytypes}).

\subsubsection{Primary Type Expression}\label{primarytypeexpr}

\begin{align*}
primary\textrm{-}type\textrm{-}expr &\rightarrow & &\hyperref[basictype]{basic\textrm{-}type}\\
&| & &\hyperref[templateid]{template\textrm{-}id}\\
&| & &\hyperref[identifier]{identifier}\\
&| & &\texttt{(} \> \hyperref[prefixtypeexpr]{prefix\textrm{-}type\textrm{-}expr} \> \texttt{)}
\end{align*}

A primary type expression consists of basic types, template identifiers, identifiers and parenthesized
prefix type expressions.

\subsection{Constant Expression}\label{constantexpr}

\begin{align*}
constant\textrm{-}expression \rightarrow \> \hyperref[expression]{expression}
\end{align*}

A constant expression is an expression whose value can be obtained at compile time.
A constant expression can contain literals, constants, enumeration constants and operators that
do not involve taking an address of an object.

\section{Statements}\label{statement}

Statements control the program execution logic, declare type aliases, evaluate expressions,
assign values to variables, or construct or destroy them.
A statement can be labeled by an identifier.

\begin{align*}
statement &\rightarrow \> & &( \> \hyperref[identifier]{identifier} \texttt{:} \> )?\\
&( & &\hyperref[controlstatement]{control\textrm{-}statement}\\
&| & &\hyperref[typedefstatement]{typedef\textrm{-}statement}\\
&| & &\hyperref[simplestatement]{simple\textrm{-}statement}\\
&| & &\hyperref[assignmentstatement]{assignment\textrm{-}statement}\\
&| & &\hyperref[constructionstatement]{construction\textrm{-}statement}\\
&| & &\hyperref[deletestatement]{delete\textrm{-}statement}\\
&| & &\hyperref[destroystatement]{destroy\textrm{-}statement}\\
&| & &\hyperref[throwstatement]{throw\textrm{-}statement}\\
&| & &\hyperref[trystatement]{try\textrm{-}catch\textrm{-}statement}\\
&| & &\hyperref[assertstatement]{assert\textrm{-}statement}\\
&| & &\hyperref[conditionalcompilationstatement]{conditional\textrm{-}compilation\textrm{-}statement}\\
&)
\end{align*}

\subsection{Control Statements}\label{controlstatement}

The control statements control statement execution order.

\begin{align*}
control\textrm{-}statement &\rightarrow & &\hyperref[returnstatement]{return\textrm{-}statement}\\
&| & &\hyperref[conditionalstatement]{conditional\textrm{-}statement}\\
&| & &\hyperref[switchstatement]{switch\textrm{-}statement}\\
&| & &\hyperref[whilestatement]{while\textrm{-}statement}\\
&| & &\hyperref[dostatement]{do\textrm{-}statement}\\
&| & &\hyperref[rangeforstatement]{range\textrm{-}for\textrm{-}statement}\\
&| & &\hyperref[forstatement]{for\textrm{-}statement}\\
&| & &\hyperref[compoundstatement]{compound\textrm{-}statement}\\
&| & &\hyperref[breakstatement]{break\textrm{-}statement}\\
&| & &\hyperref[continuestatement]{continue\textrm{-}statement}\\
&| & &\hyperref[gotostatement]{goto\textrm{-}statement}
\end{align*}

\subsubsection{Return Statement}\label{returnstatement}

The \bf{return} statement returns control from a function to its caller.
When the return type of the function is other than \bf{void}
the return statement is mandatory, and
there shall be a return value expression,
otherwise there shall be no return value expression,
and the return statement is optional.

\begin{align*}
return\textrm{-}statement \rightarrow \textbf{return} \> \hyperref[expression]{expression}? \> \texttt{;}
\end{align*}

\subsubsection{Conditional Statement}\label{conditionalstatement}

The conditional statement executes a statement if its condition expression is \bf{true}.
Otherwise, if there is an else statement, it is executed.
The condition shall be a Boolean expression.

\begin{align*}
conditional\textrm{-}statement \rightarrow \> \textbf{if} \> \texttt{(} \> \hyperref[expression]{expression} \> \texttt{)}
\> \hyperref[statement]{statement} \> ( \> \textbf{else} \> \hyperref[statement]{statement} \> )?
\end{align*}

\subsubsection{Switch Statement}\label{switchstatement}

The \bf{switch} statement evaluates its condition expression
and executes the matching case statement.
Each control path of the \bf{case} statement shall
end with \bf{break}, \bf{goto case} or \bf{goto default} statement,
that is: the control is not allowed to ``fall through''.
Multiple cases can be grouped into one \bf{case} statement, though.
The condition expression and each case expression shall evaluate to a compile time constant.

\begin{align*}
switch\textrm{-}statement &\rightarrow \> & &\textbf{switch} \> \texttt{(} \> \hyperref[constantexp]{constant\textrm{-}expression} \> \texttt{)}\\
& & &\texttt{\{} \> ( \> case\textrm{-}statement \> | \> default\textrm{-}statement \>)^* \> \texttt{\}}\\
case\textrm{-}statement &\rightarrow \> & &( \> \textbf{case} \> \hyperref[constantexpr]{constant\textrm{-}expression} \> \texttt{:} \> )^+\\
& & &( \>  \> goto\textrm{-}case\textrm{-}statement \> | \> goto\textrm{-}default\textrm{-}statement \> | \> \hyperref[statement]{statement} \>)^*\\
goto\textrm{-}case\textrm{-}statement &\rightarrow & &\textbf{goto} \> \textbf{case} \> \hyperref[constantexpr]{constant\textrm{-}expression} \> \texttt{;}\\
goto\textrm{-}default\textrm{-}statement & \rightarrow & &\textbf{goto} \> \textbf{default} \> \texttt{;}\\
default\textrm{-}statement & \rightarrow & &\textbf{default} \> \texttt{:} \> ( \>
goto\textrm{-}case\textrm{-}statement \> | \> \hyperref[statement]{statement} \> )^*
\end{align*}

\subsubsection{While Statement}\label{whilestatement}

The \bf{while} statement repeatedly evaluates its condition expression and executes a statement as long as the condition evaluates to \bf{true}.
The condition shall be a Boolean expression.

\begin{align*}
while\textrm{-}statement \rightarrow \> \textbf{while} \> \texttt{(} \> \hyperref[expression]{expression} \> \texttt{)} \> \hyperref[statement]{statement}
\end{align*}

\subsubsection{Do Statement}\label{dostatement}

The \bf{do} statement repeatedly executes a statement and then evaluates its condition expression until the condition evaluates to \bf{false}.
The condition shall be a Boolean expression.

\begin{align*}
do\textrm{-}statement \rightarrow \> \textbf{do} \> \hyperref[statement]{statement} \> \textbf{while} \> \texttt{(} \>
\hyperref[expression]{expression} \> \texttt{)} \> \texttt{;}
\end{align*}

\subsubsection{Range-for Statement}\label{rangeforstatement}
The \bf{range-for} statement iterates through a container.
For each iteration, a variable is bound to each value in the container and then a statement is executed.
The \emph{container} shall be an expression that will yield an object that is a container having \emph{Begin()} and \emph{End()} member functions
that return iterators to the beginning and one-past-the-end of a container respectively.

\begin{align*}
range\textrm{-}for\textrm{-}statement &\rightarrow \> \textbf{for} \> \texttt{(} \hyperref[typeexpr]{type\textrm{-}expression} \>
\hyperref[identifier]{identifier} \> \texttt{:} \> container \> \texttt{)} \> \hyperref[statement]{statement}\\
container &\rightarrow \> \hyperref[expression]{expression}
\end{align*}

\subsubsection{For Statement}\label{forstatement}

The \bf{for} statement first initializes a variable and then
repeatedly evaluates a condition expression and executes a statement as long as the condition evaluates to \bf{true}.
After each execution cycle an expression that typically increments a condition variable is evaluated.
The condition shall be a Boolean expression.
The initialization statement is optional as are the condition and increment expressions in which case they are evaluated as \bf{true}.

\begin{align*}
for\textrm{-}statement &\rightarrow \> \textbf{for} \> \texttt{(} \> for\textrm{-}init\textrm{-}statement \>
\hyperref[expression]{expression}? \> \texttt{;} \> \hyperref[expression]{expression}? \> \texttt{)} \> \hyperref[statement]{statement}\\
for\textrm{-}init\textrm{-}statement &\rightarrow \> \hyperref[assignmentstatement]{assignment\textrm{-}statement} \> | \>
\hyperref[constructionstatement]{construction\textrm{-}statement} \> | \> \texttt{;}
\end{align*}

\subsubsection{Compound Statement}\label{compoundstatement}

The compound statement executes a sequence of statements in order. The statement sequence can be empty.

\begin{align*}
compound\textrm{-}statement \rightarrow \> \texttt{\{} \> \hyperref[statement]{statement}^* \> \texttt{\}}
\end{align*}

\subsubsection{Break Statement}\label{breakstatement}

The \bf{break} statement transfers control to the statement coming after its closest containing \bf{switch}, \bf{while}, \bf{do} or \bf{for} statement,
if there is one; otherwise to the end of the function.

\begin{align*}
break\textrm{-}statement \rightarrow \> \textbf{break} \> \texttt{;}
\end{align*}

\subsubsection{Continue Statement}\label{continuestatement}

The \bf{continue} statement transfers control to the end of the closest containing \bf{while}, \bf{do} or \bf{for} loop.

\begin{align*}
continue\textrm{-}statement \rightarrow \> \textbf{continue} \> \texttt{;}
\end{align*}

\subsubsection{Goto Statement}\label{gotostatement}

The \bf{goto} statement transfers control to the statement labeled with the matching identifier.

\begin{align*}
goto\textrm{-}statement \rightarrow \> \textbf{goto} \> \hyperref[identifier]{identifier} \> \texttt{;}
\end{align*}

\subsection{Typedef Statement}\label{typedefstatement}

The \bf{typedef} statement declares an alias name to a type expression.

\begin{align*}
typedef\textrm{-}statement \rightarrow \> \textbf{typedef} \> \hyperref[typeexpr]{type\textrm{-}expression} \> \hyperref[identifier]{identifier} \> \texttt{;}
\end{align*}

\subsection{Simple Statement}\label{simplestatement}

The simple statement evaluates an expression if there is one, otherwise it does nothing.
Typically the expression is a function call, or incrementation or decrementation of a variable.

\begin{align*}
simple\textrm{-}statement \rightarrow \> \hyperref[expression]{expression}? \> \texttt{;}
\end{align*}

\subsection{Assignment Statement}\label{assignmentstatement}

The assignment statement assign a value to an target object. The target expression shall be an lvalue expression.

\begin{align*}
assignment\textrm{-}statement \rightarrow \> \hyperref[expression]{expression} \> \texttt{=} \> \hyperref[expression]{expression} \> \texttt{;}
\end{align*}

\subsection{Construction Statement}\label{constructionstatement}

The construction statement constructs a local variable.
If the variable is not of a class type, it fits into a register, its address is not taken,
and it is not passed by reference argument, a register for the variable is allocated,
otherwise space for the variable is reserved from the execution stack.
If an initialization expression or expression list is given, the constructor for the variable is called with the given arguments,
otherwise the variable is default-constructed.

\begin{align*}
construction\textrm{-}statement &\rightarrow \> \hyperref[typeexpr]{type\textrm{-}expression} \>
\hyperref[identifier]{identifier} \> initialization? \> \texttt{;}\\
initialization &\rightarrow \> \texttt{(} \> \hyperref[expressionlist]{expression\textrm{-}list} \> \texttt{)} \> | \> \texttt{=} \> \hyperref[expression]{expression}
\end{align*}

\subsection{Delete Statement}\label{deletestatement}

The \bf{delete} statement calls the destructor of an object if there is one, and then releases the memory reserved for the object back to the free store.
The expression shall evaluate to a pointer to the object.
If the object has a virtual destructor, it is called, otherwise the destructor for the pointee type of the pointer type is called.

\begin{align*}
delete\textrm{-}statement \rightarrow \> \textbf{delete} \> \hyperref[expression]{expression} \> \texttt{;}
\end{align*}

\subsection{Destroy Statement}\label{destroystatement}

The \bf{destroy} statement calls the destructor for an object but does not release memory reserved for the object.
The expression shall evaluate to a pointer to the object.
If the object has a virtual destructor, it is called, otherwise the destructor for the pointee type of the pointer type is called.

\begin{align*}
destroy\textrm{-}statement \rightarrow \> \textbf{destroy} \> \hyperref[expression]{expression} \> \texttt{;}
\end{align*}

\subsection{Throw Statement}\label{throwstatement}

The \bf{throw} statement causes an exception object to be thrown. The expression shall construct a class object to throw.
The exception object includes the source line number and the source file name of the throw statement.

\begin{align*}
throw\textrm{-}statement \rightarrow \> \textbf{throw} \> \hyperref[expression]{expression} \> \texttt{;}
\end{align*}

\subsection{Try-Catch Statement}\label{trystatement}

The \bf{try-catch} statement executes statements in a try-block and if an exception is thrown, control is transfered
to a matching exception handler. Each exception handler handles exceptions that are the same type as or a type derived from
the type of the variable of the exception handler. First matching handler is executed, so the handlers should be
ordered from the most specific to the most general.

\begin{align*}
try\textrm{-}catch\textrm{-}statement &\rightarrow \> \textbf{try} \> try\textrm{-}block \> exception\textrm{-}handler^+\\
try\textrm{-}block &\rightarrow \> \hyperref[compoundstatement]{compound\textrm{-}statement}\\
exception\textrm{-}handler &\rightarrow \> \textbf{catch} \> \texttt{(} \> \hyperref[typeexpr]{type\textrm{-}expression} \>
\hyperref[identifier]{identifier} \> \texttt{)} \> catch\textrm{-}block\\
catch\textrm{-}block &\rightarrow \> \hyperref[compoundstatement]{compound\textrm{-}statement}
\end{align*}

\subsection{Assert Statement}\label{assertstatement}

The \verb|#| \bf{assert} statement tests a condition that should always be true.
If the condition is false, an error message containing the failed expression, a source line number and a source file name is issued and the program is exited.

Assert statements are skipped when compiling a program using \bf{release} configuration.

\begin{align*}
assert\textrm{-}statement \rightarrow \> \texttt{\#}\textbf{assert} \> \texttt{(} \hyperref[expression]{expression} \> \texttt{)} \> \texttt{;}
\end{align*}

\subsection{Conditional Compilation Statement}\label{conditionalcompilationstatement}

The conditional compilation statement makes it possible to include statements in compilation
based on conditional compilation symbols.

When compiling a program using \bf{debug} configuration (default), the symbol DEBUG is defined.
When compiling a program using \bf{release} configuration, the symbol RELEASE is defined.
When compiling a program using Cmajor compiler in Windows, a symbol WINDOWS is defined.
When compiling a program using Cmajor compiler in Linux, a symbol LINUX is defined.

Users can define other conditional compilation symbols in IDE or using the -D command line option.

\begin{align*}
conditional\textrm{-}compilation\textrm{-}statement &\rightarrow & &cond\textrm{-}comp\textrm{-}if\textrm{-}statement\\
cond\textrm{-}comp\textrm{-}if\textrm{-}statememt &\rightarrow & &\texttt{\#} \textbf{if} \> \texttt{(} \> cond\textrm{-}comp\textrm{-}expr \> \texttt{)} \>
statement\textrm{-}list\\
& & &(\> \texttt{\#} \textbf{elif} \> \texttt{(} \> cond\textrm{-}comp\textrm{-}expr \> \texttt{)} \> statement\textrm{-}list \>)^*\\
& & &(\> \texttt{\#} \textbf{else} \> statement\textrm{-}list \>)? \> \texttt{\#} \textbf{endif}\\
cond\textrm{-}comp\textrm{-}expr &\rightarrow & &cond\textrm{-}comp\textrm{-}disjunction\\
cond\textrm{-}comp\textrm{-}disjunction &\rightarrow & &cond\textrm{-}comp\textrm{-}conjunction \> (\texttt{||} \>
cond\textrm{-}comp\textrm{-}conjunction )^*\\
cond\textrm{-}comp\textrm{-}conjunction &\rightarrow & &cond\textrm{-}comp\textrm{-}prefix \> (\texttt{\&\&} \> cond\textrm{-}comp\textrm{-}prefix )^*\\
cond\textrm{-}comp\textrm{-}prefix &\rightarrow & &cond\textrm{-}comp\textrm{-}not \> | \> cond\textrm{-}comp\textrm{-}primary\\
cond\textrm{-}comp\textrm{-}not &\rightarrow & &\texttt{!} \> cond\textrm{-}comp\textrm{-}prefix\\
cond\textrm{-}comp\textrm{-}primary &\rightarrow & &\hyperref[identifier]{identifier} \> | \> \texttt{(} \> cond\textrm{-}comp\textrm{-}expr \> \texttt{)}\\
statement\textrm{-}list &\rightarrow & &\hyperref[statement]{statement}^*
\end{align*}

The \bf{cond-comp-if} statement includes a list of statements in compilation
if its conditional compilation expression evaluates true,
otherwise, if one of the \bf{elif} conditional compilation expressions evaluates true,
the statements in that \bf{elif}-part is included in compilation, otherwise,
if the \bf{else}-part is given, the list of statements in \bf{else}-part is
included to compilation.

Conditional compilation disjunction expression evaluates to true,
if one of conditional compilation conjunction expressions it contains evaluates to true.

Conditional compilation conjunction expression evaluates to true,
if all conditional compilation prefix expressions it contains evaluate to true.

Conditional compilation prefix expression can be either conditional compilation not-expression
or conditional compilation primary expression.

Conditional compilation not-expression evaluates to true if its conditional compilation
prefix expression evaluates to false.

Conditional compilation primary expression can be an conditional compilation identifier or
parenthesized conditional compilation expression.

Conditional compilation identifier evaluates to true if it is defined.

\section{Access Specifiers}\label{accessspecifier}

Most entities defined within a class or a namespace can be given access specifiers that grant or reject access for another entity.

\begin{itemize}
\item{\bf{public}} access grants access from everywhere.

\item{\bf{protected}} access specifier grants access for an entity defined within the same or derived class and rejects it for other entities.

\item{\bf{private}} access specifier grants access for an entity defined within the same class and rejects it for other entities.

\item{\bf{internal}} access specifier grants access for an entity defined in the same program or library and rejects it for other entities.
\end{itemize}

\begin{align*}
access\textrm{-}specifier &\rightarrow \textbf{public} \> | \> \textbf{protected} \> | \> \textbf{private} \> | \> \textbf{internal}
\end{align*}

If no access specifiers are given, the default access for a namespace level entity is \bf{internal} access, and for a class level entity it is \bf{private} access.

\section{Functions}\label{functiondefinition}\label{templateparameterlist}\label{parameters}\label{parameterlist}\label{functionbody}\label{functionname}

A function represents a unit of computation that can be executed from the other parts of the program or from the function body itself.
When the function is called, each of the argument expressions of the function call is evaluated and bound to the corresponding parameter of the function.
Then the function body is executed and after that the control returns to the caller.

\begin{align*}
function\textrm{-}definition &\rightarrow & &function\textrm{-}specifiers \> \hyperref[typeexpr]{type\textrm{-}expression} \> function\textrm{-}name\\
& & &template\textrm{-}parameter\textrm{-}list? \> parameters \> \hyperref[wherecontraint]{where\textrm{-}constraint}?\\
& & &function\textrm{-}body\\
function\textrm{-}specifiers &\rightarrow & &(\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \> \textbf{inline} \> | \>
\textbf{cdecl} \> | \> \textbf{nothrow} \> | \> \textbf{throw} \> | \> \textbf{unit\_test} \>\\
& & &| \> \textbf{constexpr})^*\\
function\textrm{-}name &\rightarrow & &\hyperref[identifier]{identifier} \> | \> operator\textrm{-}function\textrm{-}name\\
operator\textrm{-}function\textrm{-}name &\rightarrow & &\textbf{operator}\\
& & &( \texttt{<<} \> | \> \texttt{>>} \> | \> \texttt{==} \> | \> \texttt{<} \> | \> \texttt{=} \> | \>
\texttt{++} \> | \> \texttt{--} \> | \> \texttt{->} \> | \> \texttt{+} \> | \> \texttt{-} \> | \> \texttt{*} \> | \> \texttt{/} \> | \> \texttt{\%} \> | \>
\texttt{\&} \> | \> \texttt{|} \> | \> \texttt{!} \> | \> \sim | \> \texttt{[]} \> | \> \texttt{()} \>)\\
template\textrm{-}parameter\textrm{-}list &\rightarrow & &\texttt{<} \> template\textrm{-}parameter \> (\texttt{,} \> template\textrm{-}parameter)^* \> \texttt{>}\\
template\textrm{-}parameter &\rightarrow & &\hyperref[identifier]{identifier} \> default\textrm{-}template\textrm{-}parameter?\\
default\textrm{-}template\textrm{-}parameter &\rightarrow & &\texttt{=} \> \hyperref[typeexpr]{type\textrm{-}expression}\\
parameters &\rightarrow & &\texttt{(} \> parameter\textrm{-}list? \> \texttt{)}\\
parameter\textrm{-}list &\rightarrow & &parameter (\> \texttt{,} \> parameter \> )^*\\
parameter &\rightarrow & &\hyperref[typeexpr]{type\textrm{-}expression} \> \hyperref[identifier]{identifier}?\\
function\textrm{-}body &\rightarrow & &\hyperref[compoundstatement]{compound\textrm{-}statement}
\end{align*}

\subsection{Function Specifiers}

\subsubsection{Inline Specifier}

\bf{inline} specifier is a hint to optimizer that
it should replace function body in place of function call when applicable.

\subsubsection{CDecl Specifier}

\bf{cdecl} specifier suppresses name mangling \footnote{name mangling encodes parameter types to the function name},
so that the function can easily called from C language.

\subsubsection{Nothrow Specifier}

\bf{nothrow} specifier states that the function will not throw Cmajor exceptions directly or indirectly,
or that the function handles all exceptions (catches \emph{System.Exception})
and does not deliberately throw any exception from catch blocks. \footnote{semantics changed from version 2.0.}

\subsubsection{Throw Specifier}

\bf{throw} specifier emphasizes that the function might throw a Cmajor exception.

\subsubsection{Unit Test Specifier}

\bf{unit\_test} specifier has a meaning in programs intended as input to the \bf{cmunit} program.

\subsubsection{Constexpr Specifier}\label{constexprfun}

\bf{constexpr} specifier states that the compiler must evaluate the function at compile time when function arguments are expressions that consist of
literals, constants or enumeration constants. A \bf{constexpr} function cannot contain \bf{switch}, \bf{case}, \bf{default},
\bf{goto case}, \bf{goto default}, \bf{goto}, \bf{assert}, \bf{throw}, or \bf{try} statements.
When function arguments cannot be evaluated at compile time, the function behaves just like an ordinary function.

\subsection{Function Templates}

A function that contains a template parameter list is said to be a \emph{function template}.
A function template is parameterized by one or more type parameters.
An optional default value can be provided for a template parameter. There cannot be a non-default
template parameter coming after a default template parameter.

\subsubsection{Constrained Function Templates}

A function template that has a \hyperref[whereconstraint]{where\textrm{-}constraint} is said to be a
\emph{constrained function template}.
The where-constraint sets requirements for template type parameters.

\subsubsection{Function Template and Overload Resolution}

Function templates participate overload resolution process.
In overload resolution the template parameters are deduced from the types of function call arguments.
The type parameters can also be explicitly specified using a \hyperref[templateid]{template identifier}.
After the type parameters are deduced or explicitly specified, the function template is instantiated,
and it becomes a concrete function.
The type-checking of an unconstrained function template is deferred until instantiation time.

\section{Derived Types}

\subsection{Pointer Types}\label{sec:pointertypes}

If $\tau$ is a \hyperref[typeexpr]{type expression}, $\tau*$ creates a new type representing a pointer to an object of type $\tau$.
The default value of a pointer type object is \bf{null}.

Unary operators \texttt{*} and \texttt{->}, prefix operators \texttt{++} and \texttt{--},
binary operators \texttt{+}, \texttt{-}, \texttt{==} and \texttt{<},
and the indexing operator \texttt{[]} operate on pointer type operands.

A pointer type value can be implicitly converted to a generic pointer type \bf{void$*$}.

\subsubsection{Generic Pointer Type}

The type \bf{void$*$} represents a generic pointer to a memory location or it is \bf{null}.
The memory location can hold an object or it can be a location in the free store that
may or may not hold an object.
The default value of a generic pointer type object is \bf{null}.

Generic pointers can be compared for equality using the \texttt{==} operator.
The generic pointer type can be converted to any other pointer type with an explicit \bf{cast}.

\subsubsection{Null Pointer Type}

The null pointer type represents a pointer that does not point to any object or any location in the free store.
The value of a null pointer type object is \bf{null}.
Any pointer type can be compared with \bf{null} for equality using the \texttt{==} operator.

\subsection{Lvalue Reference Types}\label{sec:lvaluereferencetypes}

If $\tau$ is a \hyperref[typeexpr]{type expression}, $\tau\&$ creates a new type representing an lvalue reference to an object of type $\tau$.
Lvalue reference type objects do not have a default value and they must be initialized to refer to an object in some memory location.

If T is an object type, type T\& supports the same operators as T does.

Type T\& (an lvalue reference to an object of type T) can be implicitly converted to type \bf{const} T\&
(an lvalue reference to a constant object of type T).

\subsection{Rvalue Reference Types}\label{sec:rvaluereferencetypes}

If $\tau$ is a \hyperref[typeexpr]{type expression}, $\tau\&\&$ creates a new type representing an rvalue reference to an object of type $\tau$.
Rvalue references are used to implement move semantics.

\subsection{Array Types}\label{sec:arraytypes}

If $\tau$ is a \hyperref[typeexpr]{type expression}, $\tau[N]$ creates a new type representing an array whose element type is $\tau$ and dimension is $N$.

Currently only single-dimensional arrays whose element type is a \hyperref[basictype]{basic type} or
a \hyperref[sec:classtypes]{class type} are supported.
The dimension $N$ must be a \hyperref[constantexpr]{constant expression}.

Indexing operator \texttt{[]} operates on array type operands (\ref{indexing}).

\subsection{Constant Types}

If $\tau$ is a \hyperref[typeexpr]{type expression}, \bf{const} $\tau$ creates a new type representing a constant object of type $\tau$.
The default value of type \bf{const} $\tau$ is the same as the default value of type $\tau$.

If T is an object type, type \bf{const} T supports those operators of type T that do not change the value of object of type T.

Type T can be implicitly converted to type \bf{const} T.

\section{User-defined Types}

\subsection{Enumerated Types}\label{sec:enumerations}\label{enumeratedtypedefinition}

An enumerated type is used to create an integral type with a set of named constants.
Each constant will have a value of type \bf{int} that is distinct
from the values of other constants within the same enumerated type.

\begin{align*}
enumerated\textrm{-}type\textrm{-}definition &\rightarrow & &\hyperref[accessspecifier]{access\textrm{-}specifier}? \> \textbf{enum} \>
\hyperref[identifier]{identifier}\\
& & &\texttt{\{} \> enumeration\textrm{-}constant \> (\texttt{,} \> enumeration\textrm{-}constant)^* \> \texttt{\}}\\
enumeration\textrm{-}constant &\rightarrow & &\hyperref[identifier]{identifier} \> (\texttt{=} \> \hyperref[constantexpr]{constant\textrm{-}expression})?
\end{align*}

The default value of an enumerated type object is 0, whether it is represented by a named constant or not.

If the first constant is not explicitly given a value, it will have a value 0.
If any other constant is not explicitly given a value, it will have the value of the previous constant + 1.

\subsection{Class Types}\label{sec:classtypes}\label{classdefinition}

A class type is used to define a user-defined type that can contain data members, type aliases, constants, member functions and subtypes.

\begin{align*}
class\textrm{-}definition &\rightarrow & &class\textrm{-}specifiers \> \textbf{class} \> \hyperref[identifier]{identifier}\\
class\textrm{-}specifiers &\rightarrow & &(\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \> \textbf{static} \> | \> \textbf{abstract})^*\\
& & &\hyperref[templateparameterlist]{template\textrm{-}parameter\textrm{-}list}?\\
& & &inheritance\textrm{-}and\textrm{-}implemented\textrm{-}interfaces?\\
& & &\hyperref[whereconstraint]{where\textrm{-}constraint}? \> \texttt{\{} \> class\textrm{-}content \> \texttt{\}}\\
%class\textrm{-}specifiers &\rightarrow & &(\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \> \textbf{static} \> | \> \textbf{abstract})^*\\
inheritance\textrm{-}and\textrm{-}implemented\textrm{-}interfaces &\rightarrow & &\texttt{:} \>
base\textrm{-}class\textrm{-}or\textrm{-}implemented\textrm{-}interface\\
& & &(\texttt{,} \> base\textrm{-}class\textrm{-}or\textrm{-}implemented\textrm{-}interface)^*\\
base\textrm{-}class\textrm{-}or\textrm{-}implemented\textrm{-}interface &\rightarrow & &\hyperref[templateid]{template\textrm{-}id} \> |
\> \hyperref[qualifiedid]{qualified\textrm{-}id}\\
class\textrm{-}content &\rightarrow\\
&( & &\hyperref[staticconstructor]{static\textrm{-}constructor}\\
&| & &\hyperref[constructor]{constructor}\\
&| & &\hyperref[destructor]{destructor}\\
&| & &\hyperref[memberfunction]{member\textrm{-}function}\\
&| & &\hyperref[conversionfunction]{conversion\textrm{-}function}\\
&| & &\hyperref[sec:enumerations]{enumerated\textrm{-}type\textrm{-}definition}\\
&| & &\hyperref[constantdeclaration]{constant\textrm{-}declaration}\\
&| & &\hyperref[membervariabledeclaration]{member\textrm{-}variable\textrm{-}declaration}\\
&| & &\hyperref[typedefdeclaration]{typedef\textrm{-}declaration}\\
&| & &\hyperref[delegatedefinition]{delegate\textrm{-}definition}\\
&| & &\hyperref[classdelegatedefinition]{class\textrm{-}delegate\textrm{-}definition}\\
&| & &\hyperref[classdefinition]{class\textrm{-}definition}\\
&)^*
\end{align*}

A class type can be regular, \bf{static} or \bf{abstract}.

\subsubsection{Regular Class Types}

A regular class can contain each kind of class content members.

\subsubsection{Static Class Types}

A \bf{static} class can contain
\begin{itemize}
\item a static constructor
\item static data members
\item static member functions
\item constants
\item typedef declarations
\item delegate and class delegate definitions
\item subtypes
\end{itemize}

\subsubsection{Abstract Class Types}

A class that contains one or more abstract member functions shall be declared \bf{abstract}.
One cannot create an object of an abstract class.
Each concrete class that derives from an abstract class shall override each of the
abstract member functions of an abstract base class.

\subsubsection{Class Templates}

A class that contains a template parameter list is said to be a \emph{class template}.
A class template is parameterized by one or more type parameters.
When a template name (\ref{sec:templateid}) is specified with the type argument expressions,
the class template is instantiated, and becomes a concrete class.
The type-checking of a class template is deferred until instantiation time.

\subsubsection{Inheritance and implemented interfaces}

A class or a class template can derive at most from one class or a class template.
Derived class \emph{inherits} members of the \emph{base class}.
A derived class can \emph{override} virtual, overridden and abstract member functions of the base class.

A class can implement any number of \hyperref[sec:interface]{\emph{interfaces}}.
When a class implements an interface it provides an implementation for all of the member functions of the interface.
The signatures of the class member functions must match the interface member function signatures and possible \bf{nothrow}-specifications
exactly.

\subsubsection{Constrained Class Templates}

A class template that has a \hyperref[whereconstraint]{where\textrm{-}constraint} is said to be a \emph{constrained class template}.
The where-constraint sets requirements for template type parameters.

\subsubsection{Static Constructor}\label{staticconstructor}

The identifier of the static constructor shall be equal to the name of the class type.
The purpose of the static constructor is to initialize the static member variables of a class object on its first call.
The static constructor is called from each constructor and each static member function of a class type
before taking other actions.

\begin{align*}
static\textrm{-}constructor &\rightarrow & &\textbf{static} \> static\textrm{-}constructor\textrm{-}class\textrm{-}name \> \texttt{(} \> \texttt{)}\\
& & &(\texttt{:} \> static\textrm{-}initializer\textrm{-}list)? \> \hyperref[functionbody]{function\textrm{-}body}\\
static\textrm{-}constructor\textrm{-}class\textrm{-}name &\rightarrow & &\hyperref[identifier]{identifier}\\
static\textrm{-}initializer\textrm{-}list &\rightarrow & &static\textrm{-}initializer \> (\> \texttt{,} \> static\textrm{-}initializer \>)^*\\
static\textrm{-}initializer &\rightarrow & &\hyperref[identifier]{identifier} \> \texttt{(} \> \hyperref[argumentlist]{argument\textrm{-}list} \> \texttt{)}
\end{align*}

\subsubsection{Constructors}\label{constructor}

The identifier of the constructor shall be equal to the name of the class type.
The purpose of a constructor is to initialize non-static member variables of a class type,
and to establish a class invariant.

An initializer of a constructor can delegate initialization to another constructor of
the same class using the \bf{this} keyword.
The initializer can call a base class constructor using the \bf{base} keyword.

If a non-static class has no user-defined constructor, the compiler will implement a default constructor that constructs
each non-static member variable to its default value.

If a non-static class has no user-defined copy constructor,
no user-defined move constructor, no user-defined copy assignment, no user-defined move assignment and no user-defined destructor,
the compiler will implement a copy constructor that
copy-constructs each non-static member variable from the corresponding member variable of the constructor argument.
The compiler will also implement a move constructor that moves each non-static member variable from the corresponding
member variable of the constructor argument in that case.

This automatic generation of default constructor, copy constructor and move constructor can be suppressed using the \bf{suppress} keyword.

Generation of default constructor, copy constructor and move constructor can be explicitly requested by using the \bf{default} keyword.

\begin{align*}
constructor &\rightarrow & &constructor\textrm{-}specifiers \> constructor\textrm{-}class\textrm{-}name\\
& & &\texttt{(} \> \hyperref[parameterlist]{parameter\textrm{-}list}? \> \texttt{)} \> (\texttt{:} \> initializer\textrm{-}list)? \>
\hyperref[functionbody]{function\textrm{-}body}\\
constructor\textrm{-}specifiers &\rightarrow & &(\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \>
\textbf{suppress} \> | \> \textbf{default} \> | \> \textbf{inline} \> | \> \textbf{nothrow} \> | \> \textbf{throw})^*\\
constructor\textrm{-}class\textrm{-}name &\rightarrow & &\hyperref[identifier]{identifier}\\
initializer\textrm{-}list &\rightarrow & &initializer \> (\texttt{,} \> initializer)^*\\
initializer &\rightarrow & &(\hyperref[identifier]{identifier} \> | \> \textbf{this} \> | \> \textbf{base}) \> \texttt{(} \>
\hyperref[argumentlist]{argument\textrm{-}list} \> \texttt{)}
\end{align*}

\clearpage
\begin{lstlisting}[frame=trBL]
public class Foo
{
    public Foo()                // default constructor
    {
        //  ...
    }
    public Foo(const Foo& that) // copy constructor
    {
        //  ...
    }
    public Foo(Foo&& that)      // move constructor
    {
        //  ...
    }
}

public class Bar
{
    default Bar();              // compiler will implement memberwise default constructor
    default Bar(const Bar&);    // compiler will implement memberwise copy constructor
    default Bar(Bar&&);         // compiler will implement memberwise move constructor
}

public class Baz
{
    suppress Baz();             // automatic generation of default constructor is suppressed
    suppress Baz(const Baz&);   // automatic generation of copy constructor is suppressed
    suppress Baz(Baz&&);        // automatic generation of move constructor is suppressed
}
\end{lstlisting}

\subsubsection{Destructor}\label{destructor}

The identifier of the destructor shall be equal to the name of the class type.
The purpose of a destructor is to destroy non-static member variables of a class type, release allocated resources,
and to tear down the class invariant.

\begin{align*}
destructor &\rightarrow & &destructor\textrm{-}specifiers \> \sim{}destructor\textrm{-}class\textrm{-}name \> \texttt{(} \> \texttt{)}\\
& & &\hyperref[functionbody]{function\textrm{-}body}\\
destructor\textrm{-}specifiers &\rightarrow & &(\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \> \textbf{virtual} \> | \>
\textbf{override} \> | \> \textbf{default} \> | \> \textbf{inline})^*\\
destructor\textrm{-}class\textrm{-}name &\rightarrow & &\hyperref[identifier]{identifier}
\end{align*}

If the class type has a base class that has a virtual destructor, the destructor shall be declared with override specifier;
otherwise, if the class type contains virtual functions, the destructor is automatically set virtual.

If a non-static class has no user-defined destructor,
no user-defined copy constructor, no user-defined move constructor, no user-defined copy assignment, no user-defined move assignment, and
(1) the class has virtual functions,
or (2) at least one member variable has a non-trivial destructor,
or (3) a class has a base class that has a non-trivial destructor,
the compiler will implement a destructor that destroys all non-static member variables.

Generation of destructor can be explicitly requested by using the \bf{default} keyword.

\begin{lstlisting}[frame=trBL]
public class Foo
{
    public ~Foo()   // destructor
    {
        // ...
    }
}

public class Bar
{
    default ~Bar(); // compiler will implement memberwise destructor
}
\end{lstlisting}

\subsubsection{Member Functions}\label{memberfunction}

A member function operates on member variables a class object or class type and can call
other member functions of its class.
A member function can be virtual, overridden, abstract, static or regular.

\begin{align*}
member\textrm{-}function &\rightarrow & &member\textrm{-}function\textrm{-}specifiers \> \hyperref[typeexpr]{type\textrm{-}expression}\\
& & &\hyperref[functionname]{function\textrm{-}name} \> \texttt{(} \> \hyperref[parameterlist]{parameter\textrm{-}list}? \> \texttt{)} \> \textbf{const}?\\
& & &(\hyperref[functionbody]{function\textrm{-}body} \> | \> \texttt{;})\\
member\textrm{-}function\textrm{-}specifiers &\rightarrow & &(\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \> \textbf{virtual} \>
| \> \textbf{override} \> | \> \textbf{abstract} \> | \> \textbf{static} \>\\
&| & &\textbf{suppress} \> | \> \textbf{default} \> | \> \textbf{inline} \> | \> \textbf{nothrow} \> | \> \textbf{throw})^*
\end{align*}

A regular member function may have access specifiers but no other member function specifiers.
A regular member function operates on a class object.

Member function can be declared \emph{virtual}, in which case the actual member function called
through a pointer or reference variable depends on the actual type of the class object
instead of the formal type of the pointer or reference variable.

Member function can be declared \emph{abstract}, in which case it shall not have an implementation,
and it has to be overridden in each concrete class type derived from the abstract class type.

A member function of a derived class type can \emph{override} a virtual or abstract member function
of a base class type.

Member function can be declared \emph{static}, in which case it do not operate on a class object
(it has no \bf{this} pointer).
A static member function can call other static member functions of its class and can operate on
static member variables of its class.
A static member function is called using ClassName.StaticMemberFunc(arguments) syntax.

A member function can be declared \emph{const}, in which case the type of the \bf{this} pointer
for a class C is "pointer to \bf{const} C".
A constant member function cannot directly alter its class object.

If a non-static class has no user-defined copy assignment, no user-defined copy constructor,
no user-defined move assignment, no user-defined move constructor and no user-defined destructor,
the compiler will implement a copy assignment that assigns each non-static member variable
from its corresponding member variable of the function argument.
The compiler will also implement a move assignment that swaps each non-static member variable
with the corresponding member variable of the function argument in that case.

This automatic generation of copy assignment and move assignment can be suppressed using the
\bf{suppress} keyword.

Generation of copy assignment and move assignment can be explitly requested by using the \bf{default} keyword.

\begin{lstlisting}[frame=trBL]
public class Foo
{
    public void operator=(const Foo& that)  // copy assignment
    {
        // ...
    }
    public void operator=(Foo&& that)       // move assignment
    {
        // ...
    }
}

public class Bar
{
    default void operator=(const Bar&); // compiler will implement memberwise copy assignment
    default void operator=(Bar&&);      // compiler will implement memberwise move assignment
}

public class Baz
{
    suppress void operator=(const Baz&);    // automatic generation of copy assignment is suppressed
    suppress void operator=(Baz&&);         // automatic generation of move assignment is suppressed
}
\end{lstlisting}

\subsubsection{Conversion Functions}\label{sec:conversionfunctions}\label{conversionfunction}

A conversion function converts a class type object to the specified target type.
Conversion functions participate type conversions in \hyperref[cast]{cast\textrm{-}expressions} and in function overloading.

\begin{align*}
conversion\textrm{-}function &\rightarrow & &conversion\textrm{-}function\textrm{-}specifiers\\
& & &\textbf{operator} \>
\hyperref[typeexpr]{type\textrm{-}expression} \> \texttt{(} \> \texttt{)} \> \textbf{const}?\\
& & &(\> \hyperref[functionbody]{function\textrm{-}body} \> | \> \texttt{;} \>)\\
conversion\textrm{-}function\textrm{-}specifiers &\rightarrow & &(\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \> \textbf{nothrow} \> | \>
\textbf{throw} \> | \> \textbf{inline})^*
\end{align*}

\subsubsection{Synthesized Equality Operator for Classes}\label{sec:synthesizedeq}

The compiler automatically implements a memberwise equality operator for a class if it is called.
This automatic generation of equality operator can be suppressed by using the \bf{suppress} keyword.
Generation of memberwise equality operator can be explicitly requested by using the \bf{default} keyword.

\subsubsection{Member Variable Declarations}\label{membervariabledeclaration}

A class can have non-static and static member variables.

\begin{align*}
member\textrm{-}variable\textrm{-}declaration &\rightarrow \> member\textrm{-}variable\textrm{-}specifiers \> \hyperref[typeexpr]{type\textrm{-}expression} \>
\hyperref[identifier]{identifier} \> \texttt{;}\\
member\textrm{-}variable\textrm{-}specifiers &\rightarrow (\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \> \textbf{static})^*
\end{align*}

A non-static member variable is a member of each class object of its class.

A static member variable is a member of its class type.

\subsubsection{Constant Declarations}\label{constantdeclaration}

A constant is an object whose value can be obtained at compile time.

\begin{align*}
constant\textrm{-}declaration &\rightarrow  & &\hyperref[accessspecifier]{access\textrm{-}specifier}?\\
& & &\textbf{const} \> \hyperref[typeexpr]{type\textrm{-}expression} \> \hyperref[identifier]{identifier} \> \texttt{=} \>
\hyperref[constantexpr]{constant\textrm{-}expression} \> \texttt{;}
\end{align*}

The type of a constant can be a basic value type or an enumerated type (see \ref{sec:enumerations}).

\subsubsection{Typedef Declarations}\label{typedefdeclaration}

The \bf{typedef} declaration inserts an alias name for a type expression into its scope.

\begin{align*}
typedef\textrm{-}declaration \rightarrow \hyperref[accessspecifier]{access\textrm{-}specifier}? \> \textbf{typedef} \>
\hyperref[typeexpr]{type\textrm{-}expression} \> \hyperref[identifier]{identifier} \> \texttt{;}
\end{align*}

\subsection{Delegate Types}

Delegate types make possible to delegate execution of a function to another entity.
Delegates can be passed as parameters and called much the same way ordinary functions can be called.
Delegates are typically used to implement callbacks and events.

Delegate types come in two flavors: regular delegates that capture a function pointer and
class delegates that capture a pointer to a class object and a pointer to a member function.

\subsubsection{Delegates}\label{delegatedefinition}

A delegate type is defined using the keyword \bf{delegate} followed by a return type, the name of the delegate type and a
list of function parameters.
An object of a delegate type is a pointer to a free function or to a static member function.

\begin{align*}
delegate\textrm{-}definition &\rightarrow & &(\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \> \textbf{throw} \> | \> \textbf{nothrow})?\\
& & &\textbf{delegate} \> \hyperref[typeexpr]{type\textrm{-}expression} \> \hyperref[identifier]{identifier} \> \hyperref[parameters]{parameters} \> \texttt{;}
\end{align*}

\subsubsection{Class Delegates}\label{classdelegatedefinition}

A class delegate type is defined using the keyword pair \bf{class} \bf{delegate} followed by a return type, the name of the
class delegate type and a list of member function parameters.
An object of a class delegate type is a pair consisting of a pointer to a class object and a pointer to a member function.

\begin{align*}
class\textrm{-}delegate\textrm{-}definition &\rightarrow & &(\hyperref[accessspecifier]{access\textrm{-}specifier} \> | \> \textbf{throw} \> | \> \textbf{nothrow})?\\
& & &\textbf{class} \> \textbf{delegate} \> \hyperref[typeexpr]{type\textrm{-}expression} \> \hyperref[identifier]{identifier} \>
\hyperref[parameters]{parameters} \> \texttt{;}
\end{align*}

\subsection{Interface Types}\label{interface}

An interface type contains member function signatures.
A \hyperref[classtypes]{class} can \emph{implement} an interface by mentioning the name of the interface in its inheritance list and
providing implementations for all of the member function signatures of the interface.

\begin{align*}
interface\textrm{-}definition &\rightarrow & &\hyperref[accessspecifier]{access\textrm{-}specifier}?\\
& & &\textbf{interface} \> \hyperref[identifier]{identifier} \> \texttt{\{} \> interface\textrm{-}content \> \texttt{\}}\\
interface\textrm{-}content &\rightarrow & &interface\textrm{-}member\textrm{-}function^*\\
interface\textrm{-}member\textrm{-}function &\rightarrow & &(\textbf{throw} \> | \> \textbf{nothrow})?\\
& & &\hyperref[typeexpr]{type\textrm{-}expression} \> \hyperref[identifier]{identifier} \>
\hyperref[parameters]{parameters} \> \textbf{const}? \> \texttt{;}
\end{align*}

\clearpage
\subsubsection{Interface Objects}

An object of an interface type is constructed from a pointer to a class object by writing the name of the interface followed by
a left parenthesis, a pointer to a class object and a right parenthesis.

\begin{flushleft}
For example:
\end{flushleft}

\begin{lstlisting}[frame=trBL]
using System;

public interface Reader
{
    string Read();
}

public class ConsoleReader : Reader
{
    public string Read()
    {
        return Console.ReadLine();
    }
}

public class ModelClass
{
    public void SetReader(Reader reader_)
    {
        reader = reader_;
    }
    public void Act()
    {
        string s = reader.Read();
    }
    private Reader reader;
}

public void main()
{
    ConsoleReader consoleReader;
    ModelClass model;
    model.SetReader(Reader(&consoleReader));
    model.Act();
}
\end{lstlisting}

An interface object holds two pointers: one pointing to a class object and another pointing to a table of function pointers.
Because interface objects are so small they should be passed by value (not by const reference).

Default constructed interface object does not point to any class object -- it is empty.
Interface objects can be copied, passed to functions and returned by functions.
They can also be compared for equality and inequality.

For example:

\begin{lstlisting}[frame=trBL]
public void main()
{
    Reader reader; // an empty interface object
    Reader another = reader; // copy of an interface object
    if (another == Reader()) // comparing an interface object
    {
        Console.Out() << "another is empty" << endl();
    }
}
\end{lstlisting}

\section{Concepts}\label{conceptdefinition}\label{conceptname}

Concepts are used to set requirements for template type arguments in function and class templates.
The concept design is influenced by the Concept Design for the STL (\cite{STLCONCEPTS}).

A concept definition consists of the name of the concept followed by a list of type parameters.
A concept body consists of syntactic requirements for type parameters that take form of constraints,
and semantic requirements for type parameters that take form of axioms.

A concept can \emph{refine} another concept by setting additional requirements and overriding existing requirements.
When overriding existing requirements, the refining concept can set an associated type equal to a more constrained type,
or to model a more constrained concept than in the refined concept.

\begin{align*}
concept\textrm{-}definition &\rightarrow & &\hyperref[accessspecifier]{access\textrm{-}specifier}?\\
& & &\textbf{concept} \> \hyperref[identifier]{identifier} \> \texttt{<} \> \hyperref[identifier]{identifier} \> (\> \texttt{,} \>
\hyperref[identifier]{identifier} \>)^* \> \texttt{>}\\
& & &refinement? \> \hyperref[whereconstraint]{where\textrm{-}constraint}? \> \texttt{\{} \> concept\textrm{-}body \> \texttt{\}}\\
refinement &\rightarrow & &\texttt{:} \> concept\textrm{-}name \> \texttt{<} \hyperref[identifier]{identifier} \>
(\> \texttt{,} \> \hyperref[identifier]{identifier})^* \texttt{>}\\
concept\textrm{-}name &\rightarrow & &\hyperref[qualifiedid]{qualified\textrm{-}id}\\
concept\textrm{-}body &\rightarrow\\
&( & &\hyperref[typenameconstraint]{typename\textrm{-}constraint}\\
&| & &\hyperref[signatureconstraint]{signature\textrm{-}constraint}\\
&| & &\hyperref[embeddedconstraint]{embedded\textrm{-}constraint}\\
&| & &\hyperref[axiom]{axiom}\\
&)^*
\end{align*}

\subsection{Typename Constraint}\label{typenameconstraint}

A typename constraint sets a requirement that an associated type with the specified name exists.

\begin{align*}
typename\textrm{-}constraint \rightarrow \textbf{typename} \> \hyperref[typeexpr]{type\textrm{-}expression} \> \texttt{;}
\end{align*}

Typically type expression is of the form\\
\emph{$<$concept type parameter$>$} \bf{.} \emph{$<$associated type name$>$}.

The typename constraint can be satisfied by providing a \hyperref[typedefdeclaration]{typedef declaration} or inner class definition inside a
class type.

\subsection{Signature Constraint}\label{signatureconstraint}

A signature constraint sets a requirement that either the first concept type parameter contains a member function with the specified signature or there exists a nonmember function with the specified signature.
The signature of the function does not have to match exactly.

\begin{align*}
signature\textrm{-}constraint &\rightarrow & &constructor\textrm{-}constraint\\
&| & &destructor\textrm{-}constraint\\
&| & &member\textrm{-}function\textrm{-}constraint\\
&| & &function\textrm{-}constraint\\
constructor\textrm{-}constraint &\rightarrow & &\hyperref[identifier]{identifier} \> \hyperref[parameters]{parameters} \> \texttt{;}\\
destructor\textrm{-}constraint &\rightarrow & &\sim \hyperref[identifier]{identifier} \> \texttt{(} \> \texttt{)} \> \texttt{;}\\
member\textrm{-}function\textrm{-}constraint &\rightarrow & &\hyperref[typeexpr]{type\textrm{-}expression} \>
\hyperref[identifier]{identifier} \texttt{.} \hyperref[functionname]{function\textrm{-}name} \> \hyperref[parameters]{parameters} \> \texttt{;}\\
function\textrm{-}constraint &\rightarrow & &\hyperref[typeexpr]{type\textrm{-}expression} \> \hyperref[functionname]{function\textrm{-}name} \>
\hyperref[parameters]{parameters} \>\texttt{;}
\end{align*}

\subsection{Embedded Constraint}\label{embeddedconstraint}

An embedded constraint sets additional requirements for concept parameter types.

\begin{align*}
embedded\textrm{-}constraint \rightarrow \hyperref[whereconstraint]{where\textrm{-}constraint} \> \texttt{;}
\end{align*}

\subsection{Axioms}\label{axiom}

A concept can contain \emph{axioms} that represent semantic requirements for constrained template type arguments.
The axioms are not processed in any way by the compiler (except parsing their syntax).
They are only documentation for the programmer.

\begin{align*}
axiom &\rightarrow \textbf{axiom} \> \hyperref[identifier]{identifier} \> \hyperref[parameters]{parameters} \> \texttt{\{} \> axiom\textrm{-}body \> \texttt{\}}\\
axiom\textrm{-}body &\rightarrow axiom\textrm{-}statement^*\\
axiom\textrm{-}statement &\rightarrow \hyperref[expression]{expression} \> \texttt{;}
\end{align*}

\subsection{Where Constraint}\label{sec:where-constraint}\label{whereconstraint}\label{constraintexpr}

A where constraint sets requirements for template type arguments or concept parameter types.

\begin{align*}
where\textrm{-}constraint &\rightarrow \> \textbf{where} \> constraint\textrm{-}expr\\
constraint\textrm{-}expr  &\rightarrow \> \hyperref[disjunctiveconstraint]{disjunctive\textrm{-}constraint\textrm{-}expr}
\end{align*}

\subsubsection{Disjunctive Constraint Expressions}\label{disjunctiveconstraint}

A disjunctive constraint expression states that the template type arguments and concept parameters must satisfy
the requirements of one of the conjunctive constraint expressions separated by \bf{or} connectives.

\begin{align*}
disjunctive\textrm{-}constraint\textrm{-}expr \rightarrow \> &\hyperref[conjunctiveconstraint]{conjunctive\textrm{-}constraint\textrm{-}expr}\\
&(\textbf{or} \> \hyperref[conjunctiveconstraint]{conjunctive\textrm{-}constraint\textrm{-}expr})^*
\end{align*}

\subsubsection{Conjunctive Constraint Expressions}\label{conjunctiveconstraint}

A conjunctive constraint expression states that the template type arguments and concept parameters must satisfy
the requirements of all primary constraint expressions separated by \bf{and} connectives.

\begin{align*}
conjunctive\textrm{-}constraint\textrm{-}expr \rightarrow \> &\hyperref[primaryconstraint]{primary\textrm{-}constraint\textrm{-}expr}\\
&(\textbf{and} \> \hyperref[primaryconstraint]{primary\textrm{-}constraint\textrm{-}expr})^*
\end{align*}

\subsubsection{Primary Constraint Expressions}\label{primaryconstraint}

A primary constraint can be either an atomic constraint or a constraint expression enclosed in parenthesis.

\begin{align*}
primary\textrm{-}constraint\textrm{-}expr \rightarrow \> \hyperref[atomicconstraint]{atomic\textrm{-}constraint} \> |
\> \texttt{(} \> \hyperref[constraintexpr]{constraint\textrm{-}expr} \> \texttt{)}
\end{align*}

\subsubsection{Atomic Constraints}\label{atomicconstraint}

An atomic constraint can be either a predicate-constraint, an is-constraint or a multiparameter constraint.

\begin{align*}
atomic\textrm{-}constraint \rightarrow \> \hyperref[predicateconstraint]{predicate\textrm{-}constraint} \>
| \> \hyperref[isconstraint]{is\textrm{-}constraint} \> | \>
\hyperref[multiparamconstraint]{multiparam\textrm{-}constraint}
\end{align*}

\subsubsection{Predicate-constraint}\label{predicateconstraint}

A predicate-constraint sets a requirement that the given Boolean-valued compile-time predicate returns \textbf{true}.
The compile-time predicate can be either a Boolean-valued \hyperref[constexprfun]{constexpr} function or an intrinsic type predicate from \emph{System.Meta} namespace.

\begin{align*}
predicate\textrm{-}constraint &\rightarrow \> invoke\textrm{-}expr\\
invoke\textrm{-}expr &\rightarrow \> ( \hyperref[templateid]{template\textrm{-}id} \> | \> \hyperref[identifier]{identifier} ) \>
( \texttt{.} \hyperref[identifier]{identifier} )^* \> \texttt{(} \> \hyperref[argumentlist]{argument\textrm{-}list} \> \texttt{)}
\end{align*}

\subsubsection{Is-Constraint}\label{isconstraint}

An is-constraint sets a requirement that a either (1) the specified type satisfies the requirements of the specified concept, or (2) the specified type is trivially convertible to another type. For example, type \bf{const T\&} is trivially convertible to type \bf{T}.
When specifying the is-constraint in case (2), the so far less constrained type should be put to the left and the more constrained type to the right.

\begin{align*}
is\textrm{-}constraint &\rightarrow \> \hyperref[typeexpr]{type\textrm{-}expression} \> \textbf{is} \> concept\textrm{-}or\textrm{-}typename\\
concept\textrm{-}or\textrm{-}typename &\rightarrow \> \hyperref[typeexpr]{type\textrm{-}expression}
\end{align*}

\subsubsection{Multiparameter Constraint}\label{multiparamconstraint}

A multiparameter constraint sets a requirement that the specified types satisfy the requirements of the specified concept.

\begin{align*}
multiparam\textrm{-}constraint \rightarrow \> \hyperref[conceptname]{concept\textrm{-}name} \> \texttt{<} \hyperref[typeexpr]{type\textrm{-}expression} \>
(\texttt{,} \> \hyperref[typeexpr]{type\textrm{-}expression})^* \> \texttt{>}
\end{align*}

\subsection{Built-in Concepts}

There are four built-in multiparameter concepts implemented by the compiler.

\subsubsection{Same Concept}

The \bf{Same$<$T, U$>$} concept sets a requirement that types T and U are exactly the same type.
The so far less constrained type should be put to the left and the more constrained type to the right.

\subsubsection{Derived Concept}

The \bf{Derived$<$T, U$>$} concept sets a requirement that type T is derived from type U, or in other words that the type U is the base class of type T. Type T is trivially derived from type T.

\subsubsection{Convertible Concept}

The \bf{Convertible$<$T, U$>$} concept sets a requirement that type T is convertible to type U.
Either there should be a constructor with signature \verb|U(const T&)| or there should be a built-in conversion
from type T to type U. Type T is trivially convertible to type T.

\subsubsection{Common Concept}

The \bf{Common$<$T, U$>$} concept sets a requirement that types T and U have a common type to which they both are convertible to. The common type is inserted as a typedef \emph{CommonType} to the scope of concept \bf{Common$<$T, U$>$}. The common type of T and T is trivially T.
The so far less constrained type should be put to the left and the more constrained type to the right.

\section{Namespaces}\label{namespacedefinition}\label{namespacecontent}

Namespaces are used to disambiguate equal names belonging to different libraries.
A namespace consists of optional using directives followed by optional definitions.

\begin{align*}
namespace\textrm{-}definition &\rightarrow & &\textbf{namespace} \> \hyperref[qualifiedid]{qualified\textrm{-}id} \>
\texttt{\{} namespace\textrm{-}content \texttt{\}}\\
namespace\textrm{-}content &\rightarrow & &using\textrm{-}directive^* \> definition^*\\
using\textrm{-}directive &\rightarrow & &using\textrm{-}alias\textrm{-}directive \> | \> using\textrm{-}namespace\textrm{-}directive\\
using\textrm{-}alias\textrm{-}directive &\rightarrow & &\textbf{using} \> \hyperref[identifier]{identifier} \> \texttt{=} \>
\hyperref[qualifiedid]{qualified\textrm{-}id} \> \texttt{;}\\
using\textrm{-}namespace\textrm{-}directive &\rightarrow & &\textbf{using} \> \hyperref[qualifiedid]{qualified\textrm{-}id} \> \texttt{;}\\
definition &\rightarrow & &\hyperref[enumeratedtypedefinition]{enumerated\textrm{-}type\textrm{-}definition}\\
&| & &\hyperref[constantdeclaration]{constant\textrm{-}declaration}\\
&| & &\hyperref[functiondefinition]{function\textrm{-}definition}\\
&| & &\hyperref[classdefinition]{class\textrm{-}definition}\\
&| & &\hyperref[delegatedefinition]{delegate\textrm{-}definition}\\
&| & &\hyperref[classdelegatedefinition]{class\textrm{-}delegate\textrm{-}definition}\\
&| & &\hyperref[typedefdeclaration]{typedef\textrm{-}declaration}\\
&| & &\hyperref[conceptdefinition]{concept\textrm{-}definition}\\
&| & &namespace\textrm{-}definition
\end{align*}

A using alias directive brings a single alias name to the current file scope.

A using namespace directive brings contents of given namespace to the current file scope.

\section{Source Files}\label{sourcefile}

A source file consists of namespace content.

\begin{align*}
source\textrm{-}file \rightarrow \hyperref[namespacecontent]{namespace\textrm{-}content}
\end{align*}

\section{Programs}

A Cmajor program consists of source files.
One of the source files must contain a main function.

A main function can have four possible signatures:

\begin{itemize}
\item \texttt{void main()}
\item \texttt{int main()}
\item \texttt{void main(int argc, const char** argv)}
\item \texttt{int main(int argc, const char** argv)}
\end{itemize}

In the two latter signatures parameter argc contains the number of program arguments,
and parameter argv contains program argument strings.
By convention the first argument (argv[0]) contains the name of the program.

If the main function is declared to return a value, the main function shall contain
a return statement, otherwise it shall not contain a return statement.

If the main function is declared void, it returns exit code 0 to the environment.

\section{Solution and Project File Formats}

\subsection{Solution File Format}

\begin{align*}
solution\textrm{-}file &\rightarrow solution\textrm{-}declaration \> project\textrm{-}file\textrm{-}declarations \> project\textrm{-}dependencies\\
solution\textrm{-}declaration &\rightarrow \textbf{solution} \> solution\textrm{-}name \> \texttt{;}\\
solution\textrm{-}name &\rightarrow \hyperref[qualifiedid]{qualified\textrm{-}id}\\
project\textrm{-}file\textrm{-}declarations &\rightarrow project\textrm{-}file\textrm{-}declaration^*\\
project\textrm{-}file\textrm{-}declaration &\rightarrow \textbf{project} \> project\textrm{-}file\textrm{-}path \> \texttt{;}\\
project\textrm{-}file\textrm{-}path &\rightarrow \texttt{<} \> [\> \hat{}\,\texttt{>}\>]^+ \> \texttt{>}\\
project\textrm{-}dependencies &\rightarrow project\textrm{-}dependency^*\\
project\textrm{-}dependency &\rightarrow \textbf{dependency} \> project\textrm{-}name \> dependent\textrm{-}project\textrm{-}list \> \texttt{;}\\
dependent\textrm{-}project\textrm{-}list &\rightarrow \texttt{(} \> dependent\textrm{-}project\textrm{-}name \> (\texttt{,} \>
dependent\textrm{-}project\textrm{-}name)^* \> \texttt{)}\\
dependent\textrm{-}project\textrm{-}name &\rightarrow \hyperref[qualifiedid]{qualified\textrm{-}id}
\end{align*}

\subsection{Project File Format}

\begin{align*}
project\textrm{-}file &\rightarrow & &project\textrm{-}declaration \> project\textrm{-}file\textrm{-}declarations\\
project\textrm{-}declaration &\rightarrow & &\textbf{project} \> project\textrm{-}name \> \texttt{;}\\
project\textrm{-}name &\rightarrow & &\hyperref[qualifiedid]{qualified\textrm{-}id}\\
project\textrm{-}file\textrm{-}declarations &\rightarrow & &project\textrm{-}file\textrm{-}declaration^*\\
project\textrm{-}file\textrm{-}declaration &\rightarrow & &target\textrm{-}declaration\\
&| & &stack\textrm{-}size\textrm{-}declaration\\
&| & &assembly\textrm{-}declaration\\
&| & &library\textrm{-}reference\\
&| & &executable\textrm{-}declaration\\
&| & &c\textrm{-}library\textrm{-}declaration\\
&| & &add\textrm{-}library\textrm{-}path\textrm{-}declaration\\
&| & &source\textrm{-}file\\
&| & &asm\textrm{-}source\textrm{-}file\\
&| & &c\textrm{-}source\textrm{-}file\\
&| & &cpp\textrm{-}source\textrm{-}file\\
&| & &text\textrm{-}file\\
target\textrm{-}declaration &\rightarrow & &\textbf{target} \> \texttt{=} \> (\textbf{program} | \textbf{library}) \> \texttt{;}\\
stack\textrm{-}size\textrm{-}declaration &\rightarrow & &\textbf{stack} \> \texttt{=} \> ulong \> (\texttt{,} \> ulong)? \> \texttt{;}\\
assembly\textrm{-}declaration &\rightarrow & &\textbf{assembly} \> file\textrm{-}path \> properties? \> \texttt{;}\\
library\textrm{-}reference &\rightarrow & &\textbf{reference} \> file\textrm{-}path \> properties? \> \texttt{;}\\
executable\textrm{-}declaration &\rightarrow & &\textbf{executable} \> file\textrm{-}path \> \texttt{;}\\
c\textrm{-}library\textrm{-}declaration &\rightarrow & &\textbf{clib} \> file\textrm{-}path \> properties? \> \texttt{;}\\
add\textrm{-}library\textrm{-}path\textrm{-}declaration &\rightarrow & &\textbf{addlibrarypath} \> file\textrm{-}path \> properties? \> \texttt{;}\\
source\textrm{-}file &\rightarrow & &\textbf{source} \> file\textrm{-}path \> properties? \> \texttt{;}\\
asm\textrm{-}source\textrm{-}file &\rightarrow & &\textbf{asmsource} \> file\textrm{-}path \> properties? \> \texttt{;}\\
c\textrm{-}source\textrm{-}file &\rightarrow & &\textbf{csource} \> file\textrm{-}path \> properties? \> \texttt{;}\\
cpp\textrm{-}source\textrm{-}file &\rightarrow & &\textbf{cppsource} \> file\textrm{-}path \> properties? \> \texttt{;}\\
text\textrm{-}file &\rightarrow & &\textbf{text} \> file\textrm{-}path \> properties? \> \texttt{;}\\
properties &\rightarrow & &[ \> property \> (\texttt{,} \> property)^* \> ]\\
property &\rightarrow & &property\textrm{-}name \> rel\textrm{-}op \> property\textrm{-}value\\
property\textrm{-}name &\rightarrow & &\hyperref[identifier]{identifier}\\
rel\textrm{-}op &\rightarrow & &\texttt{=} \> | \> \texttt{!=} \> | \> \texttt{>=} \> | \> \texttt{<=} \> | \> \texttt{<} \> | \> \texttt{>}\\
property\textrm{-}value &\rightarrow & &version\textrm{-}number \> | \> \hyperref[identifier]{identifier} \> | \> long\\
version\textrm{-}number &\rightarrow & &int \texttt{.} int (\texttt{.} int (\texttt{.} int)?)?\\
file\textrm{-}path &\rightarrow & &\texttt{<} \> [\> \hat{}\,\texttt{>}\>]^+ \> \texttt{>}
\end{align*}

Target declaration \emph{$<$target-declaration$>$} sets whether we are building a program or a library.

Stack size declaration \emph{$<$stack-size-declaration$>$} sets the reserved and optionally the commit size
of the program stack in bytes.
The first value is the reserved size of the stack and the second value after a comma is the commit size of the stack.

Assembly declaration \emph{$<$assembly-declaration$>$} sets the name of the archive that contains project's object code.
By convention its extension is ".cma".

Library reference \emph{$<$library-reference$>$} imports a Cmajor library to the project.
By convention its extension is ".cml".
The .cml file contains the metadata (symbol table etc.) of a Cmajor project.

If target is "program", an executable declaration \emph{$<$executable-declaration$>$}
sets the name of the executable file.
In Windows ".exe" extension is appended automatically to the executable file name.

A C-library declaration \emph{$<$c-library-declaration$>$}
requests that named object code library must be linked to the final executable.
Thus C-library declaration can be used in a library project or an executable project.
Usually the object code library file is named "libfoo.a", but the link name needed here is just "foo",
because the object code library is linked using gcc's -l option.

Library path declaration \emph{$<$add-library-path-declaration$>$}
adds a directory path to the library search paths when final executable is linked.
Thus library path declaration can be used in a library project or an executable project.
It is specified using gcc's -L option by the compiler when the program is linked.

Source file declaration \emph{$<$source-file$>$} adds a Cmajor source file to the project.
By convention its extension is ".cm".

Assembly source file declaration \emph{$<$asm-source-file$>$} adds LLVM source file to the project.
By its extension is ".ll". Assembly source file is compiled using the LLVM compiler \bf{llc}.

C source file declaration \emph{$<$c-source-file$>$} adds a C source file to the project.
By convention its extension is ".c". C source file is compiled using GNU C compiler \bf{gcc}.

C++ source file declaration \emph{$<$cpp-source-file$>$} adds a C++ source file to the project.
By convention its exension is ".cpp" or ".cxx".
C++ source file is compiled using the GNU C++ compiler \bf{g++}.

Text file declaration \emph{$<$text-file$>$} includes some text file to the project.
The text file can have any extension. It is not processed by the compiler.

Properties contains comma-separated list of property declarations.
Properties can be used to include a declaration only in selected configurations.
If the properties do not match current compilation properties, the associated declaration has no effect.

Currently property name can be \bf{backend}, \bf{os}, \bf{bits} or \bf{llvm\_version}.
Backend values can be \bf{c} and \bf{llvm}.
Os values can be \bf{windows} and \bf{linux}.
Bits values can be \bf{32} and \bf{64}.
Llvm-version number is obtained by the compiler at the start of compilation by executing command \verb|llc --version|.

\clearpage

\begin{thebibliography}{13}

\bibitem{COMPILERS} \textsc{Aho, A. V., M. S. Lam, R. Sethi, and J. D. Ullman}:
Compilers: Principles, Techniques, \& Tools. Second Edition. Addison-Wesley, 2007.

\bibitem{BOOST} Boost C++ libraries,
\textit{\url{http://www.boost.org/}}

\bibitem{ANNCPPREFMAN} \textsc{Ellis, M. A., and B. Stroustrup}:
The Annotated C++ Reference Manual. Addison-Wesley, 1990.

\bibitem{PEG} \textsc{Ford, B.}:
Parsing Expression Grammars: A Recognition-Based Syntactic Foundation.
\textit{\url{http://pdos.csail.mit.edu/~baford/packrat/popl04/peg-popl04.pdf}}

\bibitem{GIBBS} \textsc{Gibbs, M., and B. Stroustrup}:
Fast dynamic casting, 2005,
\textit{\url{http://www.stroustrup.com/fast_dynamic_casting.pdf}}

\bibitem{PDFTEX} \textsc{Han The Thanh}:
pdf\TeX, \textit{\url{http://www.tug.org/applications/pdftex/}}

\bibitem{STLCONCEPTS} \textsc{JTC1/SC22/WG21 - The C++ Standards Committee}:
A Concept Design for the STL,
\textit{\url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf}}

\bibitem{STDCPP} \textsc{JTC1/SC22/WG21 - The C++ Standards Committee}:
Working Draft, Standard for Programming Language C++,
\textit{\url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf}}

\bibitem{SOUL} \textsc{Laakko, S.}:
Soul Parsing Framework,
\textit{\url{http://sourceforge.net/projects/soulparsing/}}

\bibitem{CSLANGSPEC} \textsc{Microsoft Corporation}:
The \csharp\ Language Specification. Version 4.0,
\textit{\url{http://go.microsoft.com/fwlink/?LinkId=199552}}

\bibitem{ORGANDDESIGN} \textsc{Patterson, D. A., and J. L. Hennessy}:
Computer Organization and Design. The Hardware / Software Interface. Fourth Edition.
Morgan Kaufmann, 2012.

\bibitem{EOP} \textsc{Stepanov, A., and P. McJones}:
Elements of Programming. Addison-Wesley, 2009.

\bibitem{CPPPL} \textsc{Stroustrup, B.}:
The C++ Programming Language. Fourth Edition. Addison-Wesley, 2013.

\bibitem{SUNDARESAN} \textsc{Sundaresan V., and C. Razafimahefa, R. Vallee-Rai, L. Hendren, P. Lam, E. Cagnon, C. Godin}:
Practical Virtual Method Call Resolution for Java, 1999,
\textit{\url{http://web.cs.ucla.edu/~palsberg/tba/papers/sundaresan-et-al-oopsla00.pdf}}

\end{thebibliography}

\end{document}
