/*========================================================================
    Copyright (c) 2012-2014 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

 ========================================================================*/

// Copyright (c) 1994
// Hewlett-Packard Company
// Copyright (c) 1996
// Silicon Graphics Computer Systems, Inc.
// Copyright (c) 2009 Alexander Stepanov and Paul McJones

using System;
using System.Collections;

namespace System.Text.Parsing
{
    public typedef ParsingDomain* ParsingDomainPtr;
    public typedef UniquePtr<ParsingDomain> UniqueParsingDomainPtr;

    public class ParsingDomain: ParsingObject
    {
        public ParsingDomain(): base("parsing_domain"), globalNamespace(new Namespace("", null)), globalScope(globalNamespace->GetScope()), currentNamespace(globalNamespace)
        {
            Own(globalNamespace);
            globalScope->SetNs(globalNamespace);
            namespaceMap[currentNamespace->FullName()] = currentNamespace;
        }
        suppress ParsingDomain(const ParsingDomain&);
        suppress void operator=(const ParsingDomain&);
        suppress ParsingDomain(ParsingDomain&&);
        suppress void operator=(ParsingDomain&&);
        public ScopePtr GetNamespaceScope(const string& fullNamespaceName)
        {
            if (fullNamespaceName.IsEmpty())
            {
                return globalScope;
            }
            NamespacePtr ns = globalScope->GetNamespace(fullNamespaceName);
            if (ns == null)
            {
                ns = NamespacePtr(new Namespace(fullNamespaceName, globalScope));
                Own(ns);
                globalScope->AddNamespace(ns);
            }
            return ns->GetScope();
        }
        public nothrow GrammarPtr GetGrammar(const string& grammarName)
        {
            GrammarMapIt i = grammarMap.Find(grammarName);
            if (i != grammarMap.End())
            {
                return i->second;
            }
            return null;
        }
        public void AddGrammar(GrammarPtr grammar)
        {
            Own(grammar);
            string grammarFullName = grammar->FullName();
            GrammarMapIt i = grammarMap.Find(grammarFullName);
            if (i == grammarMap.End())
            {
                grammarMap[grammarFullName] = grammar;
                grammar->SetNs(currentNamespace);
                grammar->AddToScope();
            }
        }
        public void BeginNamespace(const string& ns)
        {
            string fullNamespaceName = ns;
            if (!currentNamespace->FullName().IsEmpty())
            {
                fullNamespaceName = currentNamespace->FullName() + "." + ns;
            }
            namespaceStack.Push(currentNamespace);
            NamespaceMapIt i = namespaceMap.Find(fullNamespaceName);
            if (i != namespaceMap.End())
            {
                currentNamespace = i->second;
            }
            else
            {
                NamespacePtr newNs(new Namespace(fullNamespaceName, globalScope));
                Own(newNs);
                newNs->GetScope()->SetNs(newNs);
                namespaceMap[newNs->FullName()] = newNs;
                currentNamespace = newNs;
                globalScope->AddNamespace(newNs);
            }
        }
        public void EndNamespace()
        {
            currentNamespace = namespaceStack.Pop();
        }
        public nothrow inline NamespacePtr GlobalNamespace() const
        {
            return globalNamespace;
        }
        public nothrow inline NamespacePtr CurrentNamespace() const
        {
            return currentNamespace;
        }
        public nothrow inline ScopePtr CurrentScope() const
        {
            return currentNamespace->GetScope();
        }
        private typedef Map<string, GrammarPtr> GrammarMap;
        private typedef GrammarMap.Iterator GrammarMapIt;
        private GrammarMap grammarMap;
        private NamespacePtr globalNamespace;
        private ScopePtr globalScope;
        private NamespacePtr currentNamespace;
        private typedef Map<string, NamespacePtr> NamespaceMap;
        private typedef NamespaceMap.Iterator NamespaceMapIt;
        private NamespaceMap namespaceMap;
        private Stack<NamespacePtr> namespaceStack;
    }

    internal class ParsingDomainRepository
    {
        static nothrow ParsingDomainRepository(): instance(new ParsingDomainRepository())
        {
        }
        public static ParsingDomainRepository& Instance()
        {
            return *instance;
        }
        private nothrow ParsingDomainRepository()
        {
        }
        suppress ParsingDomainRepository(const ParsingDomainRepository&);
        suppress void operator=(const ParsingDomainRepository&);
        suppress ParsingDomainRepository(ParsingDomainRepository&&);
        suppress void operator=(ParsingDomainRepository&&);
        public void Register(ParsingDomainPtr parsingDomain)
        {
            if (!parsingDomain->Owned())
            {
                parsingDomain->SetOwned();
                parsingDomains.Add(UniqueParsingDomainPtr(parsingDomain));
            }
        }
        private static UniquePtr<ParsingDomainRepository> instance;
        private List<UniqueParsingDomainPtr> parsingDomains;
    }

    public void RegisterParsingDomain(ParsingDomainPtr parsingDomain)
    {
        ParsingDomainRepository.Instance().Register(parsingDomain);
    }
}
