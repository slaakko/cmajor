/*========================================================================
    Copyright (c) 2012-2015 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;
using Span = System.Text.Parsing.Span;

namespace Cm.Sym
{
    public abstract class SymbolCreator
    {
        public virtual nothrow ~SymbolCreator()
        {
        }
        public abstract nothrow Symbol* CreateSymbol(const Span& span, const string& name);
    }
    
    public class ConcreteSymbolCreator<T> : SymbolCreator where T is SymbolClass
    {
        public override nothrow Symbol* CreateSymbol(const Span& span, const string& name)
        {
            return new T(span, name);
        }
    }
    
    public class SymbolFactory
    {
        static SymbolFactory() : instance(new SymbolFactory())
        {
        }
        private SymbolFactory()
        {
            creators.Resize(int(SymbolType.maxSymbol));
            Register(SymbolType.classSymbol, new ConcreteSymbolCreator<ClassTypeSymbol>());
            Register(SymbolType.constantSymbol, new ConcreteSymbolCreator<ConstantSymbol>());
            Register(SymbolType.declarationBlock, new ConcreteSymbolCreator<DeclarationBlock>());
            Register(SymbolType.delegateSymbol, new ConcreteSymbolCreator<DelegateTypeSymbol>());
            Register(SymbolType.classDelegateSymbol, new ConcreteSymbolCreator<ClassDelegateTypeSymbol>());
            Register(SymbolType.enumTypeSymbol, new ConcreteSymbolCreator<EnumTypeSymbol>());
            Register(SymbolType.enumConstantSymbol, new ConcreteSymbolCreator<EnumConstantSymbol>());
            Register(SymbolType.functionSymbol, new ConcreteSymbolCreator<FunctionSymbol>());
            Register(SymbolType.localVariableSymbol, new ConcreteSymbolCreator<LocalVariableSymbol>());
            Register(SymbolType.memberVariableSymbol, new ConcreteSymbolCreator<MemberVariableSymbol>());
            Register(SymbolType.entrySymbol, new ConcreteSymbolCreator<EntrySymbol>());
            Register(SymbolType.returnValueSymbol, new ConcreteSymbolCreator<ReturnValueSymbol>());
            Register(SymbolType.namespaceSymbol, new ConcreteSymbolCreator<NamespaceSymbol>());
            Register(SymbolType.parameterSymbol, new ConcreteSymbolCreator<ParameterSymbol>());
            Register(SymbolType.typeParameterSymbol, new ConcreteSymbolCreator<TypeParameterSymbol>());
            Register(SymbolType.templateTypeSymbol, new ConcreteSymbolCreator<TemplateTypeSymbol>());
            Register(SymbolType.derivedTypeSymbol, new ConcreteSymbolCreator<DerivedTypeSymbol>());
            Register(SymbolType.typedefSymbol, new ConcreteSymbolCreator<TypedefSymbol>());
            Register(SymbolType.conceptSymbol, new ConcreteSymbolCreator<ConceptSymbol>());
        }
        public static nothrow SymbolFactory& Instance()
        {
            return *instance;
        }
        public Symbol* CreateSymbol(SymbolType symbolType, const Span& span, const string& name)
        {
            const UniquePtr<SymbolCreator>& creator = creators[int(symbolType)];
            if (creator.IsNull())
            {
                throw Exception("no creator for symbol type '" + string(SymbolTypeStr(symbolType)) + "'");
            }
            Symbol* value = creator->CreateSymbol(span, name);
            if (value != null)
            {
                return value;
            }
            else
            {
                throw Exception("could not create symbol '" + name + "'");
            }
        }
        private void Register(SymbolType symbolType, SymbolCreator* creator)
        {
            creators[int(symbolType)] = UniquePtr<SymbolCreator>(creator);
        }
        private static UniquePtr<SymbolFactory> instance;
        private List<UniquePtr<SymbolCreator>> creators;
    }
    
    public abstract class ValueCreator
    {
        public virtual nothrow ~ValueCreator()
        {
        }
        public abstract Value* CreateValue();
    }
    
    public class ValueFactory
    {
        static ValueFactory() : instance(new ValueFactory())
        {
        }
        private ValueFactory()
        {
            creators.Resize(int(ValueType.max));
        }
        public static ValueFactory& Instance()
        {
            return *instance;
        }
        public Value* CreateValue(ValueType valueType)
        {
            const UniquePtr<ValueCreator>& creator = creators[int(valueType)];
            if (creator.IsNull())
            {
                throw Exception("no creator for value type '" + string(ValueTypeStr(valueType)) + "'");
            }
            return creator->CreateValue();
        }
        private static UniquePtr<ValueFactory> instance;
        private List<UniquePtr<ValueCreator>> creators;
    }
}
