/*========================================================================
    Copyright (c) 2012-2015 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;
using Span = System.Text.Parsing.Span;

namespace Cm.Sym
{
    public abstract class ContainerSymbol : Symbol
    {
        public nothrow ContainerSymbol(const Span& span_, const string& name_) : base(span_, name_), containerScope()
        {
        }
        public nothrow override ContainerScope* GetContainerScope() const
        {
            return &containerScope;
        }
        public nothrow inline const List<UniquePtr<Symbol>>& Symbols() const
        {
            return symbols;
        }
        public nothrow inline List<UniquePtr<Symbol>>& Symbols() 
        {
            return symbols;
        }
        public override nothrow bool IsContainerSymbol() const
        {
            return true;
        }
        public virtual void AddSymbol(Symbol* symbol)
        {
            if (!symbol->Name().IsEmpty() && !symbol->IsFunctionSymbol() && !symbol->IsConceptSymbol())
            {
                containerScope.Install(symbol);
            }
            if (symbol->IsFunctionSymbol())
            {
                FunctionSymbol* functionSymbol = cast<FunctionSymbol*>(symbol);
                if (!functionSymbol->IsFunctionTemplateSpecialization())
                {
                    FunctionGroupSymbol* functionGroupSymbol = MakeFunctionGroupSymbol(functionSymbol->GroupName(), functionSymbol->GetSpan());
                    functionGroupSymbol->AddFunction(functionSymbol);
                }
            }
            else if (symbol->IsConceptSymbol())
            {
                ConceptSymbol* conceptSymbol = cast<ConceptSymbol*>(symbol);
                ConceptGroupSymbol* conceptGroupSymbol = MakeConceptGroupSymbol(conceptSymbol->GroupName(), conceptSymbol->GetSpan());
                conceptGroupSymbol->AddConcept(conceptSymbol);
            }
            if (!symbol->IsTemplateTypeSymbol())
            {
                symbols.Add(UniquePtr<Symbol>(symbol));
            }
            symbol->SetParent(this);
        }
        public override void CollectExportedDerivedTypes(HashSet<Symbol*>& collected, HashSet<TypeSymbol*>& exportedDerivedTypes)
        {
            for (const UniquePtr<Symbol>& symbol : symbols)
            {
                if (symbol->IsExportSymbol())
                {
                    if (collected.CFind(symbol.GetPtr()) == collected.CEnd())
                    {
                        collected.Insert(symbol.GetPtr());
                        symbol->CollectExportedDerivedTypes(collected, exportedDerivedTypes);
                    }
                }
            }
        }
        public override void CollectExportedTemplateTypes(HashSet<Symbol*>& collected, HashSet<TemplateTypeSymbol*>& exportedTemplateTypes)
        {
            for (const UniquePtr<Symbol>& symbol : symbols)
            {
                if (symbol->IsExportSymbol())
                {
                    if (collected.CFind(symbol.GetPtr()) == collected.CEnd())
                    {
                        collected.Insert(symbol.GetPtr());
                        symbol->CollectExportedTemplateTypes(collected, exportedTemplateTypes);
                    }
                }
            }
        }
        
        private FunctionGroupSymbol* MakeFunctionGroupSymbol(const string& groupName, const Span& span)
        {
            Symbol* symbol = containerScope.Lookup(groupName);
            if (symbol == null)
            {
                FunctionGroupSymbol* functionGroupSymbol = new FunctionGroupSymbol(span, groupName, &containerScope);
                functionGroupSymbol->SetPublic();
                AddSymbol(functionGroupSymbol);
                return functionGroupSymbol;
            }
            if (symbol->IsFunctionGroupSymbol())
            {
                FunctionGroupSymbol* functionGroupSymbol = cast<FunctionGroupSymbol*>(symbol);
                return functionGroupSymbol;
            }
            else
            {
                throw Error("name of symbol '" + symbol->FullName() + "' conflicts with a function group '" + groupName + "'", symbol->GetSpan(), span);
            }
        }
        private ConceptGroupSymbol* MakeConceptGroupSymbol(const string& groupName, const Span& span)
        {
            Symbol* symbol = containerScope.Lookup(groupName);
            if (symbol == null)
            {
                ConceptGroupSymbol* conceptGroupSymbol = new ConceptGroupSymbol(span, groupName, &containerScope);
                conceptGroupSymbol->SetPublic();
                AddSymbol(conceptGroupSymbol);
                return conceptGroupSymbol;
            }
            if (symbol->IsConceptGroupSymbol())
            {
                ConceptGroupSymbol* conceptGroupSymbol = cast<ConceptGroupSymbol*>(symbol);
                return conceptGroupSymbol;
            }
            else
            {
                throw Error("name of symbol '" + symbol->FullName() + "' conflicts with a concept group '" + groupName + "'", symbol->GetSpan(), span);
            }
        }
        private ContainerScope containerScope;
        private List<UniquePtr<Symbol>> symbols;
    }
}
