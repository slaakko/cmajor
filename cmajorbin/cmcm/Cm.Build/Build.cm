/*========================================================================
    Copyright (c) 2012-2016 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;
using System.IO;

namespace Cm.Build
{
    public class Grammars
    {
        static Grammars() : instance(new Grammars())
        {
        }
        public static Grammars& Instance()
        {
            return *instance;
        }
        private Grammars() : solutionGrammar(Cm.Parser.SolutionGrammar.Create()), projectGrammar(Cm.Parser.ProjectGrammar.Create()), compileUnitGrammar(Cm.Parser.CompileUnitGrammar.Create())
        {
        }
        public Cm.Parser.SolutionGrammar* GetSolutionGrammar() 
        {
            return solutionGrammar;
        }
        public Cm.Parser.ProjectGrammar* GetProjectGrammar()
        {
            return projectGrammar;
        }
        public Cm.Parser.CompileUnitGrammar* GetCompileUnitGrammar()
        {
            return compileUnitGrammar;
        }
        public Cm.Parser.LlvmVersionGrammar* GetLlvmVersionGrammar()
        {
            if (llvmVersionGrammar == null)
            {
                llvmVersionGrammar = Cm.Parser.LlvmVersionGrammar.Create();
            }
            return llvmVersionGrammar;
        }
        public Cm.Parser.VersionNumberGrammar* GetVersionNumberGrammar()
        {
            if (versionNumberGrammar == null)
            {
                versionNumberGrammar = Cm.Parser.VersionNumberGrammar.Create();
            }
            return versionNumberGrammar;
        }
        private static UniquePtr<Grammars> instance;
        private Cm.Parser.SolutionGrammar* solutionGrammar;
        private Cm.Parser.ProjectGrammar* projectGrammar;
        private Cm.Parser.CompileUnitGrammar* compileUnitGrammar;
        private Cm.Parser.LlvmVersionGrammar* llvmVersionGrammar;
        private Cm.Parser.VersionNumberGrammar* versionNumberGrammar;
    }
    
    public class GlobalVersionParser : Cm.Ast.VersionParser
    {
        static nothrow GlobalVersionParser() : globalInstance(new GlobalVersionParser())
        {
        }
        private nothrow GlobalVersionParser()
        {
            SetInstance(this);
        }
        public static nothrow void Create()
        {
        }
        public override Cm.Ast.ProgramVersion Parse(const string& versionNumberStr)
        {
            return Grammars.Instance().GetVersionNumberGrammar()->Parse(versionNumberStr.Chars(), versionNumberStr.Chars() + versionNumberStr.Length(), 0, "");
        }
        private static UniquePtr<GlobalVersionParser> globalInstance;
    }
    
    public void BuildSolution(const string& solutionFilePath, bool rebuild, const List<string>& compileFileNames, const HashSet<string>& defines)
    {
        GlobalVersionParser.Create();
        int built = 0;
        int uptodate = 0;
        if (!FileExists(solutionFilePath))
        {
            throw Cm.Core.Error("solution file '" + solutionFilePath + "' not found");
        }
        Cm.Parser.SolutionGrammar* solutionGrammar = Grammars.Instance().GetSolutionGrammar();
        FileMapping solutionFile(solutionFilePath);
        UniquePtr<Cm.Ast.Solution> solution(solutionGrammar->Parse(solutionFile.Begin(), solutionFile.End(), 0, solutionFilePath));
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        bool clean = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.clean);
        if (!quiet)
        {
            string work = "Building";
            if (rebuild)
            {
                work = "Rebuilding";
            }            
            else if (clean)
            {
                work = "Cleaning";
            }
            Console.Out() << work << " solution '" << solution->Name() << "' (" << solution->FilePath() << ") using " << Cm.Core.GetConfig() << " configuration..." << endl();
        }
        solution->ResolveDeclarations();
        List<UniquePtr<Cm.Ast.Project>> projects;
        for (const string& projectFilePath : solution->ProjectFilePaths())
        {
            if (!FileExists(projectFilePath))
            {
                throw Cm.Core.Error("project file '" + projectFilePath + "' not found");
            }
            Cm.Parser.ProjectGrammar* projectGrammar = Grammars.Instance().GetProjectGrammar();
            FileMapping projectFile(projectFilePath);
            string backend = Cm.IrIntf.GetBackendStr();
            string os = GetOs();
            int bits = GetBits();
            Cm.Ast.ProgramVersion llvmVersion = GetLlvmVersion();
            UniquePtr<Cm.Ast.Project> project(projectGrammar->Parse(projectFile.Begin(), projectFile.End(), 0, projectFilePath, Cm.Core.GetConfig(), backend, os, bits, llvmVersion));
            project->ResolveDeclarations();
            solution->AddProject(Rvalue(project));
        }
        List<Cm.Ast.Project*> buildOrder = solution->CreateBuildOrder();
        for (Cm.Ast.Project* project : buildOrder)
        {
            if (clean)
            {
                CleanProject(project);
            }
            else
            {
                bool projectChanged = BuildProject(project, rebuild, compileFileNames, defines);
                if (projectChanged)
                {
                    rebuild = true;
                    ++built;
                }
                else
                {
                    ++uptodate;
                }
            }
        }
        if (!quiet)
        {
            if (clean)
            {
                Console.Out() << "Solution '" << solution->Name() << "' (" << solution->FilePath() << ") cleaned successfully" << endl();
            }
            else
            {
                string builtStr = "project";
                if (built != 1)
                {
                    builtStr.Append('s');
                }
                string uptodateStr = "project";
                if (uptodate != 1)
                {
                    uptodateStr.Append('s');
                }
                Console.Out() << built << " " << builtStr << " built, " << uptodate << " " << uptodateStr << " up-to-date" << endl();
                Console.Out() << "Solution '" << solution->Name() << "' (" << solution->FilePath() << ") built successfully" << endl();
            }
        }
    }
    
    public void BuildProject(const string& projectFilePath, bool rebuild, const List<string>& compileFileNames, const HashSet<string>& defines)
    {
        if (!FileExists(projectFilePath))
        {
            throw Cm.Core.Error("project file '" + projectFilePath + "' not found");
        }
        GlobalVersionParser.Create();
        Cm.Parser.ProjectGrammar* projectGrammar = Grammars.Instance().GetProjectGrammar();
        FileMapping projectFile(projectFilePath);
        string backend = Cm.IrIntf.GetBackendStr();
        string os = GetOs();
        int bits = GetBits();
        Cm.Ast.ProgramVersion llvmVersion = GetLlvmVersion();
        UniquePtr<Cm.Ast.Project> project(projectGrammar->Parse(projectFile.Begin(), projectFile.End(), 0, projectFilePath, Cm.Core.GetConfig(), backend, os, bits, llvmVersion));
        project->ResolveDeclarations();
        bool clean = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.clean);
        if (clean)
        {
            CleanProject(project.GetPtr());
        }
        else
        {
            BuildProject(project.GetPtr(), rebuild, compileFileNames, defines);
        }
    }
    
    public bool BuildProject(Cm.Ast.Project* project, bool rebuild, const List<string>& compileFileNames, const HashSet<string>& defines)
    {
        bool changed = false;
        Cm.Core.GlobalSettings.Instance().SetCurrentProjectName(project->Name());
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet)
        {
            string work = "Building";
            if (rebuild)
            {
                work = "Rebuilding";
            }
            Console.Out() << work << " project '" << project->Name() << "' (" << project->FilePath() << ") using " << Cm.Core.GetConfig() << " configuration..." << endl();
        }
        HashSet<string> allDefines = defines;
        if (Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.ide))
        {
            ReadIdeDefines(allDefines, project);
        }
        AddPlatformConfigAndBitsDefines(allDefines);
        Cm.Sym.Define(allDefines);
        Cm.Parser.FileRegistry.Init();
        if (!quiet)
        {
            int n = project->SourceFilePaths().Count();
            string sourceFiles = " source file";
            if (n > 1)
            {
                sourceFiles.Append('s');
            }
            Console.Out() << "Parsing " << n << sourceFiles << "..." << endl();
        }
        Cm.Ast.SyntaxTree syntaxTree = ParseSources(Cm.Parser.FileRegistry.Instance(), project->SourceFilePaths());
        Cm.Core.GlobalConceptData globalConceptData;
        Cm.Core.GlobalConceptData.SetInstance(&globalConceptData);
        Cm.Sym.SymbolTable symbolTable;
        Cm.Sym.ExceptionTable exceptionTable;
        Cm.Sym.ExceptionTable.SetInstance(&exceptionTable);
        Cm.Sym.MutexTable mutexTable;
        Cm.Sym.MutexTable.SetInstance(&mutexTable);
        Cm.Sym.ClassCounter classCounter;
        Cm.Sym.ClassCounter.SetInstance(&classCounter);
        ReadNextCid();
        List<string> assemblyFilePaths;
        assemblyFilePaths.Add(project->AssemblyFilePath());
        List<string> cLibraryFilePaths = project->CLibraryFilePaths();
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        List<string> allReferenceFilePaths;
        List<string> allDebugInfoFilePaths;
        List<string> allNativeObjectFilePaths;
        List<string> allBcuPaths;
        List<ulong> classHierarchyTable;
        List<string> allLibrarySearchPaths;
        string libraryFilePath = Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(project->FilePath()), ".cml"));
        if (!rebuild && FileExists(libraryFilePath))
        {
            Cm.Sym.Module module(libraryFilePath);
            module.CheckFileVersion();
        }
        BuildSymbolTable(symbolTable, rebuild, syntaxTree, project, libraryDirectories, assemblyFilePaths, cLibraryFilePaths, allReferenceFilePaths, allDebugInfoFilePaths, allNativeObjectFilePaths, allBcuPaths, 
            classHierarchyTable, allLibrarySearchPaths);
        CreateDirectories(project->OutputBasePath());
        List<string> objectFilePaths;
        bool cFilesChanged = CompileCFiles(project, objectFilePaths);
        if (!changed)
        {
            changed = cFilesChanged;
        }
        bool asmSouresChanged = CompileAsmSources(project, objectFilePaths);
        if (!changed)
        {
            changed = asmSouresChanged;
        }
        List<string> nativeObjectFilePaths = objectFilePaths;
        List<string> debugInfoFilePaths;
        List<string> bcuPaths;
        changed = true; // todo: remove this
        if (Compile(project, symbolTable, syntaxTree, project->OutputBasePath(), objectFilePaths, rebuild, compileFileNames, debugInfoFilePaths, bcuPaths))
        {
            changed = true;
        }
        if (project->GetTarget() == Cm.Ast.Target.program)
        {
/*            
            bool mainCompileUnitGenerated = CreateMainCompileUnit(symbolTable, project->OutputBasePath(), objectFilePaths, changed || rebuild);
            if (!changed)
            {
                changed = mainCompileUnitGenerated;
            }
*/            
/*            
            bool exceptionTableUnitGenerated = CreateExceptionTableUnit(symbolTable, project->OutputBasePath(), objectFilePaths, changed || rebuild);
            if (!changed)
            {
                changed = exceptionTableUnitGenerated;
            }
*/            
        }
        bool objectFilesChanged = Archive(objectFilePaths, project->AssemblyFilePath());
        if (!changed)
        {
            changed = objectFilesChanged;
        }
        if (project->GetTarget() == Cm.Ast.Target.program)
        {
            bool linked = Link(assemblyFilePaths, cLibraryFilePaths, project->ExecutableFilePath());
            if (!changed)
            {
                changed = linked;
            }
        }
        if (changed)
        {
            if (!quiet)
            {
                Console.Out() << "Generating library file..." << endl();
                Console.Out() << "=> " << libraryFilePath << endl();
            }
            Cm.Sym.Module projectModule(libraryFilePath);
            projectModule.SetName(project->Name());
            projectModule.SetSourceFilePaths(project->SourceFilePaths());
            projectModule.SetReferenceFilePaths(allReferenceFilePaths);
            projectModule.SetCLibraryFilePaths(project->CLibraryFilePaths());
            projectModule.SetLibrarySearchPaths(project->LibrarySearchPaths());
            projectModule.SetDebugInfoFilePaths(debugInfoFilePaths);
            projectModule.SetNativeObjectFilePaths(nativeObjectFilePaths);
            projectModule.SetBcuPaths(bcuPaths);
            //projectModule.Export(symbolTable);
        }
        if (project->GetTarget() == Cm.Ast.Target.program && Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.generate_debug_info))
        {
            for (const string& debugInfoFilePath : debugInfoFilePaths)
            {
                allDebugInfoFilePaths.Add(debugInfoFilePath);
            }
            bool debugInfoFileCreated = CreateDebugInfoFile(project->ExecutableFilePath(), allDebugInfoFilePaths);
            if (!changed)
            {
                changed = debugInfoFileCreated;
            }
        }
        WriteNextCid();
        Cm.Sym.ClassCounter.SetInstance(null);
        Cm.Sym.MutexTable.SetInstance(null);
        Cm.Sym.ExceptionTable.SetInstance(null);
        if (!quiet)
        {
            if (!changed)
            {
                Console.Out() << "Project '" << project->Name() << "' (" << project->FilePath() << ") is up-to-date" << endl();
            }
            else
            {
                Console.Out() << "Project '" << project->Name() << "' (" << project->FilePath() << ") built successfully" << endl();
            }
        }
        Cm.Core.GlobalSettings.Instance().SetCurrentProjectName("");
        return changed;
    }
    
    public Cm.Ast.SyntaxTree ParseSources(Cm.Parser.FileRegistry* fileRegistry, const List<string>& sourceFilePaths)
    {
        Cm.Parser.CompileUnitGrammar* compileUnitGrammar = Grammars.Instance().GetCompileUnitGrammar();
        Cm.Ast.SyntaxTree syntaxTree;
        for (const string& sourceFilePath : sourceFilePaths)
        {
            FileMapping sourceFile(sourceFilePath);
            int sourceFileIndex = fileRegistry->RegisterParsedFile(sourceFilePath);
            Cm.Parser.ParsingContext ctx;
            Cm.Ast.CompileUnitNode* compileUnit = compileUnitGrammar->Parse(sourceFile.Begin(), sourceFile.End(), sourceFileIndex, sourceFilePath, &ctx);
            syntaxTree.AddCompileUnit(compileUnit);
        }
        return syntaxTree;
    }
    
    public void ReadNextSid(Cm.Sym.SymbolTable& symbolTable)
    {
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        uint nextSid = symbolTable.GetNextSid();
        string nextSidFileName = Cm.IrIntf.GetBackendStr();
        nextSidFileName.Append('.').Append(Cm.Core.GetConfig()).Append(".next.sid");
        string nextSidPath = Path.Combine(libraryDirectories.Front(), nextSidFileName);
        if (FileExists(nextSidPath))
        {
            InputFileStream nextSidFile(nextSidPath);
            string nextSidStr = nextSidFile.ReadToEnd();
            nextSid = ParseUInt(nextSidStr);
        }
        symbolTable.SetNextSid(nextSid);
    }
    
    public void WriteNextSid(Cm.Sym.SymbolTable& symbolTable)
    {
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        uint nextSid = symbolTable.GetNextSid();
        string nextSidFileName = Cm.IrIntf.GetBackendStr();
        nextSidFileName.Append('.').Append(Cm.Core.GetConfig()).Append(".next.sid");
        string nextSidPath = Path.Combine(libraryDirectories.Front(), nextSidFileName);
        OutputFileStream nextSidFile(nextSidPath);
        nextSidFile << nextSid;
    }

    public void ReadNextCid()
    {
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        ulong nextCid = 0u;
        string nextCidFileName = Cm.IrIntf.GetBackendStr();
        nextCidFileName.Append('.').Append(Cm.Core.GetConfig()).Append(".next.cid");
        string nextCidPath = Path.Combine(libraryDirectories.Front(), nextCidFileName);
        if (FileExists(nextCidPath))
        {
            InputFileStream nextCidFile(nextCidPath);
            string nextCidStr = nextCidFile.ReadToEnd();
            nextCid = ParseULong(nextCidStr);
        }
        Cm.Sym.ClassCounter.Instance()->SetNextCid(nextCid);
    }

    public void WriteNextCid()
    {
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        ulong nextCid = Cm.Sym.ClassCounter.Instance()->GetNextCid();
        string nextCidFileName = Cm.IrIntf.GetBackendStr();
        nextCidFileName.Append('.').Append(Cm.Core.GetConfig()).Append(".next.cid");
        string nextCidPath = Path.Combine(libraryDirectories.Front(), nextCidFileName);
        OutputFileStream nextCidFile(nextCidPath);
        nextCidFile << nextCid;
    }
    
    public HashMap<string, ulong> ReadCidMap(const string& cidFilePath)
    {
        HashMap<string, ulong> cidMap;
        if (FileExists(cidFilePath))
        {
            InputFileStream cidFile(cidFilePath);
            string line = cidFile.ReadLine();
            List<string> components = line.Split(':');
            if (components.Count() >= 2)
            {
                string className = components[0];
                ulong cid = ParseULong(components[1]);
                cidMap[className] = cid;
            }
        }
        return cidMap;
    }
    
    public void WriteCidMap(const string& cidFilePath, const HashMap<string, ulong>& cidMap)
    {
        OutputFileStream cidFile(cidFilePath);
        for (const Pair<string, ulong>& c : cidMap)
        {
            cidFile << c.first << ":" << c.second << endl();
        }
    }
    
    public void BuildSymbolTable(Cm.Sym.SymbolTable& symbolTable, bool rebuild, const Cm.Ast.SyntaxTree& syntaxTree, Cm.Ast.Project* project, 
        const List<string>& libraryDirectories, List<string>& assemblyFilePaths, List<string>& cLibraryFilePaths, List<string>& allReferenceFilePaths, List<string>& allDebugInfoFilePaths,
        List<string>& allNativeObjectFilePaths, List<string>& allBcuPaths, List<ulong>& classHierarchyTable, List<string>& allLibrarySearchPaths)
    {
        Cm.Core.InitSymbolTable(symbolTable);
        ReadNextSid(symbolTable);
        ImportModules(symbolTable, project, libraryDirectories, assemblyFilePaths, cLibraryFilePaths, allReferenceFilePaths, allDebugInfoFilePaths, allNativeObjectFilePaths, allBcuPaths, classHierarchyTable,
            allLibrarySearchPaths);
        symbolTable.InitVirtualFunctionTables();
        for (const UniquePtr<Cm.Ast.CompileUnitNode>& compileUnit : syntaxTree.CompileUnits())
        {
            HashMap<string, ulong> cidMap;
            string cidFilePath = GetFullPath(Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(compileUnit->FilePath()), ".cid")));
            if (!rebuild)
            {
                cidMap = ReadCidMap(cidFilePath);
            }
            Cm.Sym.DeclarationVisitor declarationVisitor(symbolTable);
            declarationVisitor.SetCidMap(&cidMap);
            compileUnit->Accept(declarationVisitor);
            WriteCidMap(cidFilePath, cidMap);
        }
    }
    
    public void ImportModules(Cm.Sym.SymbolTable& symbolTable, Cm.Ast.Project* project, const List<string>& libraryDirectories, List<string>& assemblyFilePaths, List<string>& cLibraryFilePaths, 
        List<string>& allReferenceFilePaths, List<string>& allDebugInfoFilePaths, List<string>& allNativeObjectFilePaths, List<string>& allBcuPaths, List<ulong>& classHierarchyTable, 
        List<string>& allLibrarySearchPaths)
    {
        List<string> referenceFilePaths = project->ReferenceFilePaths();
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet)
        {
            Console.Out() << "Importing libraries..." << endl();
        }
        HashSet<string> importedModules;
        if (project->Name() != "system" && project->Name() != "support" && project->Name() != "os")
        {
            referenceFilePaths.Add("system.cml");
        } 
        for (const string& referenceFilePath : referenceFilePaths)
        {
            string libraryReferencePath = ResolveLibraryReference(project->OutputBasePath(), Cm.Core.GetConfig(), libraryDirectories, referenceFilePath);
            if (importedModules.CFind(libraryReferencePath) == importedModules.CEnd())
            {
                importedModules.Insert(libraryReferencePath);
                Cm.Sym.Module module(libraryReferencePath);
                module.Import(symbolTable, importedModules, assemblyFilePaths, cLibraryFilePaths, allReferenceFilePaths, allDebugInfoFilePaths, allNativeObjectFilePaths, allBcuPaths, classHierarchyTable,
                    allLibrarySearchPaths);
                module.CheckUpToDate();
            }
        }
        symbolTable.ProcessImportedTemplateTypes();
    }
    
    public string ResolveLibraryReference(const string& projectOutputBase, const string& config, const List<string>& libraryDirectories, const string& libraryReferencePath)
    {
        List<string> searched;
        string lrp = libraryReferencePath;
        string libParent;
        if (!Path.GetDirectoryName(lrp).IsEmpty())
        {
            libParent = Path.GetDirectoryName(lrp);
        }
        string projectBase = Path.GetParent(Path.GetParent(projectOutputBase));
        string libDir = Path.Combine(Path.Combine(GetFullPath(Path.Combine(projectBase, libParent)), config), Cm.IrIntf.GetBackendStr());
        string fp = GetFullPath(Path.Combine(libDir, Path.GetFileName(lrp)));
        searched.Add(fp);
        if (FileExists(fp))
        {
            return fp;
        }
        for (const string& libraryDir : libraryDirectories)
        {
            string ld = Path.Combine(Path.Combine(Path.Combine(libraryDir, libParent), config), Cm.IrIntf.GetBackendStr());
            string fp = GetFullPath(Path.Combine(ld, Path.GetFileName(lrp)));
            searched.Add(fp);
            if (FileExists(fp))
            {
                return fp;
            }
        }
        string s;
        bool first = true;
        for (const string& srch : searched)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                s.Append(";");
            }
            s.Append(srch);
        }
        throw Exception("library reference '" + libraryReferencePath + "' not found (seached: " + s + ")");
    }
    
    public bool CompileCFiles(Cm.Ast.Project* project, List<string>& objectFilePaths)
    {
        bool changed = false;
        // todo
        if (!changed) return false;
        // todo
        return true;
    }
    
    public bool CompileAsmSources(Cm.Ast.Project* project, List<string>& objectFilePaths)
    {
        bool changed = false;
        // todo
        if (!changed) return false;
        // todo
        return true;
    }
    
    public bool Compile(Cm.Ast.Project* project, Cm.Sym.SymbolTable& symbolTable, const Cm.Ast.SyntaxTree& syntaxTree, const string& outputBasePath, List<string>& objectFilePaths, bool rebuild,
        const List<string>& compileFileNames, List<string>& debugInfoFilePaths, List<string>& bcuPaths)
    {
        bool changed = false;
        if (syntaxTree.CompileUnits().IsEmpty()) return changed;
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        string ext;
        if (Cm.IrIntf.GetBackend() == Cm.IrIntf.Backend.llvm)
        {
            ext = ".ll";
        }
        else if (Cm.IrIntf.GetBackend() == Cm.IrIntf.Backend.c)
        {
            ext = ".c";
        }
        string prebindCompileUnitIrFilePath = GetFullPath(Path.Combine(outputBasePath, "__prebind__" + ext));
        Cm.BoundTree.BoundCompileUnit prebindCompileUnit(symbolTable, syntaxTree.CompileUnits().Front().GetPtr(), prebindCompileUnitIrFilePath);
        prebindCompileUnit.SetPrebindCompileUnit();
        prebindCompileUnit.SetClassTemplateRepository(new Cm.Bind.ClassTemplateRepository(prebindCompileUnit));
        prebindCompileUnit.SetInlineFunctionRepository(new Cm.Bind.InlineFunctionRepository(prebindCompileUnit));
        prebindCompileUnit.SetSynthesizedClassFunRepository(new Cm.Bind.SynthesizedClassFunRepository(prebindCompileUnit));
        prebindCompileUnit.SetDelegateTypeOpRepository(new Cm.Bind.DelegateTypeOpRepository(prebindCompileUnit));
        prebindCompileUnit.SetClassDelegateTypeOpRepository(new Cm.Bind.ClassDelegateTypeOpRepository(prebindCompileUnit));
        prebindCompileUnit.SetArrayTypeOpRepository(new Cm.Bind.ArrayTypeOpRepository(prebindCompileUnit));
        List<UniquePtr<Cm.Sym.FileScope>> fileScopes;
        for (const UniquePtr<Cm.Ast.CompileUnitNode>& compileUnit : syntaxTree.CompileUnits())
        {
            Cm.Bind.Prebinder prebinder(symbolTable, prebindCompileUnit.ClassTemplateRepository());
            compileUnit->Accept(prebinder);
            fileScopes.Add(UniquePtr<Cm.Sym.FileScope>(prebinder.ReleaseFileScope()));
        }
        for (const UniquePtr<Cm.Ast.CompileUnitNode>& compileUnit : syntaxTree.CompileUnits())
        {
            Cm.Bind.VirtualBinder virtualBinder(symbolTable, compileUnit.GetPtr(), prebindCompileUnit);
            compileUnit->Accept(virtualBinder);
        }
        if (project->Name() == "system")
        {
            Cm.Sym.ExceptionTable* exceptionTable = Cm.Sym.ExceptionTable.Instance();
            Cm.Sym.Symbol* systemExceptionSymbol = symbolTable.GlobalScope()->Lookup("System.Exception");
            if (systemExceptionSymbol != null)
            {
                if (systemExceptionSymbol is Cm.Sym.TypeSymbol*)
                {
                    Cm.Sym.TypeSymbol* systemExceptionType = cast<Cm.Sym.TypeSymbol*>(systemExceptionSymbol);
                    exceptionTable->AddProjectException(systemExceptionType);
                }
                else
                {
                    throw Exception("System.Exception not a type");
                }
            }
            else
            {
                throw Exception("System.Exception not found");
            }
        }
        HashSet<Cm.BoundTree.BoundCompileUnit*> buildSet;
        List<UniquePtr<Cm.BoundTree.BoundCompileUnit>> boundCompileUnits;
        Cm.Core.CompileUnitMap compileUnitMap;
        Cm.Sym.SetCompileUnitMap(&compileUnitMap);
        for (const UniquePtr<Cm.Ast.CompileUnitNode>& compileUnit : syntaxTree.CompileUnits())
        {
            Cm.IrIntf.Backend backend = Cm.IrIntf.GetBackend();
            string ext;
            if (backend == Cm.IrIntf.Backend.llvm)
            {
                ext = ".ll";
            }
            else if (backend == Cm.IrIntf.Backend.c)
            {
                ext = ".c";
            }
            string fileName = Path.GetFileNameWithoutExtension(compileUnit->FilePath());
            string compileUnitIrFilePath = GetFullPath(Path.Combine(outputBasePath, fileName) + ext);
            UniquePtr<Cm.BoundTree.BoundCompileUnit> boundCompileUnit(new Cm.BoundTree.BoundCompileUnit(symbolTable, compileUnit.GetPtr(), compileUnitIrFilePath));
            boundCompileUnit->SetFileName(fileName);
            boundCompileUnit->SetProjectName(project->Name());
            bcuPaths.Add(boundCompileUnit->BcuPath());
            compileUnitMap.MapCompileUnit(compileUnit.GetPtr(), boundCompileUnit.GetPtr());
            boundCompileUnits.Add(Rvalue(boundCompileUnit));
        }
        if (Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.generate_debug_info))
        {
            for (const UniquePtr<Cm.BoundTree.BoundCompileUnit>& boundCompileUnit : boundCompileUnits)
            {
                debugInfoFilePaths.Add(boundCompileUnit->CDebugInfoFilePath());
            }
        }
        if (!rebuild)
        {
            if (!compileFileNames.IsEmpty())
            {
                for (const UniquePtr<Cm.BoundTree.BoundCompileUnit>& boundCompileUnit : boundCompileUnits)
                {
                    boundCompileUnit->ReadDependencyFile();
                    for (const string& compileFileName : compileFileNames)
                    {
                        string cfn = Path.MakeCanonical(compileFileName);
                        if (LastComponentsEqual(cfn, boundCompileUnit->SyntaxUnit()->FilePath(), '/'))
                        {
                            boundCompileUnit->WriteChangedFile();
                            buildSet.Insert(boundCompileUnit.GetPtr());
                        }
                    }
                }
            }
            else
            {
                for (const UniquePtr<Cm.BoundTree.BoundCompileUnit>& boundCompileUnit : boundCompileUnits)
                {
                    boundCompileUnit->ReadDependencyFile();
                    if (boundCompileUnit->HasChangedFile())
                    {
                        for (Cm.BoundTree.BoundCompileUnit* dependentUnit : boundCompileUnit->DependentUnits())
                        {
                            buildSet.Insert(dependentUnit);
                        }
                        boundCompileUnit->RemoveChangedFile();
                    }
                    else if (boundCompileUnit->Changed())
                    {
                        buildSet.Insert(boundCompileUnit.GetPtr());
                        for (Cm.BoundTree.BoundCompileUnit* dependentUnit : boundCompileUnit->DependentUnits())
                        {
                            buildSet.Insert(dependentUnit);
                        } 
                    }
                }
            }
        }
        int index = 0;
        bool first = true;
        List<Cm.BoundTree.BoundCompileUnit*> objectCodeCompileUnits;
        for (const UniquePtr<Cm.BoundTree.BoundCompileUnit>& boundCompileUnit : boundCompileUnits)
        {
            if (rebuild || buildSet.CFind(boundCompileUnit.GetPtr()) != buildSet.CEnd())
            {
                if (!quiet && first)
                {
                    first = false;
                    Console.Out() << "Compiling..." << endl();
                }
                if (!quiet)
                {
                    Console.Out() << "> " << GetFullPath(boundCompileUnit->SyntaxUnit()->FilePath()) << endl();
                }
                changed = true;
                boundCompileUnit->SetClassTemplateRepository(new Cm.Bind.ClassTemplateRepository(*boundCompileUnit));
                boundCompileUnit->SetInlineFunctionRepository(new Cm.Bind.InlineFunctionRepository(*boundCompileUnit));
                boundCompileUnit->SetSynthesizedClassFunRepository(new Cm.Bind.SynthesizedClassFunRepository(*boundCompileUnit));
                boundCompileUnit->SetDelegateTypeOpRepository(new Cm.Bind.DelegateTypeOpRepository(*boundCompileUnit));
                boundCompileUnit->SetClassDelegateTypeOpRepository(new Cm.Bind.ClassDelegateTypeOpRepository(*boundCompileUnit));
                boundCompileUnit->SetArrayTypeOpRepository(new Cm.Bind.ArrayTypeOpRepository(*boundCompileUnit));
                boundCompileUnit->AddFileScope(fileScopes[index].Release());
                Bind(boundCompileUnit->SyntaxUnit(), *boundCompileUnit);
            }
            ++index;
        }
        return changed;
    }
    
    public void Bind(Cm.Ast.CompileUnitNode* compileUnit, Cm.BoundTree.BoundCompileUnit& boundCompileUnit)
    {
        Cm.Sym.EraseExceptionIdFile(boundCompileUnit.IrFilePath());
        Cm.Bind.Binder binder(boundCompileUnit);
        compileUnit->Accept(binder);
    }
    
    public bool Archive(const List<string>& objectFilePaths, const string& assemblyFilePath)
    {
        bool changed = false;
        // todo
        if (!changed) return false;
        // todo
        return true;
    }
    
    public bool Link(const List<string>& assemblyFilePaths, const List<string>& cLibraryFilePaths, const string& executableFilePath)
    {
        bool changed = false;
        // todo
        if (!changed) return false;
        // todo
        return true;
    }
    
    public bool CreateDebugInfoFile(const string& executableFilePath, const List<string>& allDebugInfoFilePaths)
    {
        bool changed = false;
        // todo
        if (!changed) return false;
        // todo
        return true;
    }
    
/*    
    public bool CreateExceptionTableUnit(Cm.Sym.SymbolTable& symbolTable, const string& projectOutputBasePath, List<string>& objectFilePaths, bool changed)
    {
        // todo
        if (!changed) return false;
        // todo
        return true;
    }
*/
    
    public void GetLibraryDirectories(List<string>& libraryDirectories)
    {
        char platformPathSeparatorChar = GetPlatformPathSeparatorChar();
        char* cmLibraryPath = get_environment_variable("CM_LIBRARY_PATH");
        if (cmLibraryPath != null)
        {
            string libraryPath = cmLibraryPath;
            libraryDirectories = libraryPath.Split(platformPathSeparatorChar);
        }
        else
        {
            throw Exception("please set CM_LIBRARY_PATH environment variable to contain (at least) /path/to/system directory (dirs separated by '" + string(platformPathSeparatorChar) + ")'");
        }
    }
    
    public nothrow char GetPlatformPathSeparatorChar()
    {
    #if (WINDOWS)
        return ';';
    #endif
        return ':';
    }
    
    public nothrow const char* GetOs() 
    {
    #if (WINDOWS)
        return "windows";
    #endif
        return "linux";
    }
    
    public nothrow int GetBits()
    {
    #if (BITS64)
        return 64;
    #endif
        return 32;
    }
    
    public nothrow const Cm.Ast.ProgramVersion& GetLlvmVersion()
    {
        return Cm.Core.GlobalSettings.Instance().GetLlvmVersion();
    }
    
    public void ReadIdeDefines(HashSet<string>& allDefines, Cm.Ast.Project* project)
    {
        string projectDefinePath = Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(project->FilePath()), ".cmp.sym"));
        if (FileExists(projectDefinePath))
        {
            InputFileStream projectDefineFile(projectDefinePath);
            while (!projectDefineFile.EndOfStream())
            {
                string symbol = projectDefineFile.ReadLine();
                allDefines.Insert(symbol);
            }
        }
    }
    
    public void AddPlatformConfigAndBitsDefines(HashSet<string>& allDefines)
    {
    #if (WINDOWS)
        allDefines.Insert("WINDOWS");
    #else 
        allDefines.Insert("LINUX");
    #endif
        if (Cm.Core.GetConfig() == "debug")
        {
            allDefines.Insert("DEBUG");
        }
        else
        {
            allDefines.Insert("RELEASE");
        }
        if (GetBits() == 64)
        {
            allDefines.Insert("BITS64");
        }        
        else if (GetBits() == 32)
        {
            allDefines.Insert("BITS32");
        }
    }
    
    public void CleanProject(Cm.Ast.Project* project)
    {
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet)
        {
            Console.Out() << "Cleaning project '" << project->Name() << "' (" << GetFullPath(project->OutputBasePath()) << ")" << endl();
        }
        if (DirectoryExists(project->OutputBasePath()))
        {
            int result = remove_all(project->OutputBasePath().Chars());
            if (result == 0)
            {
                if (!quiet)
                {
                    Console.Out() << "Project '" << project->Name() << "' (" << GetFullPath(project->OutputBasePath()) << ") cleaned successfully" << endl();
                }
            }            
            else
            {
                throw Exception("could not remove directory " + GetFullPath(project->OutputBasePath()));
            }
        }        
        else
        {
            if (!quiet)
            {
                Console.Out() << "Project '" << project->Name() << "' (" << GetFullPath(project->OutputBasePath()) << ") cleaned successfully" << endl();
            }
        }
    }
}
