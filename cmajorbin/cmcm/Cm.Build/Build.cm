/*========================================================================
    Copyright (c) 2012-2016 Seppo Laakko
    http://sourceforge.net/projects/cmajor/

    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

========================================================================*/

using System;
using System.Collections;
using System.IO;
using Span = System.Text.Parsing.Span;
using CodeFormatter = System.Text.CodeFormatter;

namespace Cm.Build
{
    public class Grammars
    {
        static Grammars() : instance(new Grammars())
        {
        }
        public static Grammars& Instance()
        {
            return *instance;
        }
        private Grammars() : solutionGrammar(Cm.Parser.SolutionGrammar.Create()), projectGrammar(Cm.Parser.ProjectGrammar.Create()), compileUnitGrammar(Cm.Parser.CompileUnitGrammar.Create())
        {
        }
        public Cm.Parser.SolutionGrammar* GetSolutionGrammar() 
        {
            return solutionGrammar;
        }
        public Cm.Parser.ProjectGrammar* GetProjectGrammar()
        {
            return projectGrammar;
        }
        public Cm.Parser.CompileUnitGrammar* GetCompileUnitGrammar()
        {
            return compileUnitGrammar;
        }
        public Cm.Parser.LlvmVersionGrammar* GetLlvmVersionGrammar()
        {
            if (llvmVersionGrammar == null)
            {
                llvmVersionGrammar = Cm.Parser.LlvmVersionGrammar.Create();
            }
            return llvmVersionGrammar;
        }
        public Cm.Parser.VersionNumberGrammar* GetVersionNumberGrammar()
        {
            if (versionNumberGrammar == null)
            {
                versionNumberGrammar = Cm.Parser.VersionNumberGrammar.Create();
            }
            return versionNumberGrammar;
        }
        public Cm.Parser.ToolErrorGrammar* GetToolErrorGrammar()
        {
            if (toolErrorGrammar == null)
            {
                toolErrorGrammar = Cm.Parser.ToolErrorGrammar.Create();
            }
            return toolErrorGrammar;
        }
        private static UniquePtr<Grammars> instance;
        private Cm.Parser.SolutionGrammar* solutionGrammar;
        private Cm.Parser.ProjectGrammar* projectGrammar;
        private Cm.Parser.CompileUnitGrammar* compileUnitGrammar;
        private Cm.Parser.LlvmVersionGrammar* llvmVersionGrammar;
        private Cm.Parser.VersionNumberGrammar* versionNumberGrammar;
        private Cm.Parser.ToolErrorGrammar* toolErrorGrammar;
    }
    
    public class GlobalVersionParser : Cm.Ast.VersionParser
    {
        static nothrow GlobalVersionParser() : globalInstance(new GlobalVersionParser())
        {
        }
        private nothrow GlobalVersionParser()
        {
            SetInstance(this);
        }
        public static nothrow void Create()
        {
        }
        public override Cm.Ast.ProgramVersion Parse(const string& versionNumberStr)
        {
            return Grammars.Instance().GetVersionNumberGrammar()->Parse(versionNumberStr.Chars(), versionNumberStr.Chars() + versionNumberStr.Length(), 0, "");
        }
        private static UniquePtr<GlobalVersionParser> globalInstance;
    }
    
    public void BuildSolution(const string& solutionFilePath, bool rebuild, const List<string>& compileFileNames, const HashSet<string>& defines, ulong stackSizeOpt)
    {
        GlobalVersionParser.Create();
        int built = 0;
        int uptodate = 0;
        if (!FileExists(solutionFilePath))
        {
            throw Cm.Core.Error("solution file '" + solutionFilePath + "' not found");
        }
        Cm.Parser.SolutionGrammar* solutionGrammar = Grammars.Instance().GetSolutionGrammar();
        FileMapping solutionFile(solutionFilePath);
        UniquePtr<Cm.Ast.Solution> solution(solutionGrammar->Parse(solutionFile.Begin(), solutionFile.End(), 0, solutionFilePath));
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        bool clean = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.clean);
        if (!quiet)
        {
            string work = "Building";
            if (rebuild)
            {
                work = "Rebuilding";
            }            
            else if (clean)
            {
                work = "Cleaning";
            }
            Console.Out() << work << " solution '" << solution->Name() << "' (" << solution->FilePath() << ") using " << Cm.Core.GetConfig() << " configuration..." << endl();
        }
        solution->ResolveDeclarations();
        List<UniquePtr<Cm.Ast.Project>> projects;
        for (const string& projectFilePath : solution->ProjectFilePaths())
        {
            if (!FileExists(projectFilePath))
            {
                throw Cm.Core.Error("project file '" + projectFilePath + "' not found");
            }
            Cm.Parser.ProjectGrammar* projectGrammar = Grammars.Instance().GetProjectGrammar();
            FileMapping projectFile(projectFilePath);
            string backend = Cm.IrIntf.GetBackendStr();
            string os = GetOs();
            int bits = GetBits();
            Cm.Ast.ProgramVersion llvmVersion = GetLlvmVersion();
            UniquePtr<Cm.Ast.Project> project(projectGrammar->Parse(projectFile.Begin(), projectFile.End(), 0, projectFilePath, Cm.Core.GetConfig(), backend, os, bits, llvmVersion));
            project->ResolveDeclarations();
            solution->AddProject(Rvalue(project));
        }
        List<Cm.Ast.Project*> buildOrder = solution->CreateBuildOrder();
        for (Cm.Ast.Project* project : buildOrder)
        {
            if (clean)
            {
                CleanProject(project);
            }
            else
            {
                bool projectChanged = BuildProject(project, rebuild, compileFileNames, defines, stackSizeOpt);
                if (projectChanged)
                {
                    rebuild = true;
                    ++built;
                }
                else
                {
                    ++uptodate;
                }
            }
        }
        if (!quiet)
        {
            if (clean)
            {
                Console.Out() << "Solution '" << solution->Name() << "' (" << solution->FilePath() << ") cleaned successfully" << endl();
            }
            else
            {
                string builtStr = "project";
                if (built != 1)
                {
                    builtStr.Append('s');
                }
                string uptodateStr = "project";
                if (uptodate != 1)
                {
                    uptodateStr.Append('s');
                }
                Console.Out() << built << " " << builtStr << " built, " << uptodate << " " << uptodateStr << " up-to-date" << endl();
                Console.Out() << "Solution '" << solution->Name() << "' (" << solution->FilePath() << ") built successfully" << endl();
            }
        }
    }
    
    public void BuildProject(const string& projectFilePath, bool rebuild, const List<string>& compileFileNames, const HashSet<string>& defines, ulong stackSizeOpt)
    {
        if (!FileExists(projectFilePath))
        {
            throw Cm.Core.Error("project file '" + projectFilePath + "' not found");
        }
        GlobalVersionParser.Create();
        Cm.Parser.ProjectGrammar* projectGrammar = Grammars.Instance().GetProjectGrammar();
        FileMapping projectFile(projectFilePath);
        string backend = Cm.IrIntf.GetBackendStr();
        string os = GetOs();
        int bits = GetBits();
        Cm.Ast.ProgramVersion llvmVersion = GetLlvmVersion();
        UniquePtr<Cm.Ast.Project> project(projectGrammar->Parse(projectFile.Begin(), projectFile.End(), 0, projectFilePath, Cm.Core.GetConfig(), backend, os, bits, llvmVersion));
        project->ResolveDeclarations();
        bool clean = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.clean);
        if (clean)
        {
            CleanProject(project.GetPtr());
        }
        else
        {
            BuildProject(project.GetPtr(), rebuild, compileFileNames, defines, stackSizeOpt);
        }
    }
    
    public bool BuildProject(Cm.Ast.Project* project, bool rebuild, const List<string>& compileFileNames, const HashSet<string>& defines, ulong stackSizeOpt)
    {
        bool changed = false;
        Cm.Core.GlobalSettings.Instance().SetCurrentProjectName(project->Name());
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet)
        {
            string work = "Building";
            if (rebuild)
            {
                work = "Rebuilding";
            }
            Console.Out() << work << " project '" << project->Name() << "' (" << project->FilePath() << ") using " << Cm.Core.GetConfig() << " configuration..." << endl();
        }
        HashSet<string> allDefines = defines;
        if (Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.ide))
        {
            ReadIdeDefines(allDefines, project);
        }
        AddPlatformConfigAndBitsDefines(allDefines);
        Cm.Sym.Define(allDefines);
        Cm.Parser.FileRegistry.Init();
        if (!quiet)
        {
            int n = project->SourceFilePaths().Count();
            string sourceFiles = " source file";
            if (n > 1)
            {
                sourceFiles.Append('s');
            }
            Console.Out() << "Parsing " << n << sourceFiles << "..." << endl();
        }
        Cm.Ast.SyntaxTree syntaxTree = ParseSources(Cm.Parser.FileRegistry.Instance(), project->SourceFilePaths());
        Cm.Core.GlobalConceptData globalConceptData;
        Cm.Core.GlobalConceptData.SetInstance(&globalConceptData);
        Cm.Sym.SymbolTable symbolTable;
        Cm.Sym.ExceptionTable exceptionTable;
        Cm.Sym.ExceptionTable.SetInstance(&exceptionTable);
        Cm.Sym.MutexTable mutexTable;
        Cm.Sym.MutexTable.SetInstance(&mutexTable);
        Cm.Sym.ClassCounter classCounter;
        Cm.Sym.ClassCounter.SetInstance(&classCounter);
        ReadNextCid();
        List<string> assemblyFilePaths;
        assemblyFilePaths.Add(project->AssemblyFilePath());
        List<string> cLibraryFilePaths = project->CLibraryFilePaths();
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        List<string> allReferenceFilePaths;
        List<string> allDebugInfoFilePaths;
        List<string> allNativeObjectFilePaths;
        List<string> allBcuPaths;
        List<ulong> classHierarchyTable;
        List<string> allLibrarySearchPaths;
        string libraryFilePath = Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(project->FilePath()), ".cml"));
        if (!rebuild && FileExists(libraryFilePath))
        {
            Cm.Sym.Module module(libraryFilePath);
            module.CheckFileVersion();
        }
        BuildSymbolTable(symbolTable, rebuild, syntaxTree, project, libraryDirectories, assemblyFilePaths, cLibraryFilePaths, allReferenceFilePaths, allDebugInfoFilePaths, allNativeObjectFilePaths, allBcuPaths, 
            classHierarchyTable, allLibrarySearchPaths);
        CreateDirectories(project->OutputBasePath());
        List<string> objectFilePaths;
        bool cFilesChanged = CompileCFiles(project, objectFilePaths, rebuild);
        if (!changed)
        {
            changed = cFilesChanged;
        }
        bool cppFilesChanged = CompileCppFiles(project, objectFilePaths, rebuild);
        if (!changed)
        {
            changed = cppFilesChanged;
        }
        bool asmSouresChanged = CompileAsmSources(project, objectFilePaths, rebuild);
        if (!changed)
        {
            changed = asmSouresChanged;
        }
        List<string> nativeObjectFilePaths = objectFilePaths;
        List<string> debugInfoFilePaths;
        List<string> bcuPaths;
        if (Compile(project, symbolTable, syntaxTree, project->OutputBasePath(), objectFilePaths, rebuild, compileFileNames, debugInfoFilePaths, bcuPaths))
        {
            changed = true;
        }
        ulong stackSize = 0u;
        ulong stackSizeEnv = StackSizeEnvValue();
        ulong projectStackSize = project->StackSize();
        if (stackSizeOpt != 0u)
        {
            stackSize = stackSizeOpt;
        }
        else if (projectStackSize != 0u)
        {
            stackSize = projectStackSize;
        } 
        else if (stackSizeEnv != 0u)
        {
            stackSize = stackSizeEnv;
        }
        bool full = false;
        if (project->GetTarget() == Cm.Ast.Target.program && !full)
        {
            bool changedOrRebuilt0 = changed || rebuild;
            bool exceptionTableUnitGenerated = CreateExceptionTableUnit(symbolTable, project->OutputBasePath(), objectFilePaths, changedOrRebuilt0);
            if (!changed)
            {
                changed = exceptionTableUnitGenerated;
            }
            bool changedOrRebuilt1 = changed || rebuild;
            bool classHierarchyUnitGenerated = GenerateClassHierarchyUnit(symbolTable, classHierarchyTable, project->OutputBasePath(), objectFilePaths, changedOrRebuilt1);
            if (!changed)
            {
                changed = classHierarchyUnitGenerated;
            }
            string profDataFilePath = Path.ChangeExtension(project->AssemblyFilePath(), ".profdata");
            bool changedOrRebuilt2 = changed || rebuild;
            bool mainCompileUnitGenerated = CreateMainCompileUnit(symbolTable, project->OutputBasePath(), profDataFilePath, objectFilePaths, classHierarchyTable.Count(), stackSize, changedOrRebuilt2);
            if (!changed)
            {
                changed = mainCompileUnitGenerated;
            }
        }
        bool objectFilesChanged = Archive(objectFilePaths, project->AssemblyFilePath());
        if (!changed)
        {
            changed = objectFilesChanged;
        }
        if (project->GetTarget() == Cm.Ast.Target.program)
        {
            bool linked = Link(assemblyFilePaths, cLibraryFilePaths, allLibrarySearchPaths, project->ExecutableFilePath(), stackSize);
            if (!changed)
            {
                changed = linked;
            }
        }
        if (changed)
        {
            if (!quiet)
            {
                Console.Out() << "Generating library file..." << endl();
                Console.Out() << "=> " << libraryFilePath << endl();
            }
            Cm.Sym.Module projectModule(libraryFilePath);
            projectModule.SetName(project->Name());
            projectModule.SetSourceFilePaths(project->SourceFilePaths());
            projectModule.SetReferenceFilePaths(allReferenceFilePaths);
            projectModule.SetCLibraryFilePaths(project->CLibraryFilePaths());
            projectModule.SetLibrarySearchPaths(project->LibrarySearchPaths());
            projectModule.SetDebugInfoFilePaths(debugInfoFilePaths);
            projectModule.SetNativeObjectFilePaths(nativeObjectFilePaths);
            projectModule.SetBcuPaths(bcuPaths);
            projectModule.Export(symbolTable);
        }
        if (project->GetTarget() == Cm.Ast.Target.program && Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.generate_debug_info))
        {
            for (const string& debugInfoFilePath : debugInfoFilePaths)
            {
                allDebugInfoFilePaths.Add(debugInfoFilePath);
            }
            bool debugInfoFileCreated = CreateDebugInfoFile(project->ExecutableFilePath(), allDebugInfoFilePaths);
            if (!changed)
            {
                changed = debugInfoFileCreated;
            }
        }
        WriteNextCid();
        Cm.Sym.ClassCounter.SetInstance(null);
        Cm.Sym.MutexTable.SetInstance(null);
        Cm.Sym.ExceptionTable.SetInstance(null);
        if (!quiet)
        {
            if (!changed)
            {
                Console.Out() << "Project '" << project->Name() << "' (" << project->FilePath() << ") is up-to-date" << endl();
            }
            else
            {
                Console.Out() << "Project '" << project->Name() << "' (" << project->FilePath() << ") built successfully" << endl();
            }
        }
        Cm.Core.GlobalSettings.Instance().SetCurrentProjectName("");
        return changed;
    }
    
    public Cm.Ast.SyntaxTree ParseSources(Cm.Parser.FileRegistry* fileRegistry, const List<string>& sourceFilePaths)
    {
        Cm.Parser.CompileUnitGrammar* compileUnitGrammar = Grammars.Instance().GetCompileUnitGrammar();
        Cm.Ast.SyntaxTree syntaxTree;
        for (const string& sourceFilePath : sourceFilePaths)
        {
            FileMapping sourceFile(sourceFilePath);
            int sourceFileIndex = fileRegistry->RegisterParsedFile(sourceFilePath);
            Cm.Parser.ParsingContext ctx;
            Cm.Ast.CompileUnitNode* compileUnit = compileUnitGrammar->Parse(sourceFile.Begin(), sourceFile.End(), sourceFileIndex, sourceFilePath, &ctx);
            syntaxTree.AddCompileUnit(compileUnit);
        }
        return syntaxTree;
    }
    
    public void ReadNextSid(Cm.Sym.SymbolTable& symbolTable)
    {
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        uint nextSid = symbolTable.GetNextSid();
        string nextSidFileName = Cm.IrIntf.GetBackendStr();
        nextSidFileName.Append('.').Append(Cm.Core.GetConfig()).Append(".next.sid");
        string nextSidPath = Path.Combine(libraryDirectories.Front(), nextSidFileName);
        if (FileExists(nextSidPath))
        {
            InputFileStream nextSidFile(nextSidPath);
            string nextSidStr = nextSidFile.ReadToEnd();
            nextSid = ParseUInt(nextSidStr);
        }
        symbolTable.SetNextSid(nextSid);
    }
    
    public void WriteNextSid(Cm.Sym.SymbolTable& symbolTable)
    {
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        uint nextSid = symbolTable.GetNextSid();
        string nextSidFileName = Cm.IrIntf.GetBackendStr();
        nextSidFileName.Append('.').Append(Cm.Core.GetConfig()).Append(".next.sid");
        string nextSidPath = Path.Combine(libraryDirectories.Front(), nextSidFileName);
        OutputFileStream nextSidFile(nextSidPath);
        nextSidFile << nextSid;
    }

    public void ReadNextCid()
    {
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        ulong nextCid = 0u;
        string nextCidFileName = Cm.IrIntf.GetBackendStr();
        nextCidFileName.Append('.').Append(Cm.Core.GetConfig()).Append(".next.cid");
        string nextCidPath = Path.Combine(libraryDirectories.Front(), nextCidFileName);
        if (FileExists(nextCidPath))
        {
            InputFileStream nextCidFile(nextCidPath);
            string nextCidStr = nextCidFile.ReadToEnd();
            nextCid = ParseULong(nextCidStr);
        }
        Cm.Sym.ClassCounter.Instance()->SetNextCid(nextCid);
    }

    public void WriteNextCid()
    {
        List<string> libraryDirectories;
        GetLibraryDirectories(libraryDirectories);
        ulong nextCid = Cm.Sym.ClassCounter.Instance()->GetNextCid();
        string nextCidFileName = Cm.IrIntf.GetBackendStr();
        nextCidFileName.Append('.').Append(Cm.Core.GetConfig()).Append(".next.cid");
        string nextCidPath = Path.Combine(libraryDirectories.Front(), nextCidFileName);
        OutputFileStream nextCidFile(nextCidPath);
        nextCidFile << nextCid;
    }
    
    public HashMap<string, ulong> ReadCidMap(const string& cidFilePath)
    {
        HashMap<string, ulong> cidMap;
        if (FileExists(cidFilePath))
        {
            InputFileStream cidFile(cidFilePath);
            string line = cidFile.ReadLine();
            List<string> components = line.Split(':');
            if (components.Count() >= 2)
            {
                string className = components[0];
                ulong cid = ParseULong(components[1]);
                cidMap[className] = cid;
            }
        }
        return cidMap;
    }
    
    public void WriteCidMap(const string& cidFilePath, const HashMap<string, ulong>& cidMap)
    {
        OutputFileStream cidFile(cidFilePath);
        for (const Pair<string, ulong>& c : cidMap)
        {
            cidFile << c.first << ":" << c.second << endl();
        }
    }
    
    public void BuildSymbolTable(Cm.Sym.SymbolTable& symbolTable, bool rebuild, const Cm.Ast.SyntaxTree& syntaxTree, Cm.Ast.Project* project, 
        const List<string>& libraryDirectories, List<string>& assemblyFilePaths, List<string>& cLibraryFilePaths, List<string>& allReferenceFilePaths, List<string>& allDebugInfoFilePaths,
        List<string>& allNativeObjectFilePaths, List<string>& allBcuPaths, List<ulong>& classHierarchyTable, List<string>& allLibrarySearchPaths)
    {
        Cm.Core.InitSymbolTable(symbolTable);
        ReadNextSid(symbolTable);
        ImportModules(symbolTable, project, libraryDirectories, assemblyFilePaths, cLibraryFilePaths, allReferenceFilePaths, allDebugInfoFilePaths, allNativeObjectFilePaths, allBcuPaths, classHierarchyTable,
            allLibrarySearchPaths);
        symbolTable.InitVirtualFunctionTables();
        for (const UniquePtr<Cm.Ast.CompileUnitNode>& compileUnit : syntaxTree.CompileUnits())
        {
            HashMap<string, ulong> cidMap;
            string cidFilePath = GetFullPath(Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(compileUnit->FilePath()), ".cid")));
            if (!rebuild)
            {
                cidMap = ReadCidMap(cidFilePath);
            }
            Cm.Sym.DeclarationVisitor declarationVisitor(symbolTable);
            declarationVisitor.SetCidMap(&cidMap);
            compileUnit->Accept(declarationVisitor);
            WriteCidMap(cidFilePath, cidMap);
        }
    }
    
    public void ImportModules(Cm.Sym.SymbolTable& symbolTable, Cm.Ast.Project* project, const List<string>& libraryDirectories, List<string>& assemblyFilePaths, List<string>& cLibraryFilePaths, 
        List<string>& allReferenceFilePaths, List<string>& allDebugInfoFilePaths, List<string>& allNativeObjectFilePaths, List<string>& allBcuPaths, List<ulong>& classHierarchyTable, 
        List<string>& allLibrarySearchPaths)
    {
        List<string> referenceFilePaths = project->ReferenceFilePaths();
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet)
        {
            Console.Out() << "Importing libraries..." << endl();
        }
        HashSet<string> importedModules;
        if (project->Name() != "system" && project->Name() != "support" && project->Name() != "os")
        {
            referenceFilePaths.Add("system.cml");
        } 
        for (const string& referenceFilePath : referenceFilePaths)
        {
            string libraryReferencePath = ResolveLibraryReference(project->OutputBasePath(), Cm.Core.GetConfig(), libraryDirectories, referenceFilePath);
            if (importedModules.CFind(libraryReferencePath) == importedModules.CEnd())
            {
                importedModules.Insert(libraryReferencePath);
                Cm.Sym.Module module(libraryReferencePath);
                module.Import(symbolTable, importedModules, assemblyFilePaths, cLibraryFilePaths, allReferenceFilePaths, allDebugInfoFilePaths, allNativeObjectFilePaths, allBcuPaths, classHierarchyTable,
                    allLibrarySearchPaths);
                module.CheckUpToDate();
            }
        }
        symbolTable.ProcessImportedTemplateTypes();
    }
    
    public string ResolveLibraryReference(const string& projectOutputBase, const string& config, const List<string>& libraryDirectories, const string& libraryReferencePath)
    {
        List<string> searched;
        string lrp = libraryReferencePath;
        string libParent;
        if (!Path.GetDirectoryName(lrp).IsEmpty())
        {
            libParent = Path.GetDirectoryName(lrp);
        }
        string projectBase = Path.GetParent(Path.GetParent(projectOutputBase));
        string libDir = Path.Combine(Path.Combine(GetFullPath(Path.Combine(projectBase, libParent)), config), Cm.IrIntf.GetBackendStr());
        string fp = GetFullPath(Path.Combine(libDir, Path.GetFileName(lrp)));
        searched.Add(fp);
        if (FileExists(fp))
        {
            return fp;
        }
        for (const string& libraryDir : libraryDirectories)
        {
            string ld = Path.Combine(Path.Combine(Path.Combine(libraryDir, libParent), config), Cm.IrIntf.GetBackendStr());
            string fp = GetFullPath(Path.Combine(ld, Path.GetFileName(lrp)));
            searched.Add(fp);
            if (FileExists(fp))
            {
                return fp;
            }
        }
        string s;
        bool first = true;
        for (const string& srch : searched)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                s.Append(";");
            }
            s.Append(srch);
        }
        throw Exception("library reference '" + libraryReferencePath + "' not found (seached: " + s + ")");
    }
    
    public string QuotedPath(const string& path)
    {
        if (path.Find(' ') != -1)
        {
            return "\"" + path + "\"";
        }
        return path;
    }
    
    public bool CompileCFiles(Cm.Ast.Project* project, List<string>& objectFilePaths, bool rebuild)
    {
        bool changed = false;
        if (rebuild)
        {
            changed = true;
        }
        for (const string& cSourceFilePath : project->CSourceFilePaths())
        {
            string objectFilePath = GetFullPath(Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(cSourceFilePath), ".o")));
            objectFilePaths.Add(objectFilePath);
            if (!FileExists(objectFilePath))
            {
                changed = true;
            }
            else if (!FileExists(cSourceFilePath))
            {
                changed = true;
            }
            else if (LastWriteTimeLess(objectFilePath, cSourceFilePath))
            {
                changed = true;
            }
        }
        if (!changed) return false;
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet && !project->CSourceFilePaths().IsEmpty())
        {
            Console.Out() << "Compiling C files..." << endl();
        }
        for (const string& cSourceFilePath : project->CSourceFilePaths())
        {
            string objectFilePath = GetFullPath(Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(cSourceFilePath), ".o")));
            string ccCommand = "gcc -g -O";
            ccCommand.Append(ToString(Cm.Core.GlobalSettings.Instance().OptimizationLevel())).Append(" -pthread -c ").Append(QuotedPath(cSourceFilePath)).Append(" -o ").Append(QuotedPath(objectFilePath));
            string ccErrorFilePath = GetFullPath(Path.ChangeExtension(objectFilePath, ".c.error"));
            try
            {
                if (!quiet)
                {
                    Console.Out() << "> " << GetFullPath(cSourceFilePath) << endl();
                }
                Execute(ccCommand, 2, ccErrorFilePath);
            }
            catch (const Exception& ex)
            {
                FileMapping file(ccErrorFilePath);
                Cm.Parser.ToolErrorGrammar* toolErrorGrammar = Grammars.Instance().GetToolErrorGrammar();
                Cm.Ast.ToolError toolError;
                try
                {
                    toolError = toolErrorGrammar->Parse(file.Begin(), file.End(), 0, ccErrorFilePath);
                }                
                catch (const Exception& ex)
                {
                    string errorText(file.Begin(), file.End());
                    throw Cm.Core.Error(errorText);
                }
                throw Cm.Core.ToolError(toolError);
            }
            RemoveFile(ccErrorFilePath);
        }
        return true;
    }
    
    public bool CompileCppFiles(Cm.Ast.Project* project, List<string>& objectFilePaths, bool rebuild)
    {
        bool changed = false;
        if (rebuild)
        {
            changed = true;
        }
        for (const string& cppSourceFilePath : project->CppSourceFilePaths())
        {
            string objectFilePath = GetFullPath(Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(cppSourceFilePath), ".o")));
            objectFilePaths.Add(objectFilePath);
            if (!FileExists(objectFilePath))
            {
                changed = true;
            }
            else if (!FileExists(cppSourceFilePath))
            {
                changed = true;
            }
            else if (LastWriteTimeLess(objectFilePath, cppSourceFilePath))
            {
                changed = true;
            }
        }
        if (!changed) return false;
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet && !project->CSourceFilePaths().IsEmpty())
        {
            Console.Out() << "Compiling C++ files..." << endl();
        }
        for (const string& cppSourceFilePath : project->CppSourceFilePaths())
        {
            string objectFilePath = GetFullPath(Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(cppSourceFilePath), ".o")));
            string cxxCommand = "g++ -g -O";
            cxxCommand.Append(ToString(Cm.Core.GlobalSettings.Instance().OptimizationLevel())).Append(" -std=c++11 -pthread -c ").Append(QuotedPath(cppSourceFilePath));
            cxxCommand.Append(" -o ").Append(QuotedPath(objectFilePath));
            string cxxErrorFilePath = GetFullPath(Path.ChangeExtension(objectFilePath, ".cpp.error"));
            try
            {
                if (!quiet)
                {
                    Console.Out() << "> " << GetFullPath(cppSourceFilePath) << endl();
                }
                Execute(cxxCommand, 2, cxxErrorFilePath);
            }
            catch (const Exception& ex)
            {
                FileMapping file(cxxErrorFilePath);
                Cm.Parser.ToolErrorGrammar* toolErrorGrammar = Grammars.Instance().GetToolErrorGrammar();
                Cm.Ast.ToolError toolError;
                try
                {
                    toolError = toolErrorGrammar->Parse(file.Begin(), file.End(), 0, cxxErrorFilePath);
                }                
                catch (const Exception& ex)
                {
                    string errorText(file.Begin(), file.End());
                    throw Cm.Core.Error(errorText);
                }
                throw Cm.Core.ToolError(toolError);
            }
            RemoveFile(cxxErrorFilePath);
        }
        return true;
    }
    
    public bool CompileAsmSources(Cm.Ast.Project* project, List<string>& objectFilePaths, bool rebuild)
    {
        bool changed = false;
        if (rebuild)
        {
            changed = true;
        }
        for (const string& asmSourceFilePath : project->AsmSourceFilePaths())
        {
            string objectFilePath = GetFullPath(Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(asmSourceFilePath), ".o")));
            objectFilePaths.Add(objectFilePath);
            if (!FileExists(objectFilePath))
            {
                changed = true;
            }
            else if (!FileExists(asmSourceFilePath))
            {
                changed = true;
            }
            else if (LastWriteTimeLess(objectFilePath, asmSourceFilePath))
            {
                changed = true;
            }
        }
        if (!changed) return false;
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet && !project->AsmSourceFilePaths().IsEmpty())
        {
            Console.Out() << "Compiling assembly sources..." << endl();
        }
        for (const string& asmSourceFilePath : project->AsmSourceFilePaths())
        {
            string llErrorFilePath = GetFullPath(Path.ChangeExtension(asmSourceFilePath, ".ll.error"));
            string objectFilePath = GetFullPath(Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(asmSourceFilePath), ".o")));
            string command = "llc";
            command.Append(" -O").Append(ToString(Cm.Core.GlobalSettings.Instance().OptimizationLevel()));
            command.Append(" -filetype=obj").Append(" -o ").Append(QuotedPath(objectFilePath)).Append(' ').Append(QuotedPath(asmSourceFilePath));
            try
            {
                if (!quiet)
                {
                    Console.Out() << "> " << GetFullPath(asmSourceFilePath) << endl();
                }
                Execute(command, 2, llErrorFilePath);
            }
            catch (const Exception& ex)
            {
                FileMapping file(llErrorFilePath);
                Cm.Parser.ToolErrorGrammar* toolErrorGrammar = Grammars.Instance().GetToolErrorGrammar();
                Cm.Ast.ToolError toolError;
                try
                {
                    toolError = toolErrorGrammar->Parse(file.Begin(), file.End(), 0, llErrorFilePath);
                }                
                catch (const Exception& ex)
                {
                    string errorText(file.Begin(), file.End());
                    throw Cm.Core.Error(errorText);
                }
                throw Cm.Core.ToolError(toolError);
            }
            RemoveFile(llErrorFilePath);
        }
        return true;
    }
    
    public bool Compile(Cm.Ast.Project* project, Cm.Sym.SymbolTable& symbolTable, const Cm.Ast.SyntaxTree& syntaxTree, const string& outputBasePath, List<string>& objectFilePaths, bool rebuild,
        const List<string>& compileFileNames, List<string>& debugInfoFilePaths, List<string>& bcuPaths)
    {
        bool changed = false;
        if (syntaxTree.CompileUnits().IsEmpty()) return changed;
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        string ext;
        if (Cm.IrIntf.GetBackend() == Cm.IrIntf.Backend.llvm)
        {
            ext = ".ll";
        }
        else if (Cm.IrIntf.GetBackend() == Cm.IrIntf.Backend.c)
        {
            ext = ".c";
        }
        string prebindCompileUnitIrFilePath = GetFullPath(Path.Combine(outputBasePath, "__prebind__" + ext));
        Cm.BoundTree.BoundCompileUnit prebindCompileUnit(symbolTable, syntaxTree.CompileUnits().Front().GetPtr(), prebindCompileUnitIrFilePath);
        prebindCompileUnit.SetPrebindCompileUnit();
        prebindCompileUnit.SetClassTemplateRepository(new Cm.Bind.ClassTemplateRepository(prebindCompileUnit));
        prebindCompileUnit.SetInlineFunctionRepository(new Cm.Bind.InlineFunctionRepository(prebindCompileUnit));
        prebindCompileUnit.SetSynthesizedClassFunRepository(new Cm.Bind.SynthesizedClassFunRepository(prebindCompileUnit));
        prebindCompileUnit.SetDelegateTypeOpRepository(new Cm.Bind.DelegateTypeOpRepository(prebindCompileUnit));
        prebindCompileUnit.SetClassDelegateTypeOpRepository(new Cm.Bind.ClassDelegateTypeOpRepository(prebindCompileUnit));
        prebindCompileUnit.SetArrayTypeOpRepository(new Cm.Bind.ArrayTypeOpRepository(prebindCompileUnit));
        List<UniquePtr<Cm.Sym.FileScope>> fileScopes;
        for (const UniquePtr<Cm.Ast.CompileUnitNode>& compileUnit : syntaxTree.CompileUnits())
        {
            Cm.Bind.Prebinder prebinder(symbolTable, prebindCompileUnit.ClassTemplateRepository());
            compileUnit->Accept(prebinder);
            fileScopes.Add(UniquePtr<Cm.Sym.FileScope>(prebinder.ReleaseFileScope()));
        }
        for (const UniquePtr<Cm.Ast.CompileUnitNode>& compileUnit : syntaxTree.CompileUnits())
        {
            Cm.Bind.VirtualBinder virtualBinder(symbolTable, compileUnit.GetPtr(), prebindCompileUnit);
            compileUnit->Accept(virtualBinder);
        }
        if (project->Name() == "system")
        {
            Cm.Sym.ExceptionTable* exceptionTable = Cm.Sym.ExceptionTable.Instance();
            Cm.Sym.Symbol* systemExceptionSymbol = symbolTable.GlobalScope()->Lookup("System.Exception");
            if (systemExceptionSymbol != null)
            {
                if (systemExceptionSymbol is Cm.Sym.TypeSymbol*)
                {
                    Cm.Sym.TypeSymbol* systemExceptionType = cast<Cm.Sym.TypeSymbol*>(systemExceptionSymbol);
                    exceptionTable->AddProjectException(systemExceptionType);
                }
                else
                {
                    throw Exception("System.Exception not a type");
                }
            }
            else
            {
                throw Exception("System.Exception not found");
            }
        }
        HashSet<Cm.BoundTree.BoundCompileUnit*> buildSet;
        List<UniquePtr<Cm.BoundTree.BoundCompileUnit>> boundCompileUnits;
        Cm.Core.CompileUnitMap compileUnitMap;
        Cm.Sym.SetCompileUnitMap(&compileUnitMap);
        for (const UniquePtr<Cm.Ast.CompileUnitNode>& compileUnit : syntaxTree.CompileUnits())
        {
            Cm.IrIntf.Backend backend = Cm.IrIntf.GetBackend();
            string ext;
            if (backend == Cm.IrIntf.Backend.llvm)
            {
                ext = ".ll";
            }
            else if (backend == Cm.IrIntf.Backend.c)
            {
                ext = ".c";
            }
            string fileName = Path.GetFileNameWithoutExtension(compileUnit->FilePath());
            string compileUnitIrFilePath = GetFullPath(Path.Combine(outputBasePath, fileName) + ext);
            UniquePtr<Cm.BoundTree.BoundCompileUnit> boundCompileUnit(new Cm.BoundTree.BoundCompileUnit(symbolTable, compileUnit.GetPtr(), compileUnitIrFilePath));
            boundCompileUnit->SetFileName(fileName);
            boundCompileUnit->SetProjectName(project->Name());
            bcuPaths.Add(boundCompileUnit->BcuPath());
            compileUnitMap.MapCompileUnit(compileUnit.GetPtr(), boundCompileUnit.GetPtr());
            boundCompileUnits.Add(Rvalue(boundCompileUnit));
        }
        if (Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.generate_debug_info))
        {
            for (const UniquePtr<Cm.BoundTree.BoundCompileUnit>& boundCompileUnit : boundCompileUnits)
            {
                debugInfoFilePaths.Add(boundCompileUnit->CDebugInfoFilePath());
            }
        }
        if (!rebuild)
        {
            if (!compileFileNames.IsEmpty())
            {
                for (const UniquePtr<Cm.BoundTree.BoundCompileUnit>& boundCompileUnit : boundCompileUnits)
                {
                    boundCompileUnit->ReadDependencyFile();
                    for (const string& compileFileName : compileFileNames)
                    {
                        string cfn = Path.MakeCanonical(compileFileName);
                        if (LastComponentsEqual(cfn, boundCompileUnit->SyntaxUnit()->FilePath(), '/'))
                        {
                            boundCompileUnit->WriteChangedFile();
                            buildSet.Insert(boundCompileUnit.GetPtr());
                        }
                    }
                }
            }
            else
            {
                for (const UniquePtr<Cm.BoundTree.BoundCompileUnit>& boundCompileUnit : boundCompileUnits)
                {
                    boundCompileUnit->ReadDependencyFile();
                    if (boundCompileUnit->HasChangedFile())
                    {
                        for (Cm.BoundTree.BoundCompileUnit* dependentUnit : boundCompileUnit->DependentUnits())
                        {
                            buildSet.Insert(dependentUnit);
                        }
                        boundCompileUnit->RemoveChangedFile();
                    }
                    else if (boundCompileUnit->Changed())
                    {
                        buildSet.Insert(boundCompileUnit.GetPtr());
                        for (Cm.BoundTree.BoundCompileUnit* dependentUnit : boundCompileUnit->DependentUnits())
                        {
                            buildSet.Insert(dependentUnit);
                        } 
                    }
                }
            }
        }
        int index = 0;
        bool first = true;
        List<Cm.BoundTree.BoundCompileUnit*> objectCodeCompileUnits;
        for (const UniquePtr<Cm.BoundTree.BoundCompileUnit>& boundCompileUnit : boundCompileUnits)
        {
            if (rebuild || buildSet.CFind(boundCompileUnit.GetPtr()) != buildSet.CEnd())
            {
                if (!quiet && first)
                {
                    first = false;
                    Console.Out() << "Compiling..." << endl();
                }
                if (!quiet)
                {
                    Console.Out() << "> " << GetFullPath(boundCompileUnit->SyntaxUnit()->FilePath()) << endl();
                }
                changed = true;
                boundCompileUnit->SetClassTemplateRepository(new Cm.Bind.ClassTemplateRepository(*boundCompileUnit));
                boundCompileUnit->SetInlineFunctionRepository(new Cm.Bind.InlineFunctionRepository(*boundCompileUnit));
                boundCompileUnit->SetSynthesizedClassFunRepository(new Cm.Bind.SynthesizedClassFunRepository(*boundCompileUnit));
                boundCompileUnit->SetDelegateTypeOpRepository(new Cm.Bind.DelegateTypeOpRepository(*boundCompileUnit));
                boundCompileUnit->SetClassDelegateTypeOpRepository(new Cm.Bind.ClassDelegateTypeOpRepository(*boundCompileUnit));
                boundCompileUnit->SetArrayTypeOpRepository(new Cm.Bind.ArrayTypeOpRepository(*boundCompileUnit));
                boundCompileUnit->AddFileScope(fileScopes[index].Release());
                Bind(boundCompileUnit->SyntaxUnit(), *boundCompileUnit);
                if (boundCompileUnit->HasGotos())
                {
                    AnalyzeControlFlow(*boundCompileUnit);
                }
                if (Cm.Core.GetConfig() == "full")
                {
                    // todo
                }
                else
                {
                    Emit(symbolTable.GetTypeRepository(), *boundCompileUnit, null);
                    objectCodeCompileUnits.Add(boundCompileUnit.GetPtr());
                }
            }
            else
            {
                Cm.Sym.ProcessExceptionIdFile(boundCompileUnit->IrFilePath(), symbolTable);
            }
            objectFilePaths.Add(boundCompileUnit->ObjectFilePath());
            ++index;
        }
        for (Cm.BoundTree.BoundCompileUnit* objectCodeCompileUnit : objectCodeCompileUnits)
        {
            GenerateObjectCode(*objectCodeCompileUnit);
            if (Cm.IrIntf.GetBackend() == Cm.IrIntf.Backend.llvm && Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.emitOpt))
            {
                GenerateOptimizedLlvmCodeFile(*objectCodeCompileUnit);   
            }
        }
        return changed;
    }
    
    public void Bind(Cm.Ast.CompileUnitNode* compileUnit, Cm.BoundTree.BoundCompileUnit& boundCompileUnit)
    {
        Cm.Sym.EraseExceptionIdFile(boundCompileUnit.IrFilePath());
        Cm.Bind.Binder binder(boundCompileUnit);
        compileUnit->Accept(binder);
    }
    
    public void AnalyzeControlFlow(Cm.BoundTree.BoundCompileUnit& boundCompileUnit)
    {
        Cm.Bind.ControlFlowAnalyzer controlFlowAnalyzer;
        boundCompileUnit.Accept(controlFlowAnalyzer);
    }
    
    public void Emit(Cm.Sym.TypeRepository& typeRepository, Cm.BoundTree.BoundCompileUnit& boundCompileUnit, void* tpGraph)
    {
        if (Cm.IrIntf.GetBackend() == Cm.IrIntf.Backend.llvm)
        {
            Cm.Emit.LlvmEmitter emitter(boundCompileUnit.IrFilePath(), typeRepository, boundCompileUnit.IrFunctionRepository(), boundCompileUnit.IrClassTypeRepository(), boundCompileUnit.StringRepository(),
                boundCompileUnit.ExternalConstantRepository());
            // emitter.SetTpGraph(tpGraph); todo
            boundCompileUnit.Accept(emitter);
        }
        else if (Cm.IrIntf.GetBackend() == Cm.IrIntf.Backend.c)
        {
            Cm.Emit.CEmitter emitter(boundCompileUnit.IrFilePath(), typeRepository, boundCompileUnit.IrFunctionRepository(), boundCompileUnit.IrClassTypeRepository(), boundCompileUnit.StringRepository(),
                boundCompileUnit.ExternalConstantRepository());
            // emitter.SetTpGraph(tpGraph); todo
            boundCompileUnit.Accept(emitter);
        }
    }
    
    public void GenerateObjectCode(Cm.BoundTree.BoundCompileUnit& boundCompileUnit)
    {
        Cm.IrIntf.Backend backend = Cm.IrIntf.GetBackend();
        string errorFilePath;
        string command;
        if (backend == Cm.IrIntf.Backend.llvm)
        {
            errorFilePath = GetFullPath(Path.ChangeExtension(boundCompileUnit.IrFilePath(), ".ll.error"));
            command = "llc";
        }
        else if (backend == Cm.IrIntf.Backend.c)
        {
            errorFilePath = GetFullPath(Path.ChangeExtension(boundCompileUnit.IrFilePath(), ".c.error"));
            command = "gcc";
        }
        command.Append(" -O").Append(ToString(Cm.Core.GlobalSettings.Instance().OptimizationLevel()));
        if (backend == Cm.IrIntf.Backend.llvm)
        {
            command.Append(" -filetype=obj");
        }
        else if (backend == Cm.IrIntf.Backend.c)
        {
            command.Append(" -g -c");
        }
        command.Append(" -o ").Append(QuotedPath(boundCompileUnit.ObjectFilePath())).Append(' ').Append(QuotedPath(boundCompileUnit.IrFilePath()));
        try
        {
            Execute(command, 2, errorFilePath);
        }
        catch (const Exception& ex)
        {
            FileMapping file(errorFilePath);
            Cm.Parser.ToolErrorGrammar* toolErrorGrammar = Grammars.Instance().GetToolErrorGrammar();
            Cm.Ast.ToolError toolError;
            try
            {
                toolError = toolErrorGrammar->Parse(file.Begin(), file.End(), 0, errorFilePath);
            }                
            catch (const Exception& ex)
            {
                string errorText(file.Begin(), file.End());
                throw Cm.Core.Error(errorText);
            }
            throw Cm.Core.ToolError(toolError);
        }
        RemoveFile(errorFilePath);
    }
    
    public void GenerateOptimizedLlvmCodeFile(Cm.BoundTree.BoundCompileUnit& boundCompileUnit)
    {
        string optllErrorFilePath = GetFullPath(Path.ChangeExtension(boundCompileUnit.IrFilePath(), ".opt.ll.error"));
        string command = "opt";
        int optimizationLevel = Cm.Core.GlobalSettings.Instance().OptimizationLevel();
        if (optimizationLevel == 0)
        {
            optimizationLevel = 1;
        }
        command.Append(" -O").Append(ToString(optimizationLevel));
        command.Append(" -S").Append(" -o ").Append(QuotedPath(boundCompileUnit.OptIrFilePath())).Append(' ').Append(QuotedPath(boundCompileUnit.IrFilePath()));
        try
        {
            Execute(command, 2, optllErrorFilePath);
        }
        catch (const Exception& ex)
        {
            FileMapping file(optllErrorFilePath);
            Cm.Parser.ToolErrorGrammar* toolErrorGrammar = Grammars.Instance().GetToolErrorGrammar();
            Cm.Ast.ToolError toolError;
            try
            {
                toolError = toolErrorGrammar->Parse(file.Begin(), file.End(), 0, optllErrorFilePath);
            }                
            catch (const Exception& ex)
            {
                string errorText(file.Begin(), file.End());
                throw Cm.Core.Error(errorText);
            }
            throw Cm.Core.ToolError(toolError);
        }
        RemoveFile(optllErrorFilePath);
    }
    
    public bool Archive(const List<string>& objectFilePaths, const string& assemblyFilePath)
    {
        bool changed = false;
        if (!FileExists(assemblyFilePath))
        {
            changed = true;
        }
        else 
        {
            for (const string& objectFilePath : objectFilePaths)
            {
                if (!FileExists(objectFilePath))
                {
                    changed = true;
                }
                else if (LastWriteTimeLess(assemblyFilePath, objectFilePath))
                {
                    changed = true;
                } 
            }
        }        
        if (!changed) return false;
        RemoveFile(assemblyFilePath);
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet && !objectFilePaths.IsEmpty())
        {
            Console.Out() << "Archiving..." << endl();
        }
        string arErrorFilePath = GetFullPath(Path.ChangeExtension(assemblyFilePath, ".ar.error"));
        int i = 0; 
        int n = objectFilePaths.Count();
        while (i < n)
        {
            string command = "ar";
            command.Append(" q ").Append(QuotedPath(assemblyFilePath));
            bool stop = false;
            while (i < n && !stop)
            {
                string objectFilePath = QuotedPath(objectFilePaths[i]);
                if (command.Length() + objectFilePath.Length() + 1 < 2047)
                {
                    if (!quiet)
                    {
                        Console.Out() << "> " << GetFullPath(objectFilePaths[i]) << endl();
                    }
                    command.Append(' ').Append(objectFilePath);
                    ++i;
                }
                else
                {
                    stop = true;
                }
            }
            try
            {
                Execute(command, 2, arErrorFilePath);
            }
            catch (const Exception& ex)
            {
                FileMapping file(arErrorFilePath);
                Cm.Parser.ToolErrorGrammar* toolErrorGrammar = Grammars.Instance().GetToolErrorGrammar();
                Cm.Ast.ToolError toolError;
                try
                {
                    toolError = toolErrorGrammar->Parse(file.Begin(), file.End(), 0, arErrorFilePath);
                }                
                catch (const Exception& ex)
                {
                    string errorText(file.Begin(), file.End());
                    throw Cm.Core.Error(errorText);
                }
                throw Cm.Core.ToolError(toolError);
            }
            RemoveFile(arErrorFilePath);
        }
        if (!quiet && !objectFilePaths.IsEmpty())
        {
            Console.Out() << "=> " << GetFullPath(assemblyFilePath) << endl();   
        }
        return true;
    }
    
    public bool Link(const List<string>& assemblyFilePaths, const List<string>& cLibraryFilePaths, const List<string>& allLibrarySearchPaths, const string& executableFilePath, ulong stackSize)
    {
        bool changed = false;
        string exePath;
#if (WINDOWS)
        exePath = GetFullPath(Path.ChangeExtension(executableFilePath, ".exe"));
#else
        exePath = GetFullPath(executableFilePath);
#endif
        if (!FileExists(exePath))
        {
            changed = true;
        }
        else 
        {
            for (const string& assemblyFilePath : assemblyFilePaths)
            {
                if (!FileExists(assemblyFilePath))
                {
                    changed = true;
                }
                else if (LastWriteTimeLess(exePath, assemblyFilePath))
                {
                    changed =  true;
                }
            }
        }
        if (!changed) return false;
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet && !assemblyFilePaths.IsEmpty())
        {
            Console.Out() << "Linking..." << endl();
        }
        string command = "gcc";
#if (WINDOWS)
        if (stackSize != 0u)
        {
            command.Append(" -Wl,--stack," + ToString(stackSize));
        }
#endif
        for (const string& librarySearchPath : allLibrarySearchPaths)
        {
            command.Append(" -L").Append(QuotedPath(librarySearchPath));
        }
        command.Append(" -pthread -Xlinker --allow-multiple-definition");
        command.Append(" -Xlinker --start-group");
        for (const string& assemblyFilePath : assemblyFilePaths)
        {
            command.Append(' ').Append(QuotedPath(assemblyFilePath));
            if (!quiet)
            {
                Console.Out() << "> " << GetFullPath(assemblyFilePath) << endl();
            }
        }
        for (const string& clib : cLibraryFilePaths)
        {
            command.Append(" -l").Append(clib);
            if (!quiet)
            {
                Console.Out() << "> " << clib << endl();
            }
        }
        command.Append(" -Xlinker --end-group");
        command.Append(" -o ").Append(QuotedPath(executableFilePath));
        string exeErrorFilePath = GetFullPath(Path.ChangeExtension(executableFilePath, ".exe.error"));
        try
        {
            Execute(command, 2, exeErrorFilePath);
        }
        catch (const Exception& ex)
        {
            FileMapping file(exeErrorFilePath);
            Cm.Parser.ToolErrorGrammar* toolErrorGrammar = Grammars.Instance().GetToolErrorGrammar();
            Cm.Ast.ToolError toolError;
            try
            {
                toolError = toolErrorGrammar->Parse(file.Begin(), file.End(), 0, exeErrorFilePath);
            }                
            catch (const Exception& ex)
            {
                string errorText(file.Begin(), file.End());
                throw Cm.Core.Error(errorText);
            }
            throw Cm.Core.ToolError(toolError);
        }
        RemoveFile(exeErrorFilePath);
        if (!quiet)
        {
            Console.Out() << "=> " << exePath << endl();
        }
        return true;
    }
    
    public bool CreateDebugInfoFile(const string& executableFilePath, const List<string>& allDebugInfoFilePaths)
    {
        bool changed = false;
        // todo
        if (!changed) return false;
        // todo
        return true;
    }
    
    public bool CreateExceptionTableUnit(Cm.Sym.SymbolTable& symbolTable, const string& projectOutputBasePath, List<string>& objectFilePaths, bool changed)
    {
        Span span;
        Cm.Ast.CompileUnitNode syntaxUnit(span);
        string ext;
        Cm.IrIntf.Backend backend = Cm.IrIntf.GetBackend();
        if (backend == Cm.IrIntf.Backend.llvm)
        {
            ext = ".ll";
        }
        else if (backend == Cm.IrIntf.Backend.c)
        {
            ext = ".c";
        }
        string exceptionTableUnitIrFilePath = GetFullPath(Path.Combine(projectOutputBasePath, "__exception_table__" + ext));
        Cm.BoundTree.BoundCompileUnit exceptionTableCompileUnit(symbolTable, &syntaxUnit, exceptionTableUnitIrFilePath );
        objectFilePaths.Add(exceptionTableCompileUnit.ObjectFilePath());
        if (!changed)
        {
            if (!FileExists(exceptionTableCompileUnit.IrFilePath()))
            {
                changed = true;
            }
            else if (!FileExists(exceptionTableCompileUnit.ObjectFilePath()))
            {
                changed = true;
            }
            else if (LastWriteTimeLess(exceptionTableCompileUnit.ObjectFilePath(), exceptionTableCompileUnit.IrFilePath()))
            {
                changed = true;
            }
        }
        if (!changed) return false;
        Cm.Sym.ExceptionTable.Instance()->GenerateExceptionTableUnit(exceptionTableUnitIrFilePath);
        GenerateObjectCode(exceptionTableCompileUnit);
        return true;
    }
    
    public bool GenerateClassHierarchyUnit(Cm.Sym.SymbolTable& symbolTable, List<ulong>& classHierarchyTable, const string& projectOutputBasePath, List<string>& objectFilePaths, bool changed)
    {
        if (!symbolTable.ProjectClasses().IsEmpty())
        {
            changed = true;
        }
        for (Cm.Sym.ClassTypeSymbol* projectClass : symbolTable.ProjectClasses())
        {
            if (projectClass->IsVirtual())
            {
                classHierarchyTable.Add(projectClass->Cid());
                if (projectClass->BaseClass() != null)
                {
                    classHierarchyTable.Add(projectClass->BaseClass()->Cid());
                }
                else
                {
                    classHierarchyTable.Add(Cm.Sym.noCid);
                }
            }            
        }
        int n = classHierarchyTable.Count();
        if ((n & 1) != 0)
        {
            throw Exception("invalid class hierarachy table (not even number of entries)");
        }
        Cm.IrIntf.Backend backend = Cm.IrIntf.GetBackend();
        Span span;
        Cm.Ast.CompileUnitNode syntaxUnit(span);
        string ext;
        if (backend == Cm.IrIntf.Backend.llvm)
        {
            ext = ".ll";
        }
        else if (backend == Cm.IrIntf.Backend.c)
        {
            ext = ".c";
        }
        string classHierarchyUnitIrFilePath = GetFullPath(Path.Combine(projectOutputBasePath, "__class_hierarchy__" + ext));
        Cm.BoundTree.BoundCompileUnit classHierarchyUnit(symbolTable, &syntaxUnit, classHierarchyUnitIrFilePath);
        objectFilePaths.Add(classHierarchyUnit.ObjectFilePath());
        if (!changed)
        {
            if (!FileExists(classHierarchyUnit.IrFilePath()))
            {
                changed = true;
            }
            else if (!FileExists(classHierarchyUnit.ObjectFilePath()))
            {
                changed = true;
            }
            else if (LastWriteTimeLess(classHierarchyUnit.ObjectFilePath(), classHierarchyUnit.IrFilePath()))
            {
                changed = true;
            }
        }
        if (!changed) return false;
        if (backend == Cm.IrIntf.Backend.llvm)
        {
            OutputFileStream classHierarachyFile(classHierarchyUnitIrFilePath);
            CodeFormatter formatter(classHierarachyFile);
            UniquePtr<Ir.Intf.Type> classHierarchyArrayType(Cm.IrIntf.Array(Cm.IrIntf.I64(), n));
            classHierarchyArrayType->SetOwned();
            formatter.WriteLine("@class$hierarchy = constant " + classHierarchyArrayType->Name());
            formatter.WriteLine("[");
            formatter.IncIndent();
            for (int i = 0; i < n; ++i)
            {
                ulong entry = classHierarchyTable[i];
                string entryStr;
                entryStr.Append(Ir.Intf.Factory.Instance()->GetUI64()->Name()).Append(' ').Append(ToString(entry));
                if (i < n - 1)
                {
                    entryStr.Append(", ");
                }
                formatter.Write(entryStr);
                if ((i & 1) == 1)
                {
                    formatter.WriteLine();
                }
            }
            formatter.DecIndent();
            formatter.WriteLine("]");
            UniquePtr<Ir.Intf.Type> pointerToClassHierarchyTable(Cm.IrIntf.Pointer(classHierarchyArrayType.GetPtr(), 1u));
            pointerToClassHierarchyTable->SetOwned();
            formatter.WriteLine("@class$hierarchy$table$addr = constant i64* bitcast (" + pointerToClassHierarchyTable->Name() + " @class$hierarchy to i64*)");
        }
        else if (backend == Cm.IrIntf.Backend.c)
        {
            OutputFileStream classHierarachyFile(classHierarchyUnitIrFilePath);
            CodeFormatter formatter(classHierarachyFile);
            formatter.WriteLine("#include <stdint.h>");
            formatter.WriteLine("int64_t class_X_hierarchy[" + ToString(n) + "] =");
            formatter.WriteLine("{");
            formatter.IncIndent();
            for (int i = 0; i < n; ++i)
            {
                ulong entry = classHierarchyTable[i];
                string entryStr;
                entryStr.Append(ToString(entry));
                if (i < n - 1)
                {
                    entryStr.Append(", ");
                }
                formatter.Write(entryStr);
                if ((i & 1) == 1)
                {
                    formatter.WriteLine();
                }
            }
            formatter.DecIndent();
            formatter.WriteLine("};");
            formatter.WriteLine("int64_t* class_X_hierarchy_table_addr = class_X_hierarchy;");
        }
        GenerateObjectCode(classHierarchyUnit);
        return true;
    }
    
    public void GetLibraryDirectories(List<string>& libraryDirectories)
    {
        char platformPathSeparatorChar = GetPlatformPathSeparatorChar();
        char* cmLibraryPath = get_environment_variable("CM_LIBRARY_PATH");
        if (cmLibraryPath != null)
        {
            string libraryPath = cmLibraryPath;
            libraryDirectories = libraryPath.Split(platformPathSeparatorChar);
        }
        else
        {
            throw Exception("please set CM_LIBRARY_PATH environment variable to contain (at least) /path/to/system directory (dirs separated by '" + string(platformPathSeparatorChar) + ")'");
        }
    }
    
    public nothrow char GetPlatformPathSeparatorChar()
    {
    #if (WINDOWS)
        return ';';
    #endif
        return ':';
    }
    
    public nothrow const char* GetOs() 
    {
    #if (WINDOWS)
        return "windows";
    #endif
        return "linux";
    }
    
    public nothrow int GetBits()
    {
    #if (BITS64)
        return 64;
    #endif
        return 32;
    }
    
    public ulong StackSizeEnvValue()
    {
        char* stackSizeEnv = get_environment_variable("CM_STACK_SIZE");
        if (stackSizeEnv == null)
        {
            return 0u;
        }
        string stackSizeEnvStr = stackSizeEnv;
        return ParseULong(stackSizeEnvStr);
    }
    
    public nothrow const Cm.Ast.ProgramVersion& GetLlvmVersion()
    {
        return Cm.Core.GlobalSettings.Instance().GetLlvmVersion();
    }
    
    public void ReadIdeDefines(HashSet<string>& allDefines, Cm.Ast.Project* project)
    {
        string projectDefinePath = Path.Combine(project->OutputBasePath(), Path.ChangeExtension(Path.GetFileName(project->FilePath()), ".cmp.sym"));
        if (FileExists(projectDefinePath))
        {
            InputFileStream projectDefineFile(projectDefinePath);
            while (!projectDefineFile.EndOfStream())
            {
                string symbol = projectDefineFile.ReadLine();
                allDefines.Insert(symbol);
            }
        }
    }
    
    public void AddPlatformConfigAndBitsDefines(HashSet<string>& allDefines)
    {
    #if (WINDOWS)
        allDefines.Insert("WINDOWS");
    #else 
        allDefines.Insert("LINUX");
    #endif
        if (Cm.Core.GetConfig() == "debug")
        {
            allDefines.Insert("DEBUG");
        }
        else
        {
            allDefines.Insert("RELEASE");
        }
        if (GetBits() == 64)
        {
            allDefines.Insert("BITS64");
        }        
        else if (GetBits() == 32)
        {
            allDefines.Insert("BITS32");
        }
    }
    
    public void CleanProject(Cm.Ast.Project* project)
    {
        bool quiet = Cm.Sym.GetGlobalFlag(Cm.Sym.GlobalFlags.quiet);
        if (!quiet)
        {
            Console.Out() << "Cleaning project '" << project->Name() << "' (" << GetFullPath(project->OutputBasePath()) << ")" << endl();
        }
        if (DirectoryExists(project->OutputBasePath()))
        {
            int result = remove_all(project->OutputBasePath().Chars());
            if (result == 0)
            {
                if (!quiet)
                {
                    Console.Out() << "Project '" << project->Name() << "' (" << GetFullPath(project->OutputBasePath()) << ") cleaned successfully" << endl();
                }
            }            
            else
            {
                throw Exception("could not remove directory " + GetFullPath(project->OutputBasePath()));
            }
        }        
        else
        {
            if (!quiet)
            {
                Console.Out() << "Project '" << project->Name() << "' (" << GetFullPath(project->OutputBasePath()) << ") cleaned successfully" << endl();
            }
        }
    }
}
