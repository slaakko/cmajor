/*========================================================================
    Copyright (c) 2012-2015 Seppo Laakko
    http://sourceforge.net/projects/cmajor/
 
    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

 ========================================================================*/

[cpp]#include <Cm.Parsing.Cpp/Expression.hpp>
[cpp]#include <Cm.Parsing.Cpp/Declaration.hpp>
[cpp]#include <Cm.Util/TextUtils.hpp>
[hpp]#include <Cm.Parsing.CppObjectModel/Declaration.hpp>
[cpp]#include <Cm.Parsing.CppObjectModel/Type.hpp>

namespace Cm.Parsing.Cpp
{
    [cpp]using Cm::Util::Trim;
    [cpp]using namespace Cm::Parsing::CppObjectModel;

    grammar DeclaratorGrammar
    {
        using ExpressionGrammar.ConstantExpression;
        using ExpressionGrammar.IdExpression;
        using ExpressionGrammar.ExpressionList;
        using ExpressionGrammar.AssignmentExpression;
        using DeclarationGrammar.TypeName;
        using DeclarationGrammar.TypeSpecifier;
        using DeclarationGrammar.CVQualifier;
        
        InitDeclaratorList: Cm::Parsing::CppObjectModel::InitDeclaratorList*
                        ::= empty{ value = new InitDeclaratorList(); }
                            InitDeclarator{ value->Add(InitDeclarator); } % ','
                        ;
                        
        InitDeclarator: Cm::Parsing::CppObjectModel::InitDeclarator*
                        ::= (Declarator Initializer?)
                        {
                            value = new InitDeclarator(Declarator, Initializer);
                        }
                        ;
                        
        Declarator: std::string
                        ::= 
                        (   DirectDeclarator 
                        |   PtrOperator Declarator
                        )
                        { 
                            value = Trim(std::string(matchBegin, matchEnd)); 
                        }
                        ;
                        
        DirectDeclarator 
                        ::= DeclaratorId
                        (
                            '[' ConstantExpression? ']'
                            '(' Declarator ')'
                        )*
                        ;
                        
        DeclaratorId    ::= IdExpression
                        |   TypeName
                        ;
    
        TypeId: Cm::Parsing::CppObjectModel::TypeId*
                        ::= empty{ value = new TypeId(); } 
                        (TypeSpecifierSeq(value) | TypeName{ value->Add(TypeName); }) 
                        (AbstractDeclarator{ value->Declarator() = AbstractDeclarator; })?
                        ;
                        
        Type: Cm::Parsing::CppObjectModel::Type*     
                        ::= empty{ value = new Type(); }
                            (   (TypeSpecifier{ value->Add(TypeSpecifier); })+
                            |   TypeName{ value->Add(TypeName); }
                            )
                        ;
                        
        TypeSpecifierSeq(Cm::Parsing::CppObjectModel::TypeId* typeId)
                        ::= (TypeSpecifier{ typeId->TypeSpecifiers().push_back(TypeSpecifier); })+
                        ;
                        
        AbstractDeclarator: std::string
                        ::= 
                        (   PtrOperator AbstractDeclarator?
                        |   DirectAbstractDeclarator
                        )
                        { 
                            value = Trim(std::string(matchBegin, matchEnd));
                        }
                        ;
                        
        DirectAbstractDeclarator
                        ::= 
                        (   '[' ConstantExpression? ']'
                        |   '(' AbstractDeclarator ')'
                        )+
                        ;
    
        PtrOperator     ::= '*' CVQualifierSeq?
                        |   '&'
                        ;
        
        CVQualifierSeq  ::= CVQualifier+
                        ;
                        
        Initializer: Cm::Parsing::CppObjectModel::Initializer*
                        ::= '=' InitializerClause{ value = new Initializer(InitializerClause, Cm::Parsing::CppObjectModel::GetEmptyVector()); }
                        |   ('(' ExpressionList ')'){ value = new Initializer(nullptr, ExpressionList); }
                        ;
                        
        InitializerClause: Cm::Parsing::CppObjectModel::AssignInit*
                        ::= AssignmentExpression{  value = new AssignInit(AssignmentExpression); }
                        |   '{'{ value = new AssignInit(nullptr); } InitializerList(value) '}'
                        |   '{' '}'{ value = new AssignInit(nullptr); }
                        ;
                        
        InitializerList(Cm::Parsing::CppObjectModel::AssignInit* init)
                        ::= InitializerClause{ init->Add(InitializerClause); } % ','
                        ;
   }
}
