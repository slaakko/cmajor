\documentclass[oneside, a4paper, 11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{graphics}
\usepackage{url}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref}

\begin{document}

\title{Cmajor Compiler User's Manual}
\author{Seppo Laakko}
\maketitle

\section{File Types}

Table \ref{tab:files} shows the file types recognized or generated by the Cmajor compiler.

\begin{table}[htb]
\caption{Cmajor Files}\label{tab:files}
\begin{tabular}{ll}
\textbf{File Extension} & \textbf{Description}\\
\hline
.cm & Cmajor Source File\\
.cmp & Cmajor Project File\\
.cms & Cmajor Solution File\\
.ll & LLVM Intermediate Code File\\
.opt.ll & Optimized LLVM Intermediate Code File\\
.c & C Intermediate Code File\\
.cdi & C Debug Information File\\
.cmdb & Cmajor Debugger Debug Information File\\
.o & Object Code File\\
.cml & Cmajor Library File\\
.cma & Cmajor Assembly File\\
.dep & Dependency Information File\\
.exc & Exception Type File\\
.bcu & Bound Compile Unit\\
.fun & Temporary Function Intermediate Code File\\
.cmp.sym & Conditional Compilation Symbols\\
.cmp.usr & Project Property File\\
.cms.usr & Solution Property File\\
\end{tabular}
\end{table}

.cma file is actually an archive containing object code and generated by the \verb|ar| command.\\

\section{Compile Process}

If the file argument for the compiler is a solution file (.cms),
the compiler parses the solution file and does a
topological sort for the projects the solution contains
to determine the project build order.

If the file argument for the compiler is a project file (.cmp),
the project build order consists trivially of the sole project file.

The following steps are executed for each project the solution contains:

\begin{enumerate}

\item
The source files of the project are parsed and abstract syntax trees for the
objects in each source file are created.

\item
Project's symbol table is initialized.

\item
The symbol tables of the libraries the project uses are imported to the project's symbol table.

\item
The abstract syntax trees are traversed and symbols for AST nodes are created and
inserted to the symbol table.

AST nodes that have corresponding symbols are:

\begin{itemize}
\item
namespaces,

\item
classes,

\item
functions,

\item
enumerated types and

\item
enumeration constants,

\item
typedefs,

\item
delegates,

\item
class delegates,

\item
template parameters,

\item
parameters,

\item
variables,

\item
code blocks (compound statements), for statetements and range for statements,

\item
concepts.

\end{itemize}

\item
C files the project contains are compiled using gcc.

\item
C++ files the project contains are compiled using g++.

\item
LLVM intermediate code files the project contains are compiled using llc.

\item
Main compilation begins. The compilation consists of following phases.

\begin{itemize}

\item
Syntax trees for all compile units are traversed using the prebinder.
The prebinder gets the symbol for the corresponding AST node and
processes it.
The prebinder checks that the specifiers for the symbol make sense.
It also resolves type nodes to the corresponding type symbols.

The nodes and symbols processed are:
namespace imports and using aliases, classes, functions, variables, enumerated types
and enumeration constants, constants, parameters, delegates and class delegates.

\item
Syntax trees for all compile units are traversed using the virtual binder.
The main task of the virtual binder is to initialize virtual function tables for
class symbols.
It also generates a destructor for a class if the class is virtual or has a nontrivial
destructor for some member variable, or has base class that has a destructor.
Finally the virtual binder generates a static constructor for a class if the
the does not have a user defined static constructor but has a static member variable.

\item
Each compile unit in turn is bound using the main binder,
intermediate code for it is generated using the emitter and
the intermediate code is compiled to object code using llc (if LLVM backend is used)
or gcc (if C backend is used).

The main binder traverses a syntax tree for the compile unit and generates
a corresponding bound tree.
The bound tree contains nodes for classes, functions, statements and expressions.
Each bound expression node has a resolved type symbol and
overload resolution is used to resolve function calls to function symbols.

The overload resolution also fires generation of syntax trees for function template
specializations and for member functions of class template specializations.
Generated syntax trees are recursively processed using the prebinder, virtual binder
and main binder.

The overload resolution also fires generation of synthesized class member functions.
The synthesized class member functions are default constructors, copy constructors,
copy assignments, move constructors and move assignments. They are automatically
generated by the compiler if neeeded (called) unless suppressed by the user.

\item
The emitter processes the bound tree representation generated by the main binder
and generates an intermediate code file (.ll for LLVM and .c for C backend).
The intermediate code file is a text file that contains primitive instructions
for each bound class, function, statement and expression.
(See for example \url{http://llvm.org/docs/LangRef.html}.)
The generated C code is very primitive and looks more like assembler.

\item
The generated intermediate code is feeded to static LLVM compiler (llc) or
C compiler (gcc), that generate object code (.o file) for it.

\end{itemize}

\item
If compiling a program, a compile unit containing main function is generated (\verb|__main__.ll| or \verb|__main__.c|).
The main function calls user supplied main function that is renamed to user main.
Also a compile unit containing an exception table is generated
(\verb|__exception_table__.ll| or \verb|__exception_table__.c|).

\item
The compiled object code files are feeded to archiver (ar) that creates an object code library (named .cma).

\item
If compiling a program , the object code libraries are linked to an executable using gcc.

\item
A library file (.cml) for the project is generated. The library file contains project's symbol table and
abstract syntax trees for templates in binary form.

\item
If compiling a program using C backend and debug configuration, a debug information file (.cmdb) is created.

\end{enumerate}

\section{Compile Options}

\begin{verbatim}
usage: cmc [options] {file.cms | file.cmp}
build solution file.cms or project file.cmp
\end{verbatim}

Compile options are shown in table \ref{tab:options}.

\begin{table}[htb]
\caption{Compile Options}\label{tab:options}
\begin{tabular}{lp{5cm}p{5cm}}
\textbf{Option}& \textbf{IDE command}& \textbf{Meaning}\\
\hline
-R & Build $|$ Rebuild Solution & Rebuild project or solution for the selected configuration\\
-clean & Build $|$ Clean Solution & Clean project or solution for the selected configuration\\
-c \verb|<file.cm>| & right click source file $|$ Compile & Compile single source file. Do not link.\\
-config=\verb|<config>| & Configuration combo box & Use \verb|<config>| configuration. (Default is \verb|debug|).\\
-D SYMBOL & Edit project properties & Define conditional compilation symbol SYMBOL.\\
-O=\verb|<n>| & & Set optimization level to \verb|<n>| (0-3). Defaults: debug: O=0, release: O=3.\\
-backend=llvm & Backend combo box & Use LLVM backend (default).\\
-backend=c & Backend combo box & Use C backend.\\
-m TRIPLE & & Override LLVM target triple to emit to .ll files.\\
-emit-no-triple & & Do not emit any LLVM target triple to .ll files.\\
-d DATALAYOUT & & Override LLVM datalayout to emit to .ll files.\\
-emit-no-layout & & Do not emit any LLVM datalayout to .ll files.\\
-emit-opt & Build $|$ Options $|$ Emit optimized intermediate code file & Write optimized intermediate code to .opt.ll file.\\
-quiet & Build $|$ Options $|$ Keep quiet & Output only errors.\\
-trace & & Instrument program/library with tracing enabled.\\
-debug\_heap & & Instrument program/library with debug heap enabled.\\
-no\_call\_stacks & & Do not generate call stack information for exceptions.\\
-class\_dot=FILE & Build $|$ Options $|$ Class hierarchy dot file path. & Generate class hierarchy graph to given dot file FILE.dot (only full config).\\
-tpg\_dot=FILE & Build $|$ Options $|$ Type propagation dot file path. & Generate type propagation graph to given dot file FILE.dot (only full config).\\
-vcall\_dbg & & Debug virtual calls (only full config).\\
-vcall\_txt=FILE & Build $|$ Options $|$ Virtual call text file path. & Print devirtualized virtual calls to FILE.txt (only full config).\\
\end{tabular}
\end{table}

\section{Target Triples and Datalayouts}

Current version of the Cmajor compiler (1.2.0) emits LLVM target triples and datalayouts to .ll files
to enable LLVM compiler to better optimize the code.

The LLVM target triple to use can be given using compiler option (-m) or an environment variable (CM\_TARGET\_TRIPLE).
If no target triple is given the Cmajor compiler emits the default target triple for the given system unless
-emit-no-triple compiler option is given.

The LLVM datalayout to use can be given using compiler option (-d) or an environment variable (CM\_TARGET\_DATALAYOUT).
If no datalayout is given the Cmajor compiler emits the default datalayout for the given system unless
-emit-no-layout compiler option is given.

To determine what is the correct LLVM target triple and datalayout for your system
create a minimal C program \textbf{target.c} and compile it using \emph{clang}.

\begin{itemize}
\item \textbf{target.c}:
\begin{verbatim}
int main()
{
    return 0;
}
\end{verbatim}

\item run clang:
\begin{verbatim}
clang -S -emit-llvm -c target.c -o target.ll
\end{verbatim}

\item Inspect \textbf{target.ll}:
\begin{verbatim}
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-w64-windows-gnu"
\end{verbatim}

\item Set environment variables for Cmajor:
\begin{verbatim}
set CM_TARGET_TRIPLE=x86_64-w64-windows-gnu
set CM_TARGET_DATALAYOUT=e-m:e-i64:64-f80:128-n8:16:32:64-S128
\end{verbatim}

To make them persistent edit environment variables in the Advanced System Settings pane in the System Control Panel (Windows) or
edit your shell script (Unix-like systems).

\end{itemize}

\section{Configurations}

\subsection{debug $|$ LLVM Configuration}

The default configuration is the \textbf{debug $|$ LLVM} configuration. In this configuration \verb|#assert| statements are in effect.
Currently programs compiled using this configuration cannot be debugged. No optimizations are performed for this configuration.

\subsection{debug $|$ C Configuration}

This configuration is selected when compiler option -backend=c is given. In this configuration \verb|#assert| statements are in effect.
Programs compiled using this configuration can be debugged from IDE in Windows or using command line tool cmdb.
No optimizations are performed for this configuration.

\subsection{release $|$ LLVM Configuration}

This configuration is selected when compiler option -config=release is given. In this configuration \verb|#assert| statements have no effect.
Programs compiled using this configuration cannot be debugged. Default optimization level for this configuration is O3. Function inlining is enabled.

\subsection{release $|$ C Configuration}

This configuration is selected when compiler options -config=release and -backend=c are given. In this configuration \verb|#assert| statements have no effect.
Programs compiled using this configuration cannot be debugged. Default optimization level for this configuration is O3. Function inlining is enabled.

\subsection{profile $|$ LLVM Configuration}

This configuration is selected when compiler option -config=profile is given. In this configuration \verb|#assert| statements have no effect.
Programs compiled using this configuration cannot be debugged. Default optimization level for this configuration is O3. Function inlining is enabled.
This configuration is used for profiling (see \emph{Profiling Cmajor Applications}).

\subsection{profile $|$ C Configuration}

This configuration is selected when compiler options -config=release and -backend=c are given. In this configuration \verb|#assert| statements have no effect.
Programs compiled using this configuration cannot be debugged. Default optimization level for this configuration is O3. Function inlining is enabled.
This configuration is used for profiling. Every function is instrumented by calls to get timestamps for start and end of the function.
This configuration is used for profiling (see \emph{Profiling Cmajor Applications}).

\subsection{full $|$ LLVM Configuration}

This configuration is selected when compile option -config=full is given. In this configuration \verb|#assert| statements have no effect.
Programs compiled using this configuration cannot be debugged. Default optimization level for this configuration is O3. Function inlining is enabled.
This is an experimental configuration.

In addition to optimizations done in \textbf{release} configuration a whole-program analysis is performed.
In the whole-program analysis the compiler builds a type propagation graph and uses it to devirtualize
virtual function calls (see \url{http://web.cs.ucla.edu/~palsberg/tba/papers/sundaresan-et-al-oopsla00.pdf}).
The original variable-type analysis is for Java, but I adapted it for Cmajor.
In addition every class of the program and in the library the program uses is given a prime number (key). The keys are used to compute a unique class identifier
for each class. The class identifier is the product of the key of the class and keys of each of its base class.
The class identifiers computed this way enable to optimize \textbf{is} and \textbf{as} expressions.
Normally \textbf{is} and \textbf{as} expression must traverse the class hierarchy,
but in this configuration determining if a class derives from another reduces to a simple modulo operation
(see \url{http://www.stroustrup.com/fast_dynamic_casting.pdf}).

Due to whole-program analysis compiles take considerably longer than in other configurations.

\subsection{full $|$ C Configuration}

This configuration is selected when compiler options -config=full and -backend=c are given. In this configuration \verb|#assert| statements have no effect.
Programs compiled using this configuration cannot be debugged. Default optimization level for this configuration is O3. Function inlining is enabled.
This is an experimental configuration.

The same whole-program analysis and optimizations it makes possible as in the \textbf{full $|$ LLVM} configuration are performed.

\section{Interoperability with C and C++}

To call a C function \textbf{foo(int)} from a Cmajor program, you must declare it in some Cmajor source file as
\textbf{extern public cdecl void foo(int arg);}.
If the \textbf{foo} function is contained in the C library \textbf{foolib.lib} you can
include the library by declaring it in the Cmajor project file as \textbf{clib $<$path/to/foolib$>$;}.
If you have a C source file \textbf{foo.c} that contains the \textbf{foo} function
you can include it in the Cmajor project file as \textbf{csource $<$foo.c$>$;}.

To call a C++ function \textbf{foo(int)} in \textbf{foo.cpp} from a Cmajor program the easest way is to define it
as \verb|extern "C" foo(int arg) { ... }| in \textbf{foo.cpp} and declare it in some Cmajor source file as
\textbf{extern public cdecl void foo(int arg);}. Then you can include it in the Cmajor project file as
\textbf{cppsource $<$foo.cpp$>$;}.
If the \textbf{foo} function is contained in a library and it is declared as \verb|extern "C"| you can proceed the same as in the C case.
However if the \textbf{foo} function is contained in a library and it is not declared as \verb|extern "C"| you
must obtain the mangled name for it somehow (for example \textbf{fooi3lx}) and declare it in some Cmajor source file as
\textbf{extern public cdecl void fooi3lx(int arg);}.
Then you can include the library by declaring it in the Cmajor project file as \textbf{clib $<$path/to/foolib$>$;}.

To call a Cmajor function \textbf{foo(int)} from a C program define the function as\\
\verb|cdecl void foo(int arg) { ... }| in \textbf{foo.cm}. Then you can declare it as
\textbf{void foo(int);} in some \textbf{foo.h} and
provide the \textbf{.cma} file generated by the Cmajor compiler to the C compiler.

To call a Cmajor function \textbf{foo(int)} from a C++ program define the function as\\
\verb|cdecl void foo(int arg) { ... }| in \textbf{foo.cm}. Then you can declare it as
\textbf{extern "C" void foo(int);} in some \textbf{foo.h} and
provide the \textbf{.cma} file generated by the Cmajor compiler to the C++ compiler.

\section{Tracing}

If a program and all libraries it uses are compiled with -trace compiler option enabled,
execution trace is printed. For example, for the following program...

\begin{verbatim}
using System;

int foo(int x)
{
    return 1;
}

void bar(double x)
{
    foo(0);
}

void main()
{
    bar(2.0);
}
\end{verbatim}

... the following trace is printed:

\begin{verbatim}
>0000:main()[C:/Programming/cmajorbin/test/tracing/tracing.cm:14]
+0001:main()[C:/Programming/cmajorbin/test/tracing/tracing.cm:15]
>0002:bar(double)[C:/Programming/cmajorbin/test/tracing/tracing.cm:9]
+0003:bar(double)[C:/Programming/cmajorbin/test/tracing/tracing.cm:10]
>0004:foo(int)[C:/Programming/cmajorbin/test/tracing/tracing.cm:4]
<0004:foo(int)[C:/Programming/cmajorbin/test/tracing/tracing.cm:4]
-0003:bar(double)[C:/Programming/cmajorbin/test/tracing/tracing.cm:10]
<0002:bar(double)[C:/Programming/cmajorbin/test/tracing/tracing.cm:9]
-0001:main()[C:/Programming/cmajorbin/test/tracing/tracing.cm:15]
<0000:main()[C:/Programming/cmajorbin/test/tracing/tracing.cm:14]
\end{verbatim}

\section{Debugging Memory Leaks}

If a program and all libraries it uses are compiled with -debug\_heap compiler option enabled,
a report of the detected memory leaks is printed at the end of the program:

\begin{verbatim}
DBGHEAP> memory leaks detected...
serial=0, mem=0000000000701A50, size=4
\end{verbatim}

Then, if the serial number of the leak is given as argument to the \verb|dbgheap_watch(int serial)| function,
The program prints call stack when allocation of that serial number occurs.

For example, program:

\begin{verbatim}
void leak()
{
    int* x = new int(1);
}

void main()
{
    dbgheap_watch(0);
    leak();
}
\end{verbatim}

Prints the following call stack:

\begin{verbatim}
call stack:
1> function 'System.Support.DebugHeapMemAlloc(ulong)' file C:/Users/Seppo/AppDat
a/Roaming/Cmajor/system/utility.cm line 136
0> function 'main()' file C:/Programming/cmajorbin/test/leak_test/leak_test.cm
line 9
\end{verbatim}

\end{document}
