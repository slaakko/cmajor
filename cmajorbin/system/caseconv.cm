using System.Collections;
using System.IO;

namespace System
{
    public nothrow inline char SeparatorChar()
    {
    #if (WINDOWS)
        return ';';
    #endif
        return ':';
    }
    
    public string PathToSystemDirectory()
    {
        char* cmLibraryPath = get_environment_variable("CM_LIBRARY_PATH");
        string cmLibPath;
        if (cmLibraryPath != null)
        {
            cmLibPath = cmLibraryPath;
        }
        if (cmLibPath.IsEmpty())
        {
            throw Exception("CM_LIBRARY_PATH environment variable not set");
        }
        List<string> paths = cmLibPath.Split(SeparatorChar());
        if (paths.Count() > 0)
        {
            return paths[0];
        }        
        else
        {
            throw Exception("library paths empty");
        }
    }
    
    public class CaseConversion
    {
        static CaseConversion() : instance(new CaseConversion())
        {
        }
        public static CaseConversion& Instance()
        {
            #assert(!instance.IsNull());
            return *instance;
        }
        private CaseConversion()
        {
            string caseConvBinFilePath = Path.Combine(PathToSystemDirectory(), "caseconv.bin");
            BinaryFileStream caseConvBinFile(caseConvBinFilePath, OpenMode.readOnly);
            long fileSize = caseConvBinFile.GetFileSize();
            uint n = cast<uint>(fileSize) / cast<uint>(sizeof(uint) * 3u);
            for (uint i = 0u; i < n; ++i)
            {
                uint code = caseConvBinFile.ReadUInt();
                uint upper = caseConvBinFile.ReadUInt();
                uint lower = caseConvBinFile.ReadUInt();
                map[cast<uchar>(code)] = Pair<uchar, uchar>(cast<uchar>(upper), cast<uchar>(lower));
            }
        }
        public uchar ToLower(uchar x)
        {
            HashMap<uchar, Pair<uchar, uchar>>.ConstIterator i = map.CFind(x);
            if (i != map.CEnd())
            {
                uchar lower = i->second.second;
                if (lower != cast<uchar>(0u))
                {
                    return lower;
                }
            }
            return x;
        }
        public uchar ToUpper(uchar x)
        {
            HashMap<uchar, Pair<uchar, uchar>>.ConstIterator i = map.CFind(x);
            if (i != map.CEnd())
            {
                uchar upper = i->second.first;
                if (upper != cast<uchar>(0u))
                {
                    return upper;
                }
            }
            return x;
        }
        private static UniquePtr<CaseConversion> instance;
        private HashMap<uchar, Pair<uchar, uchar>> map;
    }
}
