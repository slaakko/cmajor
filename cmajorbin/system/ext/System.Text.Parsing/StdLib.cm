using System;
using System.Collections;
using System.Text.Parsing;

namespace System.Text.Parsing
{
    public class stdlib: System.Text.Parsing.Grammar
    {
        public static stdlib* Create()
        {
            return Create(new ParsingDomain());
        }
        public static stdlib* Create(ParsingDomain* parsingDomain)
        {
            RegisterParsingDomain(parsingDomain);
            stdlib* grammar(new stdlib(parsingDomain));
            parsingDomain->AddGrammar(grammar);
            grammar->CreateRules();
            grammar->Link();
            return grammar;
        }
        private stdlib(ParsingDomain* parsingDomain): base("stdlib", parsingDomain->GetNamespaceScope("System.Text.Parsing"), parsingDomain)
        {
            SetOwner(0);
        }
        private class intRule: System.Text.Parsing.Rule
        {
            public intRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("int");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<int>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = ParseInt(match);
            }
            private class Context
            {
                public int value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class uintRule: System.Text.Parsing.Rule
        {
            public uintRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("uint");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<uint>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = ParseUInt(match);
            }
            private class Context
            {
                public uint value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class hexRule: System.Text.Parsing.Rule
        {
            public hexRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("ulong");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ulong>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = ParseHex(match);
            }
            private class Context
            {
                public ulong value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class hex_literalRule: System.Text.Parsing.Rule
        {
            public hex_literalRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("ulong");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ulong>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* hexNonterminalParser = GetNonterminal("hex");
                hexNonterminalParser->SetPostCall(PostCall(Posthex));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = context.fromhex;
            }
            public throw void Posthex(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromhex_value = stack.Pop();
                    context.fromhex = *cast<ValueObject<ulong>*>(fromhex_value.GetPtr());
                }
            }
            private class Context
            {
                public ulong value;
                public ulong fromhex;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class octaldigitRule: System.Text.Parsing.Rule
        {
            public octaldigitRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("int");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<int>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = cast<int>(match[0]) - cast<int>('0');
            }
            private class Context
            {
                public int value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class realRule: System.Text.Parsing.Rule
        {
            public realRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("double");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<double>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = ParseDouble(match);
            }
            private class Context
            {
                public double value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class urealRule: System.Text.Parsing.Rule
        {
            public urealRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("double");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<double>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = ParseDouble(match);
            }
            private class Context
            {
                public double value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class numberRule: System.Text.Parsing.Rule
        {
            public numberRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("double");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<double>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                NonterminalParser* rNonterminalParser = GetNonterminal("r");
                rNonterminalParser->SetPostCall(PostCall(Postr));
                NonterminalParser* iNonterminalParser = GetNonterminal("i");
                iNonterminalParser->SetPostCall(PostCall(Posti));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = context.fromr;
            }
            public throw void A1Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = context.fromi;
            }
            public throw void Postr(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromr_value = stack.Pop();
                    context.fromr = *cast<ValueObject<double>*>(fromr_value.GetPtr());
                }
            }
            public throw void Posti(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromi_value = stack.Pop();
                    context.fromi = *cast<ValueObject<int>*>(fromi_value.GetPtr());
                }
            }
            private class Context
            {
                public double value;
                public double fromr;
                public int fromi;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class boolRule: System.Text.Parsing.Rule
        {
            public boolRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("bool");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<bool>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = true;
            }
            public throw void A1Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = false;
            }
            private class Context
            {
                public bool value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class identifierRule: System.Text.Parsing.Rule
        {
            public identifierRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("string");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<string>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = match;
            }
            private class Context
            {
                public string value;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class qualified_idRule: System.Text.Parsing.Rule
        {
            public qualified_idRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("string");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<string>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                NonterminalParser* firstNonterminalParser = GetNonterminal("first");
                firstNonterminalParser->SetPostCall(PostCall(Postfirst));
                NonterminalParser* restNonterminalParser = GetNonterminal("rest");
                restNonterminalParser->SetPostCall(PostCall(Postrest));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = match;
            }
            public throw void Postfirst(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromfirst_value = stack.Pop();
                    context.fromfirst = *cast<ValueObject<string>*>(fromfirst_value.GetPtr());
                }
            }
            public throw void Postrest(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromrest_value = stack.Pop();
                    context.fromrest = *cast<ValueObject<string>*>(fromrest_value.GetPtr());
                }
            }
            private class Context
            {
                public string value;
                public string fromfirst;
                public string fromrest;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class escapeRule: System.Text.Parsing.Rule
        {
            public escapeRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("char");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<char>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                ActionParser* a2ActionParser = GetAction("A2");
                a2ActionParser->SetAction(ParsingAction(A2Action));
                ActionParser* a3ActionParser = GetAction("A3");
                a3ActionParser->SetAction(ParsingAction(A3Action));
                NonterminalParser* xNonterminalParser = GetNonterminal("x");
                xNonterminalParser->SetPostCall(PostCall(Postx));
                NonterminalParser* o1NonterminalParser = GetNonterminal("o1");
                o1NonterminalParser->SetPostCall(PostCall(Posto1));
                NonterminalParser* o2NonterminalParser = GetNonterminal("o2");
                o2NonterminalParser->SetPostCall(PostCall(Posto2));
                NonterminalParser* o3NonterminalParser = GetNonterminal("o3");
                o3NonterminalParser->SetPostCall(PostCall(Posto3));
                NonterminalParser* decimalEscapeNonterminalParser = GetNonterminal("decimalEscape");
                decimalEscapeNonterminalParser->SetPostCall(PostCall(PostdecimalEscape));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = cast<char>(context.fromx);
            }
            public throw void A1Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = cast<char>(64 * context.fromo1 + 8 * context.fromo2 + context.fromo3);
            }
            public throw void A2Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = cast<char>(context.fromdecimalEscape);
            }
            public throw void A3Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                char c = match[0];
                switch (c)
                {
                    case 'a':
                    {
                        context.value = '\a';
                        break;
                    }
                    case 'b':
                    {
                        context.value = '\b';
                        break;
                    }
                    case 'f':
                    {
                        context.value = '\f';
                        break;
                    }
                    case 'n':
                    {
                        context.value = '\n';
                        break;
                    }
                    case 'r':
                    {
                        context.value = '\r';
                        break;
                    }
                    case 't':
                    {
                        context.value = '\t';
                        break;
                    }
                    case 'v':
                    {
                        context.value = '\v';
                        break;
                    }
                    case '0':
                    {
                        context.value = '\0';
                        break;
                    }
                    default:
                    {
                        context.value = c;
                        break;
                    }
                }
            }
            public throw void Postx(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromx_value = stack.Pop();
                    context.fromx = *cast<ValueObject<ulong>*>(fromx_value.GetPtr());
                }
            }
            public throw void Posto1(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromo1_value = stack.Pop();
                    context.fromo1 = *cast<ValueObject<int>*>(fromo1_value.GetPtr());
                }
            }
            public throw void Posto2(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromo2_value = stack.Pop();
                    context.fromo2 = *cast<ValueObject<int>*>(fromo2_value.GetPtr());
                }
            }
            public throw void Posto3(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromo3_value = stack.Pop();
                    context.fromo3 = *cast<ValueObject<int>*>(fromo3_value.GetPtr());
                }
            }
            public throw void PostdecimalEscape(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromdecimalEscape_value = stack.Pop();
                    context.fromdecimalEscape = *cast<ValueObject<uint>*>(fromdecimalEscape_value.GetPtr());
                }
            }
            private class Context
            {
                public char value;
                public ulong fromx;
                public int fromo1;
                public int fromo2;
                public int fromo3;
                public uint fromdecimalEscape;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class charRule: System.Text.Parsing.Rule
        {
            public charRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("char");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<char>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                NonterminalParser* escapeNonterminalParser = GetNonterminal("escape");
                escapeNonterminalParser->SetPostCall(PostCall(Postescape));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = match[0];
            }
            public throw void A1Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value = context.fromescape;
            }
            public throw void Postescape(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromescape_value = stack.Pop();
                    context.fromescape = *cast<ValueObject<char>*>(fromescape_value.GetPtr());
                }
            }
            private class Context
            {
                public char value;
                public char fromescape;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        private class stringRule: System.Text.Parsing.Rule
        {
            public stringRule(const string& name_, Scope* enclosingScope_, Parser* definition_):
                base(name_, enclosingScope_, definition_), contextStack(), context()
            {
                SetValueTypeName("string");
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack)
            {
                contextStack.Push(Rvalue(context));
                context = Context();
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<string>(context.value)));
                }
                context = contextStack.Pop();
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction("A0");
                a0ActionParser->SetAction(ParsingAction(A0Action));
                ActionParser* a1ActionParser = GetAction("A1");
                a1ActionParser->SetAction(ParsingAction(A1Action));
                NonterminalParser* escapeNonterminalParser = GetNonterminal("escape");
                escapeNonterminalParser->SetPostCall(PostCall(Postescape));
            }
            public throw void A0Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value.Append(match);
            }
            public throw void A1Action(const string& match, const string& content, const Position& position, const string& fileName, bool& pass)
            {
                context.value.Append(context.fromescape);
            }
            public throw void Postescape(Stack<UniquePtr<Object>>& stack, bool matched)
            {
                if (matched)
                {
                    UniquePtr<Object> fromescape_value = stack.Pop();
                    context.fromescape = *cast<ValueObject<char>*>(fromescape_value.GetPtr());
                }
            }
            private class Context
            {
                public string value;
                public char fromescape;
            }
            private Stack<Context> contextStack;
            private Context context;
        }
        public override void GetReferencedGrammars()
        {
        }
        public override void CreateRules()
        {
            AddRule(new Rule("spaces", GetScope(),
                new PositiveParser(
                    new SpaceParser())));
            AddRule(new Rule("newline", GetScope(),
                new AlternativeParser(
                    new AlternativeParser(
                        new StringParser("\r\n"),
                        new StringParser("\n")),
                    new StringParser("\r"))));
            AddRule(new Rule("comment", GetScope(),
                new AlternativeParser(
                    new NonterminalParser("line_comment", "line_comment", 0),
                    new NonterminalParser("block_comment", "block_comment", 0))));
            AddRule(new Rule("line_comment", GetScope(),
                new SequenceParser(
                    new SequenceParser(
                        new StringParser("//"),
                        new KleeneStarParser(
                            new CharSetParser("\r\n", true))),
                    new NonterminalParser("newline", "newline", 0))));
            AddRule(new Rule("block_comment", GetScope(),
                new SequenceParser(
                    new SequenceParser(
                        new StringParser("/*"),
                        new KleeneStarParser(
                            new AlternativeParser(
                                new AlternativeParser(
                                    new NonterminalParser("string", "string", 0),
                                    new NonterminalParser("char", "char", 0)),
                                new DifferenceParser(
                                    new AnyCharParser(),
                                    new StringParser("*/"))
                                ))),
                    new StringParser("*/"))));
            AddRule(new Rule("spaces_and_comments", GetScope(),
                new PositiveParser(
                    new AlternativeParser(
                        new SpaceParser(),
                        new NonterminalParser("comment", "comment", 0)))));
            AddRule(new Rule("digit_sequence", GetScope(),
                new TokenParser(
                    new PositiveParser(
                        new DigitParser()))));
            AddRule(new Rule("sign", GetScope(),
                new AlternativeParser(
                    new CharParser('+'),
                    new CharParser('-'))));
            AddRule(new intRule("int", GetScope(),
                new ActionParser("A0",
                    new TokenParser(
                        new SequenceParser(
                            new OptionalParser(
                                new NonterminalParser("sign", "sign", 0)),
                            new NonterminalParser("digit_sequence", "digit_sequence", 0))))));
            AddRule(new uintRule("uint", GetScope(),
                new ActionParser("A0",
                    new NonterminalParser("digit_sequence", "digit_sequence", 0))));
            AddRule(new hexRule("hex", GetScope(),
                new ActionParser("A0",
                    new TokenParser(
                        new PositiveParser(
                            new HexDigitParser())))));
            AddRule(new hex_literalRule("hex_literal", GetScope(),
                new ActionParser("A0",
                    new TokenParser(
                        new SequenceParser(
                            new AlternativeParser(
                                new StringParser("0x"),
                                new StringParser("0X")),
                            new ExpectationParser(
                                new NonterminalParser("hex", "hex", 0)))))));
            AddRule(new octaldigitRule("octaldigit", GetScope(),
                new ActionParser("A0",
                    new CharSetParser("0-7"))));
            AddRule(new realRule("real", GetScope(),
                new ActionParser("A0",
                    new TokenParser(
                        new AlternativeParser(
                            new SequenceParser(
                                new SequenceParser(
                                    new OptionalParser(
                                        new NonterminalParser("sign", "sign", 0)),
                                    new NonterminalParser("fractional_real", "fractional_real", 0)),
                                new OptionalParser(
                                    new NonterminalParser("exponent_part", "exponent_part", 0))),
                            new SequenceParser(
                                new SequenceParser(
                                    new OptionalParser(
                                        new NonterminalParser("sign", "sign", 0)),
                                    new NonterminalParser("digit_sequence", "digit_sequence", 0)),
                                new NonterminalParser("exponent_part", "exponent_part", 0)))))));
            AddRule(new urealRule("ureal", GetScope(),
                new ActionParser("A0",
                    new TokenParser(
                        new AlternativeParser(
                            new SequenceParser(
                                new NonterminalParser("fractional_real", "fractional_real", 0),
                                new OptionalParser(
                                    new NonterminalParser("exponent_part", "exponent_part", 0))),
                            new SequenceParser(
                                new NonterminalParser("digit_sequence", "digit_sequence", 0),
                                new NonterminalParser("exponent_part", "exponent_part", 0)))))));
            AddRule(new Rule("fractional_real", GetScope(),
                new AlternativeParser(
                    new TokenParser(
                        new SequenceParser(
                            new SequenceParser(
                                new OptionalParser(
                                    new NonterminalParser("digit_sequence", "digit_sequence", 0)),
                                new CharParser('.')),
                            new NonterminalParser("digit_sequence", "digit_sequence", 0))),
                    new TokenParser(
                        new SequenceParser(
                            new NonterminalParser("digit_sequence", "digit_sequence", 0),
                            new CharParser('.'))))));
            AddRule(new Rule("exponent_part", GetScope(),
                new TokenParser(
                    new SequenceParser(
                        new SequenceParser(
                            new CharSetParser("eE"),
                            new OptionalParser(
                                new NonterminalParser("sign", "sign", 0))),
                        new NonterminalParser("digit_sequence", "digit_sequence", 0)))));
            AddRule(new numberRule("number", GetScope(),
                new AlternativeParser(
                    new ActionParser("A0",
                        new NonterminalParser("r", "real", 0)),
                    new ActionParser("A1",
                        new NonterminalParser("i", "int", 0)))));
            AddRule(new boolRule("bool", GetScope(),
                new AlternativeParser(
                    new ActionParser("A0",
                        new KeywordParser("true")),
                    new ActionParser("A1",
                        new KeywordParser("false")))));
            AddRule(new identifierRule("identifier", GetScope(),
                new ActionParser("A0",
                    new TokenParser(
                        new SequenceParser(
                            new AlternativeParser(
                                new LetterParser(),
                                new CharParser('_')),
                            new KleeneStarParser(
                                new AlternativeParser(
                                    new AlternativeParser(
                                        new LetterParser(),
                                        new DigitParser()),
                                    new CharParser('_'))))))));
            AddRule(new qualified_idRule("qualified_id", GetScope(),
                new ActionParser("A0",
                    new TokenParser(
                        new SequenceParser(
                            new NonterminalParser("first", "identifier", 0),
                            new KleeneStarParser(
                                new SequenceParser(
                                    new CharParser('.'),
                                    new NonterminalParser("rest", "identifier", 0))))))));
            AddRule(new escapeRule("escape", GetScope(),
                new TokenParser(
                    new SequenceParser(
                        new CharParser('\\'),
                        new AlternativeParser(
                            new AlternativeParser(
                                new AlternativeParser(
                                    new SequenceParser(
                                        new CharSetParser("xX"),
                                        new ActionParser("A0",
                                            new NonterminalParser("x", "hex", 0))),
                                    new ActionParser("A1",
                                        new SequenceParser(
                                            new SequenceParser(
                                                new NonterminalParser("o1", "octaldigit", 0),
                                                new NonterminalParser("o2", "octaldigit", 0)),
                                            new NonterminalParser("o3", "octaldigit", 0)))),
                                new SequenceParser(
                                    new CharSetParser("dD"),
                                    new ActionParser("A2",
                                        new NonterminalParser("decimalEscape", "uint", 0)))),
                            new ActionParser("A3",
                                new CharSetParser("dDxX", true)))))));
            AddRule(new charRule("char", GetScope(),
                new TokenParser(
                    new SequenceParser(
                        new SequenceParser(
                            new CharParser('\''),
                            new AlternativeParser(
                                new ActionParser("A0",
                                    new CharSetParser("\\\r\n", true)),
                                new ActionParser("A1",
                                    new NonterminalParser("escape", "escape", 0)))),
                        new ExpectationParser(
                            new CharParser('\''))))));
            AddRule(new stringRule("string", GetScope(),
                new TokenParser(
                    new SequenceParser(
                        new SequenceParser(
                            new CharParser('"'),
                            new KleeneStarParser(
                                new AlternativeParser(
                                    new ActionParser("A0",
                                        new PositiveParser(
                                            new CharSetParser("\"\\\r\n", true))),
                                    new ActionParser("A1",
                                        new NonterminalParser("escape", "escape", 0))))),
                        new ExpectationParser(
                            new CharParser('"'))))));
        }
    }
}
