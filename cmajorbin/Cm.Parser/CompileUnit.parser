/*========================================================================
    Copyright (c) 2012-2015 Seppo Laakko
    http://sourceforge.net/projects/cmajor/
 
    Distributed under the GNU General Public License, version 3 (GPLv3).
    (See accompanying LICENSE.txt or http://www.gnu.org/licenses/gpl.html)

 ========================================================================*/

 [hpp]#include <Cm.Parser/ParsingContext.hpp>
 [hpp]#include <Cm.Ast/CompileUnit.hpp>
 [cpp]#include <Cm.Parser/Identifier.hpp>
 [cpp]#include <Cm.Parser/Constant.hpp>
 [cpp]#include <Cm.Parser/Function.hpp>
 [cpp]#include <Cm.Parser/Enumeration.hpp>
 [cpp]#include <Cm.Parser/Typedef.hpp>
 [cpp]#include <Cm.Parser/Class.hpp>
 [cpp]#include <Cm.Parser/Delegate.hpp>
 [cpp]#include <Cm.Parser/Concept.hpp>
 [cpp]#include <Cm.Ast/Namespace.hpp>
 [cpp]#include <Cm.Ast/Identifier.hpp>
 [cpp]#include <Cm.Ast/Function.hpp>
 [cpp]#include <Cm.Ast/Constant.hpp>
 [cpp]#include <Cm.Ast/Enumeration.hpp>
 [cpp]#include <Cm.Ast/Typedef.hpp>
 [cpp]#include <Cm.Ast/Class.hpp>
 [cpp]#include <Cm.Ast/Delegate.hpp>
 [cpp]#include <Cm.Ast/Concept.hpp>

namespace Cm.Parser
{
    using namespace Cm::Ast;

    grammar CompileUnitGrammar
    {
        using IdentifierGrammar.Identifier;
        using IdentifierGrammar.QualifiedId;
        using FunctionGrammar.Function;
        using ConstantGrammar.Constant;
        using EnumerationGrammar.EnumType;
        using TypedefGrammar.Typedef;
        using ClassGrammar.Class;
        using DelegateGrammar.Delegate;
        using DelegateGrammar.ClassDelegate;
        using ConceptGrammar.Concept;
        using stdlib.spaces_and_comments;
        skip spaces_and_comments;
        recover;

        CompileUnit(ParsingContext* ctx): Cm::Ast::CompileUnit*
            ::= empty{ value = new CompileUnit(fileName); }
                NamespaceContent(ctx, value)
            ;

        NamespaceContent(ParsingContext* ctx, Cm::Ast::CompileUnit* compileUnit)
            ::= UsingDirectives(ctx, compileUnit) 
                Definitions(ctx, compileUnit)
            ;

        UsingDirectives(ParsingContext* ctx, Cm::Ast::CompileUnit* compileUnit)
            ::= UsingDirective(ctx, compileUnit)*
            ;

        UsingDirective(ParsingContext* ctx, Cm::Ast::CompileUnit* compileUnit)
            ::= UsingAliasDirective{ compileUnit->AddNode(UsingAliasDirective); }
            |   UsingNamespaceDirective{ compileUnit->AddNode(UsingNamespaceDirective); }
            ;

        UsingAliasDirective: Cm::Ast::AliasNode*
            ::= (keyword("using") Identifier '=' QualifiedId! ';'!){ value = new AliasNode(span, Identifier, QualifiedId); }
            ;

        UsingNamespaceDirective: Cm::Ast::NamespaceImportNode*
            ::= (keyword("using") QualifiedId! ';'!){ value = new NamespaceImportNode(span, QualifiedId); }
            ;

        Definitions(ParsingContext* ctx, Cm::Ast::CompileUnit* compileUnit)
            ::= (Definition(ctx, compileUnit){ compileUnit->AddNode(Definition); })*
            ;

        Definition(ParsingContext* ctx, Cm::Ast::CompileUnit* compileUnit): Cm::Ast::Node*
            ::= NamespaceDefinition(ctx, compileUnit){ value = NamespaceDefinition; }
            |   FunctionDefinition(ctx){ value = FunctionDefinition; }
            |   ConstantDefinition(ctx){ value = ConstantDefinition; }
            |   EnumerationDefinition(ctx){ value = EnumerationDefinition; }
            |   TypedefDefinition(ctx){ value = TypedefDefinition; }
            |   ClassDefinition(ctx){ value = ClassDefinition; }
            |   DelegateDefinition(ctx){ value = DelegateDefinition; }
            |   ClassDelegateDefinition(ctx){ value = ClassDelegateDefinition; }
            |   ConceptDefinition(ctx){ value = ConceptDefinition; }
            ;

        NamespaceDefinition(ParsingContext* ctx, Cm::Ast::CompileUnit* compileUnit): Cm::Ast::Node*
            ::= keyword("namespace") QualifiedId! '{'! NamespaceContent(ctx, compileUnit)! '}'!
            ;

        FunctionDefinition(ParsingContext* ctx): Cm::Ast::Node*
            ::= Function(ctx){ value = Function; }
            ;

        ConstantDefinition(ParsingContext* ctx): Cm::Ast::Node*
            ::= Constant(ctx){ value = Constant; }
            ;

        EnumerationDefinition(ParsingContext* ctx): Cm::Ast::Node*
            ::= EnumType(ctx){ value = EnumType; }
            ;

        TypedefDefinition(ParsingContext* ctx): Cm::Ast::Node*
            ::= Typedef(ctx){ value = Typedef; }
            ;

        ClassDefinition(ParsingContext* ctx): Cm::Ast::Node*
            ::= Class(ctx){ value = Class; }
            ;

        DelegateDefinition(ParsingContext* ctx): Cm::Ast::Node*
            ::= Delegate(ctx){ value = Delegate; }
            ;

        ClassDelegateDefinition(ParsingContext* ctx): Cm::Ast::Node*
            ::= ClassDelegate(ctx){ value = ClassDelegate; }
            ;

        ConceptDefinition(ParsingContext* ctx): Cm::Ast::Node*
            ::= Concept(ctx){ value = Concept; }
            ;
    }
}
